
We have designed the work on the Lurch Deductive Engine (LDE) to progress in
phases.  The idea is that each phase ends with a completed whole that can be
tested in that state, and that provides more features than the previous
state did.  By the time the final phase is complete, the LDE will be a
robust and useful product.

# LDE Design Phase 5: Interpretation

## Content

In this phase, we implement the Interpretation Phase of the LDE.

## Goal

The LDE will be able to interpret the Input Tree, creating an Output Tree
from it.

## Status

This has not been implemented.  See the tasks below.

## Building interpretation routines

 * [x] Create an `interpret` routine in the `InputStructure` class that
   takes three arguments, `accessibles` (a list of `OutputStructure`s
   accessible to the `InputStructure` in question), `childResults` (a list
   of lists of `OutputStructure` instances that were generated by recursive
   interpretation calls), and `scope` (a list of the top-level structures
   that are in the scope of the one in which `interpret` was invoked).  The
   implementation in this base class should be to create a generic
   `OutputStructure` instance and flatten all the `childResults` arrays
   into it as children, in order.  Pseudocode:
```
let result = new OutputStructure() // plain vanilla wrapper node
for each childArray in childResults:
    for each node in childArray:
        result.appendChild( node ) // put everything in it
return [ result ] // return an array of exactly one tree
```
 * [x] Add documentation in that file describing the changes just made.
 * [x] Extend the unit tests for the `InputStructure` module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.
 * [x] Add documentation in that test file describing the changes just made.
 * [x] Once the unit tests pass, build everything and commit.
 * [x] Add documentation stating the limitations on how subclasses are
   permitted to override the `interpret` routine from the `InputStructure`
   class.  Specifically, the following rules must be obeyed:
    * The routine should depend upon only the data passed to it in its
      first two parameters.
    * If `X.interpret()` calls `Y.markDirty()`, then `Y` must be in scope
      (that is, one of the elements of the `scope` array or one of their
      descendants).
 * [x] Rebuild the docs and commit.

## Building recursive interpretation

 * [x] Create a `recursiveInterpret` routine in the `InputStructure` class
   that takes two arguments, `accessibles` (with the same meaning as in the
   `interpret` routine) and `scope` (which should be the list of top-level
   structures in the scope of the object in which the function is being
   invoked).  Both arguments should default to an empty array.
   Pseudocode:
```
// remember the size of accessibles for later:
let L = the current length of the accessibles array.
// we will be recursively computing child result arrays,
// and will want to keep a list of them, so initialize that list to empty:
let allChildResults = [ ]
// we need to pass those children their scopes as well, so start with:
let childScope = a shallow copy of the list of children
// now the loop for the recursive work:
for each child C of X do the following:
    // update the child scope list by popping off its first element:
    childScope.shift()
    // do the recursion.
    // note that for the first child, the same list of accessibles for the
    // parent applies to that child:
    let childResult = C.recursiveInterpret( accessibles, childScope )
    // but for later children, more things are accessible.  specifically,
    // anything just created by interpreting C should be accessible to
    // C.nextSibling(), so:
    let accessibles = the concatenation of accessibles
        with childResult (thus extending accessibles)
    // and of course remember the result of the recursive call we just made:
    append childResult as a new entry to the end of allChildResults
        // (which is an array of arrays)
// now that we're done recurring,
// we want to restore the accessibles array to its old state:
let accessibles = just the first L entries of accessibles
    // (restoring it to what it was at the start of this routine)
// this is because we will now ask this node X to interpret itself in
// light of (a) what's accessible to it and (b) all the recursive
// results of interpreting its children.
// So we need the right accessibles array to do this:
result = X.interpret( accessibles, allChildResults, scope )
mark X as no longer dirty
then return result as the result of this function
```
 * [x] Add documentation in that file describing the changes just made.
 * [x] Extend the unit tests for the `InputStructure` module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.
 * [ ] Write more unit tests that create and register some dummy subclasses
   of `InputStructure` that have example custom `interpret` routines.
   Verify that those routines get called and do exactly what's expected in
   the creation of their portion of the Output Tree.  Ensure you test a
   variety of different kinds of `interpret` routines, including ones that
   copy or create attributes, delete children, don't include the default
   wrapper, etc.
 * [ ] Add documentation in that test file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.

## Tracking origins

 * [x] Create a class variable in the `InputStructure` class called
   `instancesBeingInterpreted` that is initialized to the empty array.
 * [x] Extend the `recursiveInterpret` routine so that, before each call to
   `X.interpret()`, it pushes `X` onto `instanceBeingInterpreted`, then pops
   after `X.interpret()` is complete.
 * [x] Extend the constructor for `OutputStructure` nodes so that, if the
   global `InputStructure` class is defined, and its
   `instanceBeingInterpreted` array is non-empty, then its last entry is
   stored within the newly constructed `OutputStructure` in a field called
   `origin`.  Otherwise, `origin` should be undefined (or null, whatever).
 * [x] Override the `OutputStructure`'s routine for creating connections so
   that, in addition to forming the connection, it also adds to its JSON
   data an `_origin` key whose value is the unique id in the Input Tree of
   the last entry on the `instanceBeingInterpreted` array, if one exists.
   (If not, leave the `_origin` field undefined.)
 * [x] Extend the unit tests for the LDE module to verify that Output Trees
   now have, in each of their nodes, the correct origin node from the Input
   Tree that gave rise to that `OutputStructure`.
 * [x] Add unit tests verifying that the `feedback()` function in
   `OutputStructure` instances correctly delegates the work to that
   instance's `origin`.
 * [x] Once the unit tests pass, build everything and commit.

## The Interpretation Phase

 * [x] Implement a `runInterpretation()` method in the LDE module.  It
   should just call `recursiveInterpret()` in the root of the Input Tree,
   store the result in the global Output Tree object, and then call a
   callback.
 * [x] Extend that implementation so that it also sends a feedback message
   when it replaces the Output Tree, indicating that the Input and Output
   Trees have been updated and are ready for exporting, should the client
   wish to query them.
 * [x] Extend the unit tests of the LDE to test this new function.  This
   should just involve taking some of the existing tests of
   `recursiveInterpret()` and redoing them to use this new name.
 * [x] Extend `runModification()` so that it no longer calls its own
   callback when complete, but instead calls `runInterpretation()` and
   passes the callback along to that function.
 * [x] Extend the unit tests to test this feature.
 * [x] Once the unit tests pass, build everything and commit.

## Adding security

One of the policies by which interpretation functions must abide is that an
`InputStructure` can call `markDirty()` only in another `InputStructure`
that is on the `scope` list, or whose ancestor is on the `scope` list.  We
introduce policing for that policy here, to prevent infinite loops in
interpretation.  We rely on the fact that one `InputStructure` is in the
`scope` variable of another (which is not the same as scope in the Input
Tree) iff it is interpreted after the other.

 * [x] Have the `runInterpretation()` method initialize a global variable to
   an empty array; it will contain the list of instances whose
   interpretations have begun.
 * [x] Each step in the `recursiveInterpret()` process should begin by
   adding the `InputStructure` being interepreted to that global array and
   writing a flag into the `InputStructure` object itself as well.
 * [x] When `runInterpretation()` calls its callback or quits and restarts
   the modification phase, erase the flags in all `InputStructure` instances
   in that array, then set the array to empty again.
 * [x] Extend `markDirty()` in the `InputStructure` class so that if the
   instance has the flag set that indicates that its interpretation has
   begun, we do not obey the request, but instead send a feedback message
   about an internal error and also write the error message to the console.
 * [x] Add unit tests of this feature by creating a few different situations
   in which such an invalid marking loop might arise, and verifying that the
   feedback is sent (and the marking-dirty prevented) in each case.
 * [x] Once the unit tests pass, build everything and commit.

Another of the policies interpretation must obey is that it should not yield
an Output Tree in which any one of the `OutputStructure` nodes has a
connection to a node outside the Output Tree.  We enforce that policy as
follows.

 * [x] Add to the end of the `runInterpretation()` function a full traversal
   of the newly created Output Tree.  At every subtree, if that node has any
   connections, examine the other side of the connection, and walk up its
   ancestor chain to verify that it is in the Output Tree.  If not, sever
   the connection.
 * [x] Add unit tests of this feature by creating a few different situations
   in which such an invalid Output Tree might arise, and verifying that the
   invalid connections (and no others) are removed in each case.
 * [x] Once the unit tests pass, build everything and commit.

## Dependency support

 * [x] Create a subclass of `InputExpression`, in the `InputStructure`
   module, called `Dependency`.  It takes an array of `OutputStructure`
   instances at construction time, and stores them.  It provides a getter
   for that same array, which can be overridden in subclasses to filter the
   array in cases where it would be helpful to do so.
 * [x] Make its `interpret()` routine simply call the getter, not even
   bothering to make copies of the results; return the original array it was
   given at construction time.
 * [x] Add documentation explaining what it is and does.
 * [x] Ensure that the `Dependency` subclass registers itself with the
   serialization code, as
   [the documentation here](https://github.com/lurchmath/lde/blob/master/src/structure.litcoffee#registering-class-names)
   describes.  (That is, use a line like
   `className : Structure.addSubclass 'Dependency', Dependency` in the
   `Dependency` class code.)
 * [x] Create a new unit test file for `Dependency` instances that not only
   ensures that the symbol `Dependency` is defined at the global scope and
   that its instances are also instances of the `InputStructure` class, but
   also that the `interpret()` routine behaves as intended, including in the
   context of recursive interpretation of the entire Input Tree.
 * [x] Add documentation for that unit test file, following the pattern
   established in the documentation of other unit test files in this
   repository.
 * [x] Once the unit tests pass, build everything and commit.

## API Documentation

 * [ ] Extend the processing phases page of the API Documentation to include
   all the work done in this phase, including interpretation.
 * [ ] Rebuild docs and commit.

## Efficiency improvements

This section lists all the potential efficiency improvements related to all
the code written during this phase of development.  Because they are only
efficiency improvements (and thus not required to make the code work
correctly), they can be deferred until later in the project.  It is not
sensible to invest development time on an efficiency improvement if we do
not even yet know whether its lack will be perceived.  If we notice any
performance bottlenecks that any of these improvements could fix, we can
return to these ideas later and follow the steps below to implement them.

### Caching interpretation results

 * [ ] Extend the `InputStructure` class with a field called
   `lastInterpretation`, which is initialized to undefined in the
   constructor.  This field does not need to be part of any serialization
   or deserialization of instances.
 * [ ] Create an `getLastInterpretation()` method that returns the value of
   that member variable.
 * [ ] Create a `saveInterpretation(I)` method in the `InputStructure` class
   that stores the array `I` (of zero or more Output Structures) in the
   `lastInterpretation` field.  If no parameter is passed, clear the cached
   value.
 * [ ] At the end of the `recursiveInterpret()` routine, just before
   returning the result, call `saveInterpretation()` on it.
 * [ ] At the start of the `recursiveInterpret()` routine, if the structure
   is not marked dirty and there is a `lastInterpretation` defined, just
   return that immediately.
 * [ ] Update all documentation in that file to reflect the changes just
   made.
 * [ ] Add to the unit tests for `InputStructure`s a few simple tests for
   these new routines.
 * [ ] Add documentation in that file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.

### Miscellaneous

 * [ ] Create a `setChildrenList(newChildren)` function in the `Structure`
   base class.  It should change as little as possible (maybe nothing) to
   make the structure's children array equal to the given one.  This lets
   `interpret()` routines reuse old Output Structures from cache, just
   adjusting their children lists, rather than constructing new ones, even
   if their children list changed.  Many `interpret()` routines may
   therefore be simply `lastInterpretation.setChildrenList(childResults)`
   followed by returning the last interpretation again.  This will often
   just verify that the children list is already correct, change nothing,
   and move on.
 * [ ] Add to the unit tests for this new routine.
 * [ ] Add documentation in the `Structure` module describing the new
   routine.
 * [ ] Once the unit tests pass, build everything and commit.

### Recursive interpretation

 * [ ] Create a subclass of `OutputStructure`, in the `OutputStructure`
   module, called `InterpretationDirective`.
 * [ ] Add documentation explaining what it is and will do (though that
   documentation can grow with time).
 * [ ] Ensure that the `InterpretationDirective` subclass registers itself
   with the serialization code, as
   [the documentation here](https://github.com/lurchmath/lde/blob/master/src/structure.litcoffee#registering-class-names)
   describes.  (That is, use a line like
   `className : Structure.addSubclass 'InterpretationDirective', InterpretationDirective` in
   the `InterpretationDirective` class code.)
 * [ ] Create a new unit test file for `InterpretationDirective`s that is
   extremely basic, just testing to be sure that the symbol
   `InterpretationDirective` is defined at the global scope and creates
   things that are instances of the `InterpretationDirective` class.
 * [ ] Add documentation for that unit test file, following the pattern
   established in the documentation of other unit test files in this
   repository.
 * [ ] Create a subclass `FilterableArray` of `Array` that, at construction
   time, is given a predicate.  It stores, internally, a filtered version of
   itself, which is initialized to the empty array.  It guarantees to keep
   this filtered version correct iff it is manipulated only through calls to
   its `push()` and `pop()` routines, which we override below.
 * [ ] Override `FilterableArray::push()` to do an ordinary `Array::push()`
   and then also a push on the internal filtered version iff the predicate
   holds of the new item.
 * [ ] Override `FilterableArray::pop()` to do an ordinary `Array::pop()`
   and then also a pop on the internal filtered version iff the object
   popped was also on the end of that array.
 * [ ] Add a new method `FilterableArray::filtered()` that returns the
   filtered version.
 * [ ] Update the default version of `recursiveInterpret()` to create the
   `accessibles` array as an instance of `FilterableArray`, with the
   predicate being whether the Structure is an instance of the
   `InterpretationDirective` class.  Ensure that adding items to the array
   and removing them from it are done with calls to `push()` and `pop()`.
 * [ ] Document this so that later implementations of `interpret()` can be
   faster by leveraging `accessibles.filtered()` rather than the entire
   `accessibles` array.
 * [ ] Ensure all the unit tests still pass.
 * [ ] Add new unit tests for the `FilterableArray` class independently of
   the rest of the LDE.
 * [ ] Add some new unit tests that verify that `accessibles.filtered()` is
   exactly what it should be (i.e., the Interpretation Directive predicate
   is being used correctly).
 * [ ] Once the unit tests pass, build everything and commit.
