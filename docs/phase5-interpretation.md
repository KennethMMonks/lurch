
We have designed the work on the Lurch Deductive Engine (LDE) to progress in
phases.  The idea is that each phase ends with a completed whole that can be
tested in that state, and that provides more features than the previous
state did.  By the time the final phase is complete, the LDE will be a
robust and useful product.

# LDE Design Phase 5: Interpretation

## Content

In this phase, we implement the Interpretation Phase of the LDE.

## Goal

The LDE will be able to interpret the Input Tree, creating an Output Tree
from it.

## Status

This has not been implemented.  See the tasks below.

## Building interpretation routines

 * [ ] Create an `interpret` routine in the `InputStructure` class that
   takes two arguments, `accessibles` (a list of `OutputStructure`s
   accessible to the `InputStructure` in question) and `childResults` (a
   list of lists of `OutputStructure` instances that were generated by
   recursive interpretation calls).  The implementation in this base class
   should be to create a generic `OutputStructure` instance and flatten all
   the `childResults` arrays into it as children, in order.  Pseudocode:
```
let result = new OutputStructure() // plain vanilla wrapper node
for each childArray in childResults:
    for each node in childArray:
        result.appendChild( node ) // put everything in it
        return [ result ] // return an array of exactly one tree
```
 * [ ] Add documentation in that file describing the changes just made.
 * [ ] Extend the unit tests for the `InputStructure` module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.
 * [ ] Add documentation in that test file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.
 * [ ] Add documentation stating the limitations on how subclasses are
   permitted to override the `interpret` routine from the `InputStructure`
   class.  Specifically, the following rules must be obeyed:
    * The routine should depend upon only the data passed to it in its
      parameters.
    * If `X.interpret()` calls `Y.markDirty()`, then the interpretation of
      `Y` must not yet have begun.  Add a note that we may, in the future,
      choose to add code that polices this restriction, but we have not yet
      done so.
 * [ ] Rebuild the docs and commit.

## Caching interpretation results

 * [ ] Extend the `InputStructure` class with a field called
   `lastInterpretation`, which is initialized to undefined in the
   constructor.  This field does not need to be part of any serialization
   or deserialization of instances.
 * [ ] Create an `getLastInterpretation()` method that returns the value of
   that member variable.
 * [ ] Create a `saveInterpretation(I)` method in the `InputStructure` class
   that stores the array `I` (of zero or more Output Structures) in the
   `lastInterpretation` field.  If no parameter is passed, clear the cached
   value.
 * [ ] Update all documentation in that file to reflect the changes just
   made.
 * [ ] Add to the unit tests for `InputStructure`s a few simple tests for
   these new routines.
 * [ ] Add documentation in that file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.

## Building recursive interpretation

 * [ ] Create a `recursiveInterpret` routine in the `InputStructure` class
   that takes one argument, `accessibles` (with the same meaning as in the
   `interpret` routine).  This argument should default to an empty array.
   Pseudocode:
```
// use the cache if it's there:
if my lastInterpretation() is not undefined, return that and quit
otherwise...
// remember the size of accessibles for later:
let L = the current length of the accessibles array.
// we will be recursively computing child result arrays,
// and will want to keep a list of them, so initialize that list to empty:
let allChildResults = [ ]
// now the loop for the recursive work:
for each child C of X do the following:
    // do the recursion.
    // note that for the first child, the same list of accessibles for the
    // parent applies to that child:
    let childResult = C.recursiveInterpret( accessibles )
    // but for later children, more things are accessible.  specifically,
    // anything just created by interpreting C should be accessible to
    // C.nextSibling(), so:
    let accessibles = the concatenation of accessibles
        with childResult (thus extending accessibles)
    // and of course remember the result of the recursive call we just made:
    append childResult as a new entry to the end of allChildResults
        // (which is an array of arrays)
// now that we're done recurring,
// we want to restore the accessibles array to its old state:
let accessibles = just the first L entries of accessibles
    // (restoring it to what it was at the start of this routine)
// this is because we will now ask this node X to interpret itself in
// light of (a) what's accessible to it and (b) all the recursive
// results of interpreting its children.
// So we need the right accessibles array to do this:
saveInterpretation( X.interpret( accessibles, allChildResults ) )
mark X as no longer dirty
then return lastInterpretation() as the result of this function
```
 * [ ] Add documentation in that file describing the changes just made.
 * [ ] Extend the unit tests for the `InputStructure` module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.
 * [ ] Write more unit tests that create and register some dummy subclasses
   of `InputStructure` that have example custom `interpret` routines.
   Verify that those routines get called and do exactly what's expected in
   the creation of their portion of the Output Tree.  Ensure you test a
   variety of different kinds of `interpret` routines, including ones that
   copy or create attributes, delete children, don't include the default
   wrapper, etc.
 * [ ] Add documentation in that test file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.

## Tracking origins

 * [ ] Create a class variable in the `InputStructure` class called
   `instancesBeingInterpreted` that is initialized to the empty array.
 * [ ] Extend the `recursiveInterpret` routine so that, before each call to
   `X.interpret()`, it pushes `X` onto `instanceBeingInterpreted`, then pops
   after `X.interpret()` is complete.
 * [ ] Extend the constructor for `OutputStructure` nodes so that, if the
   global `InputStructure` class is defined, and its
   `instanceBeingInterpreted` array is non-empty, then its last entry is
   stored within the newly constructed `OutputStructure` in a field called
   `origin`.  Otherwise, `origin` should be undefined (or null, whatever).
 * [ ] Extend the unit tests for the LDE module to verify that Output Trees
   now have, in each of their nodes, the correct origin node from the Input
   Tree that gave rise to that `OutputStructure`.
 * [ ] Once the unit tests pass, build everything and commit.

## The Interpretation Phase

 * [ ] Implement a `runInterpretation()` method in the LDE module.  It
   should just call `recursiveInterpret()` in the root of the Input Tree,
   store the result in the global Output Tree object, and then call a
   callback.
 * [ ] Extend that implementation so that it also sends a feedback message
   when it replaces the Output Tree, indicating that the Input and Output
   Trees have been updated and are ready for exporting, should the client
   wish to query them.
 * [ ] Extend the unit tests of the LDE to test this new function.  This
   should just involve taking some of the existing tests of
   `recursiveInterpret()` and redoing them to use this new name.
 * [ ] Extend `runModification()` so that it no longer calls its own
   callback when complete, but instead calls `runInterpretation()` and
   passes the callback along to that function.
 * [ ] Enhance `recursiveInterpret()` to initialize an ancestor chain array
   that marks its current position in the recursion (starting at `[]`) and
   then uses a chain of `setTimeout()` calls to move to the first child,
   next sibling, or parent, as required by the tree structure, calling the
   callback when the traversal is complete.  (Use extremely brief timeout
   delays.)
 * [ ] Ensure that the unit tests still handle this asynchronous version.
 * [ ] Enhance `runInterpretation()` so that, if any LDE API call is made
   while the interpretation phase is ongoing, it does not call the next step
   of interpretation, but rather restarts the first step of modification,
   passing it the same callback.
 * [ ] Extend the unit tests to test this feature.  That is, make some
   `interpret()` routines that take a long time to compute (say, 0.5
   seconds) and some `updateConnections()` routine that log their calls to a
   global array.  Make a set of API calls in succession about 0.3 seconds
   apart, and ensure that the global call log is as expected.
 * [ ] Once the unit tests pass, build everything and commit.

## Adding security

One of the policies by which interpretation function must abide is that no
`InputStructure` may call `markDirty()` in any `InputStructure` whose
interpretation has already begun.  We introduce policing for that policy
here, to prevent infinite loops in interpretation.

 * [ ] Have the `runInterpretation()` method initialize a global variable to
   an empty array; it will contain the list of instances whose
   interpretations have begun.
 * [ ] Each step in the `recursiveInterpret()` process should begin by
   adding the `InputStructure` being interepreted to that global array and
   writing a flag into the `InputStructure` object itself as well.
 * [ ] When `runInterpretation()` calls its callback or quits and restarts
   the modification phase, erase the flags in all `InputStructure` instances
   in that array, then set the array to empty again.
 * [ ] Extend `markDirty()` in the `InputStructure` class so that if the
   instance has the flag set that indicates that its interpretation has
   begun, we do not obey the request, but instead send a feedback message
   about an internal error and also write the error message to the console.

## Dependency support

 * [ ] Create a subclass of `InputExpression`, in the `InputStructure`
   module, called `Dependency`.  It takes an array of `OutputStructure`
   instances at construction time, and stores them.  It provides a getter
   for that same array, which can be overridden in subclasses to filter the
   array in cases where it would be helpful to do so.
 * [ ] Make its `interpret()` routine simply call the getter, not even
   bothering to make copies of the results; return the original array it was
   given at construction time.
 * [ ] Add documentation explaining what it is and does.
 * [ ] Ensure that the `Dependency` subclass registers itself with the
   serialization code, as
   [the documentation here](https://github.com/lurchmath/lde/blob/master/src/structure.litcoffee#registering-class-names)
   describes.  (That is, use a line like
   `className : Structure.addSubclass 'Dependency', Dependency` in the
   `Dependency` class code.)
 * [ ] Create a new unit test file for `Dependency` instances that not only
   ensures that the symbol `Dependency` is defined at the global scope and
   that its instances are also instances of the `InputStructure` class, but
   also that the `interpret()` routine behaves as intended, including in the
   context of recursive interpretation of the entire Input Tree.
 * [ ] Add documentation for that unit test file, following the pattern
   established in the documentation of other unit test files in this
   repository.
 * [ ] Once the unit tests pass, build everything and commit.

## API Documentation

 * [ ] Extend the processing phases page of the API Documentation to include
   all the work done in this phase, including interpretation.
 * [ ] Rebuild docs and commit.
