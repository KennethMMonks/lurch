
We have designed the work on the Lurch Deductive Engine (LDE) to progress in
phases.  The idea is that each phase ends with a completed whole that can be
tested in that state, and that provides more features than the previous
state did.  By the time the final phase is complete, the LDE will be a
robust and useful product.

# LDE Design Phase 3: Interpretation

## Content

In this phase, we add a very rudimentary `OutputStructure` class, and
methods in the Input Tree to generate it by interpreting the contents of the
input.

## Goal

The `OutputStructure` class will exist and a hierarchy of such things will
be created by the Input Tree.

## Status

This has not been implemented.  See the tasks below.

## `OutputStructure` class

 * [ ] Create a subclass of `Structure`, in its own new module,
   `src/output-structure.litcoffee`.
 * [ ] Add documentation explaining what it is and will do (though that
   documentation can grow with time).
 * [ ] Ensure that the `OutputStructure` subclass registers itself with the
   serialization code, as
   [the documentation here](https://github.com/lurchmath/lde/blob/master/src/structure.litcoffee#registering-class-names)
   describes.  (That is, use a line like
   `className : Structure.addSubclass 'OutputStructure', OutputStructure` in
   the `OutputStructure` class code.)
 * [ ] Ensure that the LDE module also imports the
   `output-structure.litcoffee` module in addition to the
   `input-structure.litcoffee` one.
 * [ ] Update all documentation in that file to reflect the changes just
   made.
 * [ ] Create a new unit test file for `OutputStructure`s that is extremely
   basic, just testing to be sure that the symbol `OutputStructure` is
   defined at the global scope and creates things that are instances of the
   generic `Structure` base class.
 * [ ] Add documentation for that unit test file, following the pattern
   established in the documentation of other unit test files in this
   repository.
 * [ ] Once the unit tests pass, build everything and commit.

## Building interpretation routines

 * [ ] Create an `interpret` routine in the `InputStructure` class that
   takes two arguments, `accessibles` (a list of `OutputStructure`s
   accessible to the `InputStructure` in question) and `childResults` (a
   list of lists of `OutputStructure` instances that were generated by
   recursive interpretation calls).  The implementation in this base class
   should be to create a generic `OutputStructure` instance and flatten all
   the `childResults` arrays into it as children, in order.  Pseudocode:
```
let result = new OutputStructure() // plain vanilla wrapper node
for each childArray in childResults:
    for each node in childArray:
        result.appendChild( node ) // put everything in it
        return [ result ] // return an array of exactly one tree
```
 * [ ] Add documentation in that file describing the changes just made.
 * [ ] Extend the unit tests for the `InputStructure` module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.
 * [ ] Add documentation in that test file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.
 * [ ] Add documentation stating the limitations on how subclasses are
   permitted to override the `interpret` routine from the `InputStructure`
   class.  Specifically, the following rules must be obeyed:
    * For any two nodes A and B in the output tree, if A was created by
      `X.interpret()` and B was created by `Y.interpret()`, and A is an
      ancestor of B, then X must be an ancestor of Y.
    * For any two nodes A and B in the output tree, if A was created by
      `X.interpret()` and B was created by `Y.interpret()`, and A has any
      ancestor that is an earlier sibling of any ancestor of B, then X must
      have an ancestor that is an earlier sibling of some ancestor of Y.
    * If `X.interpret()` calls `Y.markDirty()`, then X must be accessible
      to Y.
    * The result of `X.interpret()` may be contingent only upon the
      following data.  (This is made easy by passing this stuff as
      parameters to `X.interpret()`.  So as long as it just uses its
      parameters and children, and doesn't go seeking out other data, this
      rule is automatically followed.)
       * Any descendant `InputStructure` Y of X, including (naturally) its
         most recently computed interpretation.  (Note that X is not
         accessible to any such Y.)
       * Any `InputStructure` Y accessible to X, optionally with its most
         recently computed interpretation as well.  (Note that this does not
         include ancestors of X.)
 * [ ] Rebuild the docs and commit.

## Caching interpretation results

 * [ ] Extend the `InputStructure` class with a field called
   `lastInterpretation`, which is initialized to undefined in the
   constructor.  This field does not need to be part of any serialization
   or deserialization of instances.
 * [ ] Create an `interpretation()` method that returns the value of
   that member variable.
 * [ ] Create a `saveInterpretation(S)` method in the `InputStructure` class
   that stores `OutputStructure` `S` in the `lastInterpretation` field.  If
   no parameter `S` is passed, replace the cached value with undefined.
 * [ ] Update all documentation in that file to reflect the changes just
   made.
 * [ ] Add to the unit tests for `InputStructure`s a few simple tests for
   these new routines.
 * [ ] Add documentation in that file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.

## Building recursive interpretation

 * [ ] Create a `recursiveInterpret` routine in the `InputStructure` class
   that takes one argument, `accessibles` (with the same meaning as in the
   `interpret` routine).  This argument should default to an empty array.
   Pseudocode:
```
// use the cache if it's there:
if my lastInterpretation() is not undefined, return that and quit
otherwise...
// remember the size of accessibles for later:
let L = the current length of the accessibles array.
// we will be recursively computing child result arrays,
// and will want to keep a list of them, so initialize that list to empty:
let allChildResults = [ ]
// now the loop for the recursive work:
for each child C of X do the following:
    // do the recursion.
    // note that for the first child, the same list of accessibles for the
    // parent applies to that child:
    let childResult = C.recursiveInterpret( accessibles )
    // but for later children, more things are accessible.  specifically,
    // anything just created by interpreting C should be accessible to
    // C.nextSibling(), so:
    let accessibles = the concatenation of accessibles
        with childResult (thus extending accessibles)
    // and of course remember the result of the recursive call we just made:
    append childResult as a new entry to the end of allChildResults
        // (which is an array of arrays)
// now that we're done recurring,
// we want to restore the accessibles array to its old state:
let accessibles = just the first L entries of accessibles
    // (restoring it to what it was at the start of this routine)
// this is because we will now ask this node X to interpret itself in
// light of (a) what's accessible to it and (b) all the recursive
// results of interpreting its children.
// So we need the right accessibles array to do this:
saveInterpretation( X.interpret( accessibles, allChildResults ) )
mark X as no longer dirty
then return lastInterpretation() as the result of this function
```
 * [ ] Add documentation in that file describing the changes just made.
 * [ ] Extend the unit tests for the `InputStructure` module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.
 * [ ] Write more unit tests that create and register some dummy subclasses
   of `InputStructure` that have example custom `interpret` routines.
   Verify that those routines get called and do exactly what's expected in
   the creation of their portion of the Output Tree.  Ensure you test a
   variety of different kinds of `interpret` routines, including ones that
   copy or create attributes, delete children, don't include the default
   wrapper, etc.
 * [ ] Add documentation in that test file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.

## Calling interpretation routines

 * [ ] In the LDE module, in every one of the four functions it exposes as
   part of its API, extend the function so that it calls `.markDirty()` on
   the appropriate `InputStructure` instance, then
   `.recursiveInterpret()` on the root of the LDE document (the Input Tree).
 * [ ] Update the documentation in that file to describe the changes just
   made.
 * [ ] Extend the unit tests for the LDE module to verify that this
   assembles an Output Tree that (by default) has exactly the same structure
   as the Input Tree (but no actual content, just base class nodes).
 * [ ] Write more unit tests that create and register some dummy subclasses
   of `InputStructure` that have example custom `interpret` routines.
   Verify that those routines get called and do exactly what's expected in
   the creation of the Output Tree.  Ensure you test a variety of different
   kinds of `interpret` routines, as you did in the previous section.
 * [ ] Add documentation in that test file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.

## Tracking origins

 * [ ] Create a class variable in the `InputStructure` class called
   `instanceBeingInterpreted` that is initialized to null.
 * [ ] Extend the `recursiveInterpret` routine so that, before each call to
   `X.interpret()`, it sets `instanceBeingInterpreted` to `X`, then sets it
   back to null after `X.interpret()` is complete.
 * [ ] Extend the constructor for `OutputStructure` nodes so that, if the
   global `InputStructure` class is defined, and its
   `instanceBeingInterpreted` variable is non-null, then that instance is
   stored within the newly constructed `OutputStructure` in a field called
   `origin`.  Otherwise, `origin` should be undefined (or null, whatever).
 * [ ] Extend the unit tests for the LDE module to verify that Output Trees
   now have, in each of their nodes, the correct origin node from the Input
   Tree that gave rise to that `OutputStructure`.
 * [ ] Once the unit tests pass, build everything and commit.

## Feedback messages

 * [ ] Add a function to the LDE module that can be called whenever the
   Input Tree wants to communicate to the UI some attribute of a node in the
   Input Tree.  That function will send a message (to any listening client)
   containing the ID of the node and a key-value pair for the attribute in
   question.
 * [ ] Extend each of the LDE module's API functions so that, when any new
   `InputStructure` instances are added in the Input Tree, we recursively go
   through them and all their descendants, and set their `wasChanged` event
   handlers to call that global message sending function.  It should not
   filter out any such messages by default; rather, the LDE can make
   guarantees in its documentation about certain attribute keys that
   follow certain rules, and the UI can choose whichever subset of those
   keys it wants to watch for and display to the user in some way.  This
   will include feedback about validation, but may include other things as
   well.  Example:
    * Consider a step of work that needs two premises, but none were cited,
      and the option is enabled that lets Lurch seek the premises automatically.
    * So Lurch fills in the preceding two steps as the reasons, and as it
      does so, it might store in one of the step's attributes the fact that
      it auto-filled, as the premises, those two preceding steps.
    * A user interface might choose to implement a feature that watched for
      when such an attribute appears on an OT node, and then display the
      meaning of that attribute to the user, perhaps by showing
      faint/dotted arrows connecting the step to its auto-inserted premises.
    * In other words, when premises aren't provided, the user will just see
      ghostly connections that communicate what the LDE inferred.  No more
      mystery about which premises are auto-filled.
 * [ ] Update the documentation in that file to describe the changes just
   made.
 * [ ] Extend the unit tests for the LDE module to verify that this
   works as described.  (Change attributes of some nodes in the Input Tree
   and verify that messages are sent by the LDE to that effect.)
 * [ ] Add documentation in that test file describing the changes just made.
 * [ ] Once the unit tests pass, build everything and commit.
