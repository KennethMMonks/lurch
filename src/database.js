

/////////////////////////////////////////////////
// DO NOT EDIT THIS SOURCE CODE FILE DIRECTLY. //
// IT IS AUTOGENERATED BY npm run build-db.    //
/////////////////////////////////////////////////

// Instead, edit database/footer.js, database/generate.js, or any of the
// .putdown or .smackdown files recursively stored in any subfolder of the
// database folder.

// This file begins with the database as a large JSON object,
// then ends with JavaScript code that provides access to it.

const testingDatabase = [
  {
    "filename": "/matching tests/test 1.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(and P Q)  (and a (or b c))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  a\n\t\tQ  (or b c)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 10.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (A 1 2 3)\n\t(@apply P x)  (A 2 1 3)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 11.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (f 1 2)\n\t(@apply P y)  (f 1 2)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  f\n\t\ty  f\n\t\tP  (@lambda v , (v 1 2))\n\t)\n\t( // solution 2\n\t\tx  1\n\t\ty  1\n\t\tP  (@lambda v , (f v 2))\n\t)\n\t( // solution 3\n\t\tx  2\n\t\ty  2\n\t\tP  (@lambda v , (f 1 v))\n\t)\n\t( // solution 4\n\t\tx  (f 1 2)\n\t\ty  (f 1 2)\n\t\tP  (@lambda v , v)\n\t)\n\t( // solution 5\n\t\tP  (@lambda v , (f 1 2))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 12.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (g k (e 2))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  (g k (e 2))\n\t\tP  (@lambda v , v)\n\t)\n\t( // solution 2\n\t\tx  g\n\t\tP  (@lambda v , (v k (e 2)))\n\t)\n\t( // solution 3\n\t\tx  k\n\t\tP  (@lambda v , (g v (e 2)))\n\t)\n\t( // solution 4\n\t\tx  (e 2)\n\t\tP  (@lambda v , (g k v))\n\t)\n\t( // solution 5\n\t\tx  e\n\t\tP  (@lambda v , (g k (v 2)))\n\t)\n\t( // solution 6\n\t\tx  2\n\t\tP  (@lambda v , (g k (e v)))\n\t)\n\t( // solution 7\n\t\tP  (@lambda v , (g k (e 2)))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 13.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (f a a)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  (f a a)\n\t\tP  (@lambda v , v)\n\t)\n\t( // solution 2\n\t\tx  f\n\t\tP  (@lambda v , (v a a))\n\t)\n\t( // solution 3\n\t\tx  a\n\t\tP  (@lambda v , (f a v))\n\t)\n\t( // solution 4\n\t\tx  a\n\t\tP  (@lambda v , (f v a))\n\t)\n\t( // solution 5\n\t\tx  a\n\t\tP  (@lambda v , (f v v))\n\t)\n\t( // solution 6\n\t\tP  (@lambda v , (f a a))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 14.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (f a a)\n\tx             b\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  b\n\t\tP  (@lambda v , (f a a))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 15.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (f a a)\n\tx             f\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  f\n\t\tP  (@lambda v , (v a a))\n\t)\n\t( // solution 2\n\t\tx  f\n\t\tP  (@lambda v , (f a a))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 16.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P a Q b)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P a)  (eq 3 3)\n\t(@apply Q b)  (gt 5 4)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\ta  (eq 3 3)\n\t\tP  (@lambda v , v)\n\t\tb  (gt 5 4)\n\t\tQ  (@lambda v , v)\n\t)\n\t( // solution 2\n\t\ta  eq\n\t\tP  (@lambda v , (v 3 3))\n\t\tb  (gt 5 4)\n\t\tQ  (@lambda v , v)\n\t)\n\t( // solution 3\n\t\ta  3\n\t\tP  (@lambda v , (eq v v))\n\t\tb  (gt 5 4)\n\t\tQ  (@lambda v , v)\n\t)\n\t( // solution 4\n\t\ta  3\n\t\tP  (@lambda v , (eq v 3))\n\t\tb  (gt 5 4)\n\t\tQ  (@lambda v , v)\n\t)\n\t( // solution 5\n\t\ta  3\n\t\tP  (@lambda v , (eq 3 v))\n\t\tb  (gt 5 4)\n\t\tQ  (@lambda v , v)\n\t)\n\t( // solution 6\n\t\tP  (@lambda v , (eq 3 3))\n\t\tb  (gt 5 4)\n\t\tQ  (@lambda v , v)\n\t)\n\t( // solution 7\n\t\ta  (eq 3 3)\n\t\tP  (@lambda v , v)\n\t\tb  gt\n\t\tQ  (@lambda v , (v 5 4))\n\t)\n\t( // solution 8\n\t\ta  eq\n\t\tP  (@lambda v , (v 3 3))\n\t\tb  gt\n\t\tQ  (@lambda v , (v 5 4))\n\t)\n\t( // solution 9\n\t\ta  3\n\t\tP  (@lambda v , (eq v v))\n\t\tb  gt\n\t\tQ  (@lambda v , (v 5 4))\n\t)\n\t( // solution 10\n\t\ta  3\n\t\tP  (@lambda v , (eq v 3))\n\t\tb  gt\n\t\tQ  (@lambda v , (v 5 4))\n\t)\n\t( // solution 11\n\t\ta  3\n\t\tP  (@lambda v , (eq 3 v))\n\t\tb  gt\n\t\tQ  (@lambda v , (v 5 4))\n\t)\n\t( // solution 12\n\t\tP  (@lambda v , (eq 3 3))\n\t\tb  gt\n\t\tQ  (@lambda v , (v 5 4))\n\t)\n\t( // solution 13\n\t\ta  (eq 3 3)\n\t\tP  (@lambda v , v)\n\t\tb  5\n\t\tQ  (@lambda v , (gt v 4))\n\t)\n\t( // solution 14\n\t\ta  eq\n\t\tP  (@lambda v , (v 3 3))\n\t\tb  5\n\t\tQ  (@lambda v , (gt v 4))\n\t)\n\t( // solution 15\n\t\ta  3\n\t\tP  (@lambda v , (eq v v))\n\t\tb  5\n\t\tQ  (@lambda v , (gt v 4))\n\t)\n\t( // solution 16\n\t\ta  3\n\t\tP  (@lambda v , (eq v 3))\n\t\tb  5\n\t\tQ  (@lambda v , (gt v 4))\n\t)\n\t( // solution 17\n\t\ta  3\n\t\tP  (@lambda v , (eq 3 v))\n\t\tb  5\n\t\tQ  (@lambda v , (gt v 4))\n\t)\n\t( // solution 18\n\t\tP  (@lambda v , (eq 3 3))\n\t\tb  5\n\t\tQ  (@lambda v , (gt v 4))\n\t)\n\t( // solution 19\n\t\ta  (eq 3 3)\n\t\tP  (@lambda v , v)\n\t\tb  4\n\t\tQ  (@lambda v , (gt 5 v))\n\t)\n\t( // solution 20\n\t\ta  eq\n\t\tP  (@lambda v , (v 3 3))\n\t\tb  4\n\t\tQ  (@lambda v , (gt 5 v))\n\t)\n\t( // solution 21\n\t\ta  3\n\t\tP  (@lambda v , (eq v v))\n\t\tb  4\n\t\tQ  (@lambda v , (gt 5 v))\n\t)\n\t( // solution 22\n\t\ta  3\n\t\tP  (@lambda v , (eq v 3))\n\t\tb  4\n\t\tQ  (@lambda v , (gt 5 v))\n\t)\n\t( // solution 23\n\t\ta  3\n\t\tP  (@lambda v , (eq 3 v))\n\t\tb  4\n\t\tQ  (@lambda v , (gt 5 v))\n\t)\n\t( // solution 24\n\t\tP  (@lambda v , (eq 3 3))\n\t\tb  4\n\t\tQ  (@lambda v , (gt 5 v))\n\t)\n\t( // solution 25\n\t\ta  (eq 3 3)\n\t\tP  (@lambda v , v)\n\t\tQ  (@lambda v , (gt 5 4))\n\t)\n\t( // solution 26\n\t\ta  eq\n\t\tP  (@lambda v , (v 3 3))\n\t\tQ  (@lambda v , (gt 5 4))\n\t)\n\t( // solution 27\n\t\ta  3\n\t\tP  (@lambda v , (eq v v))\n\t\tQ  (@lambda v , (gt 5 4))\n\t)\n\t( // solution 28\n\t\ta  3\n\t\tP  (@lambda v , (eq v 3))\n\t\tQ  (@lambda v , (gt 5 4))\n\t)\n\t( // solution 29\n\t\ta  3\n\t\tP  (@lambda v , (eq 3 v))\n\t\tQ  (@lambda v , (gt 5 4))\n\t)\n\t( // solution 30\n\t\tP  (@lambda v , (eq 3 3))\n\t\tQ  (@lambda v , (gt 5 4))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 17.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq t 1)\n\t(@apply P a)  (gt t 0)\n\t(@apply P b)  (gt 1 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\ta  t\n\t\tb  1\n\t\tP  (@lambda v , (gt v 0))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 18.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq t 1)\n\t(@apply P a)  (gt 1 0)\n\t(@apply P b)  (gt t 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 19.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq t 1)\n\t(@apply P a)  (eq (plus t 1) 2)\n\t(@apply P b)  (eq (plus 1 1) 2)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\ta  t\n\t\tb  1\n\t\tP  (@lambda v , (eq (plus v 1) 2))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 2.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables X Y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(multiply (plus X Y) (minus X Y))  (multiply (plus 3 k) (minus 3 p))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 20.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq t 1)\n\t(@apply P a)  (eq (plus 1 1) 2)\n\t(@apply P b)  (eq (plus t 1) 2)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 21.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq 1 2)\n\t(@apply P a)  (eq (plus 1 1) 2)\n\t(@apply P b)  (eq (plus 2 2) 2)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\ta  1\n\t\tb  2\n\t\tP  (@lambda v , (eq (plus v v) 2))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 22.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq 1 2)\n\t(@apply P a)  (eq (plus 1 1) 2)\n\t(@apply P b)  (eq (plus 2 1) 2)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\ta  1\n\t\tb  2\n\t\tP  (@lambda v , (eq (plus v 1) 2))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 23.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq 1 2)\n\t(@apply P a)  (eq (plus 1 1) 2)\n\t(@apply P b)  (eq (plus 1 2) 2)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\ta  1\n\t\tb  2\n\t\tP  (@lambda v , (eq (plus 1 v) 2))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 24.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq 1 2)\n\t(@apply P a)  (eq (plus 1 1) 2)\n\t(@apply P b)  (eq (plus 1 1) 2)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\ta  1\n\t\tb  2\n\t\tP  (@lambda v , (eq (plus 1 1) 2))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 25.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq 1 2)\n\t(@apply P a)  (eq (plus 1 1) 2)\n\t(@apply P b)  (eq (plus 2 2) 1)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 26.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq 1 2)\n\t(@apply P a)  (eq (plus 1 1) 2)\n\t(@apply P b)  (eq (plus 1 1) 1)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 27.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(eq a b)      (eq x y)\n\t(@apply P a)  (exists y , (neq y x))\n\t(@apply P b)  (exists y , (neq y y))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 28.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (gte x 0))\n\t(@apply P t)               (gte 7 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tt  7\n\t\tP  (@lambda v , (gte v 0))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 29.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (gte x 0))\n\t(@apply P t)               (gte 7 7)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 3.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(and (@apply P 1) (@apply P 2))  (and (neq 0 1) (neq 0 2))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (neq 0 v))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 30.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , Q)\n\t(@apply P t)               Q\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tP  (@lambda v , Q)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 31.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall s , (eq (sq s) s))\n\t(@apply P t)               (eq (sq 1) 1)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  s\n\t\tP  (@lambda v , (eq (sq v) v))\n\t\tt  1\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 32.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (R x y))\n\t(@apply P t)               (R x 3)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 33.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (R x y))\n\t(@apply P t)               (R 3 y)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tP  (@lambda v , (R v y))\n\t\tt  3\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 34.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (R x x))\n\t(@apply P t)               (R 3 3)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tP  (@lambda v , (R v v))\n\t\tt  3\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 35.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (R x x))\n\t(@apply P t)               (R 3 x)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 36.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (R x x))\n\t(@apply P t)               (R x 3)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 37.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (R x x))\n\t(@apply P t)               (R x x)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tP  (@lambda v , (R v v))\n\t\tt  x\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 38.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall s , (eq (plus s s) r))\n\t(@apply P t)               (eq (plus t s) r)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 39.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P t)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall x , (eq x x))\n\t(@apply P t)               (eq (iff P Q) (iff P Q))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tP  (@lambda v , (eq v v))\n\t\tt  (iff P Q)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 4.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P T)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(forall x , (@apply P x))  (forall r , (gt (plus (sq r) 1) 0))\n\t(@apply P T)               (gt (plus (sq -9) 1) 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tT  -9\n\t\tx  r\n\t\tP  (@lambda v , (gt (plus (sq v) 1) 0))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 40.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (r a a))\n\t(forall x , (@apply P x))    (forall b , (r b b))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// The following would be a solution if we permitted users to deduce\n\t// a conclusion that's alpha-equivalent to the explicitly permitted one,\n\t// but we actually don't plan to support that, and our matching algorithm\n\t// doesn't support it either, so we comment this \"solution\" out.\n\t// (\n\t// \tx  a\n\t// \tP  (@lambda v , (r v v))\n\t// )\n)\n"
  },
  {
    "filename": "/matching tests/test 41.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (r a a))\n\t(forall x , (@apply P x))    (forall b , (r b b))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (r v v))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 42.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (r a a))\n\t(forall y , (@apply P y))    (forall b , (r b b))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  a\n\t\tP  (@lambda v , (r v v))\n\t\ty  b\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 43.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (r a a))\n\t(forall y , (@apply P y))    (forall b , (r b b))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (r v v))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 44.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (gt a 3))\n\t(forall y , (@apply P y))    (forall a , (gt a 3))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  a\n\t\tP  (@lambda v , (gt v 3))\n\t\ty  a\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 45.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (gt a 3))\n\t(forall y , (@apply P y))    (forall x , (gt x 3))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  a\n\t\tP  (@lambda v , (gt v 3))\n\t\ty  x\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 46.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof T , (R T T))\n\t(forall y , (@apply P y))    (forall T , (R T T))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  T\n\t\tP  (@lambda v , (R v v))\n\t\ty  T\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 47.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof T , (R T T))\n\t(forall y , (@apply P y))    (forall x , (R T x))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 48.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof y , (neq 0 1))\n\t(forall y , (@apply P y))    (forall z , (neq 0 1))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  y\n\t\tP  (@lambda v , (neq 0 1))\n\t\ty  z\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 49.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof b , (eq (minus b b) 0))\n\t(forall y , (@apply P y))    (forall c , (eq (minus b c) 0))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 5.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables X P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(w   (w X (@apply P X))        (forall x , (@apply P x)))\n\t(w   (w k (lt (plus k 1) 5))   (forall s , (lt (plus s 1) 5)))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tX  k\n\t\tP  (@lambda v , (lt (plus v 1) 5))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 50.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (gt a 3))\n\t(forall x , (@apply P x))    (forall a , (gt a 3))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  a\n\t\tP  (@lambda v , (gt v 3))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 51.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof a , (gt a 3))\n\t(forall x , (@apply P x))    (forall x , (gt x 3))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// The following would be a solution if we permitted users to deduce\n\t// a conclusion that's alpha-equivalent to the explicitly permitted one,\n\t// but we actually don't plan to support that, and our matching algorithm\n\t// doesn't support it either, so we comment this \"solution\" out.\n\t// (\n\t// \tx  a\n\t// \tP  (@lambda v , (gt v 3))\n\t// )\n)\n"
  },
  {
    "filename": "/matching tests/test 52.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof T , (R T T))\n\t(forall x , (@apply P x))    (forall T , (R T T))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  T\n\t\tP  (@lambda v , (R v v))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 53.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof T , (R T T))\n\t(forall x , (@apply P x))    (forall x , (R T x))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 54.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof y , (neq 0 1))\n\t(forall x , (@apply P x))    (forall y , (neq 0 1))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  y\n\t\tP  (@lambda v , (neq 0 1))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 55.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof x , (eq x x))\n\t(forall y , (@apply P y))    (forall x , (eq x x))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\ty  x\n\t\tP  (@lambda v , (eq v v))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 56.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(Subproof x , (@apply P x))  (Subproof x , (exists y , (lt x y)))\n\t(forall x , (@apply P x))    (forall y , (exists y , (lt y y)))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 57.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P t x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P t)               (gt 1 0)\n\t(exists x , (@apply P x))  (exists x , (gt x 0))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (gt v 0))\n\t\tt  1\n\t\tx  x\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 58.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P t x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P t)               (eq (choose 6 3) 20)\n\t(exists x , (@apply P x))  (exists n , (eq (choose 6 n) 20))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (eq (choose 6 v) 20))\n\t\tt  3\n\t\tx  n\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 59.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P t x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P t)               (lt (pow t x) 5)\n\t(exists x , (@apply P x))  (exists x , (lt (pow x x) 5))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 6.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(w (exists x , (@apply P x)) (forall y , (implies (@apply P y) Q)) Q)  (w (exists x , (eq (cubed x) -1)) (forall x , (implies (eq (cubed x) -1) (lt x 5))) (lt x 5))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 60.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P t x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P t)               (neq x t)\n\t(exists x , (@apply P x))  (exists y , (neq y t))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (neq v t))\n\t\tt  x\n\t\tx  y\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 61.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P t x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P t)               (neq x t)\n\t(exists x , (@apply P x))  (exists x , (neq x x))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 62.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P t x)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P t)               (forall t , (eq t t))\n\t(exists x , (@apply P x))  (exists x , (forall t , (eq x t)))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 63.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (gte 0 0)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall n , (implies (gte n 0) (gte (plus n 1) 0)))\n\t(forall n , (@apply P n))                                  (forall n , (gte n 0))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (gte v 0))\n\t\tk  n\n\t\tn  n\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 64.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (eq (plus 0 0) 0)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall m , (implies (eq (plus m 0) m) (eq (plus (plus m 1) 0) (plus m 1))))\n\t(forall n , (@apply P n))                                  (forall k , (eq (plus k 0) k))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (eq (plus v 0) v))\n\t\tk  m\n\t\tn  k\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 65.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (P 0)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall k , (implies (P k) (P (plus k 1))))\n\t(forall n , (@apply P n))                                  (forall n , (P n))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (P v))\n\t\tk  k\n\t\tn  n\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 66.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (eq 7 5)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall n , (implies (eq 7 5) (eq 7 5)))\n\t(forall n , (@apply P n))                                  (forall n , (eq 7 5))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tP  (@lambda v , (eq 7 5))\n\t\tk  n\n\t\tn  n\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 67.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (R n 1)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall m , (implies (R m 1) (R (plus m 1) 1)))\n\t(forall n , (@apply P n))                                  (forall m , (R m 1))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 68.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (gte k 0)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall k , (implies (gte k k) (gte k (plus k 1))))\n\t(forall n , (@apply P n))                                  (forall n , (gte n k))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 69.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (gte n 0)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall k , (implies (gte n k) (gte n (plus k 1))))\n\t(forall n , (@apply P n))                                  (forall n , (gte n n))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 7.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (b 2)\n\t(@apply P y)  (b 3)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  (b 2)\n\t\ty  (b 3)\n\t\tP  (@lambda v , v)\n\t)\n\t( // solution 2\n\t\tx  2\n\t\ty  3\n\t\tP  (@lambda v , (b v))\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 70.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P k n)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P 0)                                               (gte 0 0)\n\t(forall k , (implies (@apply P k) (@apply P (plus k 1))))  (forall n , (implies (gte n 0) (gte 0 (plus n 1))))\n\t(forall n , (@apply P n))                                  (forall n , (gte 0 0))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 71.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists x , (eq (sq x) 1))\n\t(forall x , (implies (@apply P x) Q))  (forall x , (implies (eq (sq x) 1) (gte 1 0)))\n\tQ                                      (gte 1 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tP  (@lambda v , (eq (sq v) 1))\n\t\tQ  (gte 1 0)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 72.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists x , (eq (sq x) 1))\n\t(forall x , (implies (@apply P x) Q))  (forall x , (implies (eq (sq x) 1) (lte x 1)))\n\tQ                                      (lte x 1)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 73.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists x , (gt x 0))\n\t(forall x , (implies (@apply P x) Q))  (implies (forall x , (gt x 0)) (gt -1 0))\n\tQ                                      (gt -1 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 74.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists x , (gt x 0))\n\t(forall x , (implies (@apply P x) Q))  (forall x , (implies (gt x 0) (gt -1 0)))\n\tQ                                      (gt -1 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\tP  (@lambda v , (gt v 0))\n\t\tQ  (gt -1 0)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 75.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists m , (gt m 0))\n\t(forall x , (implies (@apply P x) Q))  (forall m , (implies (gt m 0) (gt -1 0)))\n\tQ                                      (gt -1 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  m\n\t\tP  (@lambda v , (gt v 0))\n\t\tQ  (gt -1 0)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 76.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists x , (gt x 0))\n\t(forall y , (implies (@apply P y) Q))  (forall x , (implies (gt x 0) (gt -1 0)))\n\tQ                                      (gt -1 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  x\n\t\ty  x\n\t\tP  (@lambda v , (gt v 0))\n\t\tQ  (gt -1 0)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 77.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists m , (gt m 0))\n\t(forall y , (implies (@apply P y) Q))  (forall n , (implies (gt n 0) (gt -1 0)))\n\tQ                                      (gt -1 0)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  m\n\t\ty  n\n\t\tP  (@lambda v , (gt v 0))\n\t\tQ  (gt -1 0)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 78.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables x P y Q)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))              (exists n , (lt n a))\n\t(forall y , (implies (@apply P y) Q))  (forall a , (implies (lt a a) (lt a a)))\n\tQ                                      (lt a a)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t// no solutions\n)\n"
  },
  {
    "filename": "/matching tests/test 79.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// Declare the metavariables in this matching problem:\n(metavariables x P y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(exists x , (@apply P x))  (exists t , (exists p , (b t p)))\n\t(@apply P y)               (exists p , (b n p))\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t(\n        x  t\n        y  n\n        P  (@lambda v , (exists p , (b v p)))\n    )\n)\n"
  },
  {
    "filename": "/matching tests/test 8.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (equals (plus 2 3) 5)\n\t(@apply P y)  (equals 5 5)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  (plus 2 3)\n\t\ty  5\n\t\tP  (@lambda v , (equals v 5))\n\t)\n\t( // solution 2\n\t\tx  (equals (plus 2 3) 5)\n\t\ty  (equals 5 5)\n\t\tP  (@lambda v , v)\n\t)\n)\n"
  },
  {
    "filename": "/matching tests/test 9.putdown",
    "metadata": {
      "testing": {
        "type": "matching"
      }
    },
    "content": "\n// This file was autogenerated as part of an export process from an old repository.\n\n// Declare the metavariables in this matching problem:\n(metavariables P x y)\n\n// List the pattern-expression pairs in this matching problem:\n(problem\n\t(@apply P x)  (A 1 2 3)\n\t(@apply P y)  (A 2 1 3)\n)\n\n// List all solutions in this matching problem:\n(solutions\n\t( // solution 1\n\t\tx  (A 1 2 3)\n\t\ty  (A 2 1 3)\n\t\tP  (@lambda v , v)\n\t)\n)\n"
  },
  {
    "filename": "/multi-matching tests/test 1.putdown",
    "metadata": {
      "testing": {
        "type": "multi-matching"
      }
    },
    "content": "\n// Declare the metavariables in this matching problem:\n(metavariables x y)\n\n// List the pattern-then-expressions tuples in this multi-matching problem:\n(problem\n    (constraint  (and x y)    (and 1 2)  (and 3 4)  )\n    (constraint  (and 3 y)    (and 1 4)  (and 3 2)  )\n)\n\n// List all solutions in this matching problem:\n// (Note that each one comes with a list of indices,\n// followed by a metavariable assignment.)\n(solutions\n    (0 1)\n    (\n        x  1\n        y  2\n    )\n)\n"
  },
  {
    "filename": "/multi-matching tests/test 2.putdown",
    "metadata": {
      "testing": {
        "type": "multi-matching"
      }
    },
    "content": "\n// Declare the metavariables in this matching problem:\n(metavariables P x t)\n\n// List the pattern-then-expressions tuples in this multi-matching problem:\n(problem\n    (constraint  (forall x , (@apply P x))\n                 (> 5 n)\n                 (forall k , (happier k 7))\n                 (forall q , (= (+ q r) t))\n                 (exists foo , bar)  )\n    (constraint  (@apply P t)\n                 (= (+ 9 r) t)  )\n)\n\n// List all solutions in this matching problem:\n// (Note that each one comes with a list of indices,\n// followed by a metavariable assignment.)\n(solutions\n    (2 0)\n    (\n        x  q\n        t  9\n        P  (@lambda v , (= (+ v r) t))\n    )\n)\n"
  },
  {
    "filename": "/multi-matching tests/test 3.putdown",
    "metadata": {
      "testing": {
        "type": "multi-matching"
      }
    },
    "content": "\n// Declare the metavariables in this matching problem:\n(metavariables A B C)\n\n// List the pattern-then-expressions tuples in this multi-matching problem:\n(problem\n    (constraint  (or A B)  (or p p)  (=> p p)  p  )\n    (constraint  (=> A C)  (or p p)  (=> p p)  p  )\n    (constraint  (=> B C)  (or p p)  (=> p p)  p  )\n    (constraint  C         (or p p)  (=> p p)  p  )\n)\n\n// List all solutions in this matching problem:\n// (Note that each one comes with a list of indices,\n// followed by a metavariable assignment.)\n(solutions\n    (0 1 1 2)\n    (\n        A  p\n        B  p\n        C  p\n    )\n)\n"
  },
  {
    "filename": "/multi-matching tests/test 4.putdown",
    "metadata": {
      "testing": {
        "type": "multi-matching"
      }
    },
    "content": "\n// Declare the metavariables in this matching problem:\n(metavariables a b P)\n\n// List the pattern-then-expressions tuples in this multi-matching problem:\n(problem\n    (constraint  (= a b)\n                 (> (squared 5) (squared x))\n                 (= (+ 3 1) 4)\n                 (= x 4)\n                 (= y 3)  )\n    (constraint  (@apply P a)\n                 (> (squared 5) (squared x))\n                 (= (+ 3 1) 4)\n                 (= x 4)\n                 (= y 3)  )\n    (constraint  (@apply P b)\n                 (> (squared 5) (squared 4))  )\n)\n\n// List all solutions in this matching problem:\n// (Note that each one comes with a list of indices,\n// followed by a metavariable assignment.)\n(solutions\n    (2 0 0)\n    (\n        a  x\n        b  4\n        P  (@lambda v , (> (squared 5) (squared v)))\n    )\n)\n"
  },
  {
    "filename": "/parsing tests/syntax error 1.putdown",
    "metadata": {
      "testing": {
        "syntax": "invalid"
      }
    },
    "content": "\n// This file contains an Expression with an Environment inside, which is\n// invalid putdown syntax.\n\n(+ 1 2 { :A B })\n"
  },
  {
    "filename": "/parsing tests/syntax error 2.putdown",
    "metadata": {
      "testing": {
        "syntax": "invalid"
      }
    },
    "content": "\n{* A B C *} // invalid because we deleted formula notation\n"
  },
  {
    "filename": "/parsing tests/valid syntax 1.putdown",
    "metadata": {
      "testing": {
        "syntax": "valid",
        "length": 4
      }
    },
    "content": "\n// This file contains several Expressions, all using valid putdown notation.\n\n(+ 1 2)\n\n(- k t (* u v))\n\n(polynomial (variable x) (coefficients 9 0 -6 2 1))\n\n(forall x , (exists y , (> x y)))\n"
  },
  {
    "filename": "/parsing tests/valid syntax 2.putdown",
    "metadata": {
      "testing": {
        "syntax": "valid",
        "length": 1
      }
    },
    "content": "\n// This file contains some nested Environments, Expressions, and Declarations,\n// all using valid putdown syntax.\n\n{\n    // Let x be arbitrary.\n    [x]\n    // Assume x is a real number.\n    :(in x R)\n    // Claim that x is a complex number, by Theorem 21\n    (in x C) +{\"reason\":\"Theorem 21\"}\n}\n"
  },
  {
    "filename": "/parsing tests/syntax error 1.smackdown",
    "metadata": {
      "testing": {
        "syntax": "invalid"
      }
    },
    "content": "\n// This file contains an Expression with an Environment inside, which is\n// invalid smackdown syntax, because it is invalid putdown syntax.\n\n(+ 1 2 { :A B })\n"
  },
  {
    "filename": "/parsing tests/syntax error 2.smackdown",
    "metadata": {
      "testing": {
        "syntax": "invalid"
      }
    },
    "content": "\n\\label{hello}   // invalid because it is preceded by no LC to modify\n(one two three)\n"
  },
  {
    "filename": "/parsing tests/valid syntax 1.smackdown",
    "metadata": {
      "testing": {
        "syntax": "valid",
        "length": 3
      }
    },
    "content": "\n// This file contains several examples of valid smackdown expressions\n\n(+ 1 2)    // valid putdown\n\n$k-t-u*v$  // a smackdown \"notation\" atom (for later parsing)\n\n(forall x , (exists y , $x>y$))  // smackdown inside putdown is also valid\n"
  },
  {
    "filename": "/parsing tests/valid syntax 2.smackdown",
    "metadata": {
      "testing": {
        "syntax": "valid",
        "length": 1
      }
    },
    "content": "\n// This file contains more complex smackdown, including labels,\n// references, and proof markers.\n\n\\begin{proof}\n    // Let x be arbitrary and mark it with label \"1\"\n    [x]        \\label{1}\n    // Assume x is a real number and mark it with label \"2\"\n    :$x∈R$     \\label{2}\n    // Claim that x is a complex number, by Theorem 21\n    $x∈C$      \\reason{Theorem 21}\n    // (Even though no reason command has a built-in meaning implemented,\n    // smackdown will still parse it and remember it was a command.)\n\\end{proof}\n"
  },
  {
    "filename": "/propositional logic/all rules.putdown",
    "metadata": {
      "includes": [
        "declare connectives.putdown",
        "conjunction introduction.putdown",
        "conjunction elimination.putdown",
        "disjunction introduction.putdown",
        "disjunction elimination.putdown",
        "conditional introduction.putdown",
        "conditional elimination.putdown",
        "negation introduction.putdown",
        "negation elimination.putdown",
        "biconditional introduction.putdown",
        "biconditional elimination.putdown"
      ]
    },
    "content": "\n// Declare the logical connectives as constants:\n\n[and or not implies iff const]\n\n\n{\n    :A\n    :B\n    (and A B)\n}\n\n\n{\n    :(and A B)\n    A\n    B\n}\n\n\n{\n    :A\n    (or A B)\n}\n\n{\n    :B\n    (or A B)\n}\n\n\n{\n    :(or A B)\n    :(implies A C)\n    :(implies B C)\n    C\n}\n\n\n{\n    :{\n        :A\n        B\n    }\n    (implies A B)\n}\n\n\n{\n    :(implies A B)\n    :A\n    B\n}\n\n\n{\n    :{\n        :A\n        B\n        (not B)\n    }\n    (not A)\n}\n\n\n{\n    :{\n        :(not A)\n        B\n        (not B)\n    }\n    A\n}\n\n\n{\n    :{\n        :A\n        B\n    }\n    :{\n        :B\n        A\n    }\n    (iff A B)\n}\n\n\n{\n    :(iff A B)\n    :A\n    B\n}\n\n{\n    :(iff A B)\n    :B\n    A\n}\n\n",
    "original": ""
  },
  {
    "filename": "/propositional logic/biconditional elimination.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "biconditional elimination",
        "<->E"
      ]
    },
    "content": "\n{\n    :(iff A B)\n    :A\n    B\n}\n\n{\n    :(iff A B)\n    :B\n    A\n}\n"
  },
  {
    "filename": "/propositional logic/biconditional introduction.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "conditional introduction",
        "->I"
      ]
    },
    "content": "\n{\n    :{\n        :A\n        B\n    }\n    :{\n        :B\n        A\n    }\n    (iff A B)\n}\n"
  },
  {
    "filename": "/propositional logic/conditional elimination.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "conditional elimination",
        "->E"
      ]
    },
    "content": "\n{\n    :(implies A B)\n    :A\n    B\n}\n"
  },
  {
    "filename": "/propositional logic/conditional introduction.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "conditional introduction",
        "->I"
      ]
    },
    "content": "\n{\n    :{\n        :A\n        B\n    }\n    (implies A B)\n}\n"
  },
  {
    "filename": "/propositional logic/conjunction elimination.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "conjunction elimination",
        "^E"
      ]
    },
    "content": "\n{\n    :(and A B)\n    A\n    B\n}\n"
  },
  {
    "filename": "/propositional logic/conjunction introduction.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "conjunction introduction",
        "^I"
      ]
    },
    "content": "\n{\n    :A\n    :B\n    (and A B)\n}\n"
  },
  {
    "filename": "/propositional logic/declare connectives.putdown",
    "metadata": {},
    "content": "\n// Declare the logical connectives as constants:\n\n[and or not implies iff const]\n"
  },
  {
    "filename": "/propositional logic/disjunction elimination.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "disjunction elimination",
        "vE"
      ]
    },
    "content": "\n{\n    :(or A B)\n    :(implies A C)\n    :(implies B C)\n    C\n}\n"
  },
  {
    "filename": "/propositional logic/disjunction introduction.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "disjunction introduction",
        "vI"
      ]
    },
    "content": "\n{\n    :A\n    (or A B)\n}\n\n{\n    :B\n    (or A B)\n}\n"
  },
  {
    "filename": "/propositional logic/negation elimination.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "negation elimination",
        "-E"
      ]
    },
    "content": "\n{\n    :{\n        :(not A)\n        B\n        (not B)\n    }\n    A\n}\n"
  },
  {
    "filename": "/propositional logic/negation introduction.putdown",
    "metadata": {
      "rule": true,
      "names": [
        "negation introduction",
        "-I"
      ]
    },
    "content": "\n{\n    :{\n        :A\n        B\n        (not B)\n    }\n    (not A)\n}\n"
  },
  {
    "filename": "/validation tests/formula test 01.putdown",
    "metadata": {
      "testing": {
        "type": "validation",
        "subtype": "formula",
        "description": "A basic valid single formula test."
      }
    },
    "content": "\n(⇒ ¬ or),{                         // declare non-metavars\n  \n  \"alt def of ⇒\">                  // using X> as a label\n  :{ :(⇒ P Q) (or (¬ P) Q) }       // a theorem turned formula\n  \n  // start a proof\n  {  \n1>   :(⇒ A B)                          // assume something\n     (or (¬ A) B)                      // prove this\n                   by \"alt def of ⇒\"   // using 'by \"label\"' as reason for\n                                       // the previous sibling\n                   using 1             // citing a premise to optionally\n                                       // restrict the sequent by 'using label1 ...  labeln'      \n                   with P=A Q=B        // using 'with A1=B1 ... An=Bn' to specify\n                                       // instantiations of metavars   \n                                       // assuming you can chain attributes\n                   ⟨\"valid\"⟩           // expected validation result\n  }\n}\n\n//\n// incorrect variants\n//\n\n// no such reason\n(⇒ ¬ or),{                         \n  \"alt def of ⇒\">                  \n  :{ :(⇒ P Q) (or (¬ P) Q) }       \n  \n  {  \n1>   :(⇒ A B)                         \n     (or (¬ A) B) by \"Stewart's Thm\"    // wrong reason\n                   using 1\n                   with P=A Q=B                                       \n                   ⟨\"no such reason\"⟩ \n  }\n}\n\n// no such premise\n(⇒ ¬ or),{                         \n  \"alt def of ⇒\">                  \n  :{ :(⇒ P Q) (or (¬ P) Q) }       \n  {  \n1>   :(⇒ A B)                         \n     (or (¬ A) B) by \"alt def of ⇒\"    \n                   using 2              // missing premise\n                   with P=A Q=B                                       \n                   ⟨\"no such premise\"⟩ \n  }\n}\n\n// formula not accessible (and meaningless)\n(⇒ ¬ or),{                         \n  {                             // accidentally make it inaccessible/meaningless\n    \"alt def of ⇒\">                  \n    :{ :(⇒ P Q) (or (¬ P) Q) }\n  }          \n  {  \n1>   :(⇒ A B)                         \n     (or (¬ A) B) by \"alt def of ⇒\"    \n                   using 1              \n                   with P=A Q=B                                       \n                   ⟨\"formula not accessible\"⟩   \n  }\n}\n\n// premise not accessible (and meaningless)\n(⇒ ¬ or),{                         \n    \"alt def of ⇒\">                  \n    :{ :(⇒ P Q) (or (¬ P) Q) }\n  {  \n    {              // accidentally make it inaccessible/meaningless\n1>   :(⇒ A B)\n    }\n     (or (¬ A) B) by \"alt def of ⇒\"    \n                   using 1              \n                   with P=A Q=B                                       \n                   ⟨\"formula not accessible\"⟩   \n  }\n}\n\n\n// bound, so not a metavariable\n(⇒ ¬ or),{                         \n                              \n    \"alt def of ⇒\">                  \n    :{ :(⇒ P Q) (or (¬ P) Q) }                                 \n \n  {  \n1>   :(⇒ A B)                         \n     (or (¬ A) B) by \"alt def of ⇒\"    \n                  using 1              \n                  with P=A Q=B ⇒=A                                      \n                  ⟨\"not a metavariable\"⟩   \n  }\n}\n\n// extraneous metavariable\n(⇒ ¬ or),{                                                       \n    \"alt def of ⇒\">                  \n    :{ :(⇒ P Q) (or (¬ P) Q) }                                 \n \n  {  \n1>   :(⇒ A B)                         \n     (or (¬ A) B) by \"alt def of ⇒\"    \n                  using 1            \n                  with P=A Q=B R=A                                      \n                  ⟨\"extraneous metavariable\"⟩   \n  }\n}\n\n// syntactically valid, but not logically\n(⇒ ¬ or),{                         \n                              \n    \"alt def of ⇒\">                  \n    :{ :(⇒ P Q) (or (¬ P) Q) }                                 \n \n  {  \n1>   :(⇒ A B)                         \n     (or (¬ A) B) by \"alt def of ⇒\"    \n                  using 1            \n                  with P=A Q=A           // Q should be B\n                  ⟨\"invalid\"⟩   \n  }\n}\n\n// syntactically valid, but not logically\n(⇒ ¬ or),{                         \n                              \n    \"alt def of ⇒\">                  \n    :{ :(⇒ P Q) (or (¬ P) Q) }                                 \n \n  {  \n1>   :(⇒ A B)\n2>   :(⇒ B A)                                                  \n     (or (¬ A) B) by \"alt def of ⇒\"    \n                  using 2                // wrong premise            \n                  with P=A Q=A \n                  ⟨\"invalid\"⟩   \n  }\n}\n\n// syntactically valid, but not logically\n(⇒ ¬ or),{                         \n                              \n    \"alt def of ⇒\">                  \n    :{ :(⇒ P Q) (or (¬ P) Q) }                                 \n    \"reflexive of ⇒\">                  \n    :{ (⇒ P P) }\n \n  {  \n1>   :(⇒ A B)\n2>   :(⇒ B A)                                                  \n     (or (¬ A) B) by \"reflexive of ⇒\"   // wrong reason\n                  using 1\n                  with P=A Q=B \n                  ⟨\"invalid\",\"extraneous metavariable\"⟩   \n  }\n}\n"
  },
  {
    "filename": "/validation tests/prop test 01.putdown",
    "metadata": {
      "testing": {
        "type": "validation",
        "subtype": "propositional"
      },
      "imported": {
        "source": "fic-experiment repository",
        "file": "scripts/init.js",
        "name": "BadLC"
      }
    },
    "content": "\n{\n  :{\n    :W\n    :V\n    U\n    V\n  }\n  :W\n  :V\n  U +{\"expected validation result\":\"valid\"}\n}\n"
  },
  {
    "filename": "/validation tests/prop test 02.putdown",
    "metadata": {
      "testing": {
        "type": "validation",
        "subtype": "propositional"
      },
      "imported": {
        "source": "fic-experiment repository",
        "file": "scripts/init.js",
        "name": "imp2"
      }
    },
    "content": "\n{\n    :{\n        A\n        :B\n    }\n    A +{\"expected validation result\":\"valid\"}\n    :C\n    C +{\"expected validation result\":\"valid\"}\n}\n"
  },
  {
    "filename": "/validation tests/prop test 03.putdown",
    "metadata": {
      "testing": {
        "type": "validation",
        "subtype": "propositional"
      },
      "imported": {
        "source": "fic-experiment repository",
        "file": "test/data/PropProofsTxt.js"
      }
    },
    "content": "\n{\n    :{\n        :{\n            W\n            V\n        }\n        (and W V)\n        (and V W)\n    }\n    :{\n        :(and W V)\n        W\n        V\n    }\n    :{\n        :W\n        (or W V)\n        (or V W)\n    }\n    :{\n        :(or W V)\n        :{\n            :W\n            R\n        }\n        :{\n            :W\n            R\n        }\n        R\n    }\n    :{\n        :{\n            :W\n            V\n        }\n        (implies W V)\n    }\n    :{\n        :W\n        :(implies W V)\n        V\n    }\n    :{\n        :{\n            :W\n            V\n        }\n        :{\n            :V\n            W\n        }\n        (iff W V)\n    }\n    :{\n        :(iff W V)\n        {\n            :V\n            W\n        }\n        {\n            :W\n            V\n        }\n    }\n    :{\n        :{\n            :W\n            contradiction\n        }\n        (not W)\n    }\n    :{\n        :{\n            :(not W)\n            contradiction\n        }\n        W\n    }\n    :{\n        :W\n        :(not W)\n        contradiction\n    }\n    :{\n        :(not P)\n        (or P (not P))\n    }\n    :{\n        :P\n        (or P (not P))\n    }\n    :{\n        :P\n        (or P Q)\n    }\n    :{\n        :Q\n        (or P Q)\n    }\n    :{\n        :(or P Q)\n        (or (or P Q) R)\n    }\n    :{\n        :R\n        (or (or P Q) R)\n    }\n    :{\n        :P\n        (or P (and (not P) P))\n    }\n    :{\n        :(not P)\n        (or (not P) (not Q))\n    }\n    :{\n        :(not Q)\n        (or (not P) (not Q))\n    }\n    :{\n        :(or Q R)\n        :{\n            :Q\n            (or (or P Q) R)\n        }\n        :{\n            :R\n            (or (or P Q) R)\n        }\n        (or (or P Q) R)\n    }\n    :{\n        :(or P (or Q R))\n        :{\n            :P\n            (or (or P Q) R)\n        }\n        :{\n            :(or Q R)\n            (or (or P Q) R)\n        }\n        (or (or P Q) R)\n    }\n    :{\n        :(or (not P) (not Q))\n        :{\n            :(not P)\n            contradiction\n        }\n        :{\n            :(not Q)\n            contradiction\n        }\n        contradiction\n    }\n    :{\n        :(or P (not P))\n        :(not (or P (not P)))\n        contradiction\n    }\n    :{\n        :(not (or (not P) (not Q)))\n        :(or (not P) (not Q))\n        contradiction\n    }\n    :{\n        :(not (and P Q))\n        :(and P Q)\n        contradiction\n    }\n    :{\n        :(not P)\n        :P\n        contradiction\n    }\n    :{\n        :(not Q)\n        :Q\n        contradiction\n    }\n    :{\n        :{\n            :(not P)\n            contradiction\n        }\n        P\n    }\n    :{\n        :{\n            :(not Q)\n            contradiction\n        }\n        Q\n    }\n    :{\n        :{\n            :(not (or P (not P)))\n            contradiction\n        }\n        (or P (not P))\n    }\n    :{\n        :{\n            :(not (or (not P) (not Q)))\n            contradiction\n        }\n        (or (not P) (not Q))\n    }\n    :{\n        :{\n            :(and P Q)\n            contradiction\n        }\n        (not (and P Q))\n    }\n    :{\n        :{\n            :contradiction\n            P\n        }\n        (implies contradiction P)\n    }\n    :{\n        :{\n            :(or P (or Q R))\n            (or (or P Q) R)\n        }\n        (implies (or P (or Q R)) (or (or P Q) R))\n    }\n    :{\n        :{\n            :P\n            (or P (and (not P) P))\n        }\n        (implies P (or P (and (not P) P)))\n    }\n    :{\n        :{\n            :(or P (and (not P) P))\n            P\n        }\n        (implies (or P (and (not P) P)) P)\n    }\n    :{\n        :{\n            :P\n            (iff P (or P (and (not P) P)))\n        }\n        (implies P (iff P (or P (and (not P) P))))\n    }\n    :{\n        :{\n            :(not (and P Q))\n            (or (not P) (not Q))\n        }\n        (implies (not (and P Q)) (or (not P) (not Q)))\n    }\n    :{\n        :{\n            :(or (not P) (not Q))\n            (not (and P Q))\n        }\n        (implies (or (not P) (not Q)) (not (and P Q)))\n    }\n    :{\n        :(implies P (or P (and (not P) P)))\n        :(implies (or P (and (not P) P)) P)\n        (iff P (or P (and (not P) P)))\n    }\n    :{\n        :(implies (not (and P Q)) (or (not P) (not Q)))\n        :(implies (or (not P) (not Q)) (not (and P Q)))\n        (iff (not (and P Q)) (or (not P) (not Q)))\n    }\n    :{\n        :P\n        :Q\n        (and P Q)\n    }\n    :{\n        :P\n        :Q\n        (and P Q)\n    }\n    :{\n        :(and P Q)\n        P\n        Q\n    }\n    {\n        :(not (or P (not P)))\n        {\n            :(not P)\n            (or P (not P)) +{\"expected validation result\":\"valid\"}\n            contradiction +{\"expected validation result\":\"valid\"}\n        }\n        P +{\"expected validation result\":\"valid\"}\n        (or P (not P)) +{\"expected validation result\":\"valid\"}\n        contradiction +{\"expected validation result\":\"valid\"}\n    }\n    (or P (not P)) +{\"expected validation result\":\"valid\"}\n    {\n        :contradiction\n        {\n            :(not P)\n            contradiction +{\"expected validation result\":\"valid\"}\n        }\n        P +{\"expected validation result\":\"valid\"}\n    }\n    (implies contradiction P) +{\"expected validation result\":\"valid\"}\n    {\n        :(or P (or Q R))\n        {\n            :P\n            (or P Q) +{\"expected validation result\":\"valid\"}\n            (or (or P Q) R) +{\"expected validation result\":\"valid\"}\n        }\n        {\n            :(or Q R)\n            {\n                :Q\n                (or P Q) +{\"expected validation result\":\"valid\"}\n                (or (or P Q) R) +{\"expected validation result\":\"valid\"}\n            }\n            {\n                :R\n                (or (or P Q) R) +{\"expected validation result\":\"valid\"}\n            }\n            (or (or P Q) R) +{\"expected validation result\":\"valid\"}\n        }\n        (or (or P Q) R) +{\"expected validation result\":\"valid\"}\n    }\n    (implies (or P (or Q R)) (or (or P Q) R)) +{\"expected validation result\":\"valid\"}\n    {\n        :P\n        {\n            :P\n            (or P (and (not P) P)) +{\"expected validation result\":\"valid\"}\n        }\n        (implies P (or P (and (not P) P))) +{\"expected validation result\":\"valid\"}\n        {\n            :(or P (and (not P) P))\n            P +{\"expected validation result\":\"valid\"}\n        }\n        (implies (or P (and (not P) P)) P) +{\"expected validation result\":\"valid\"}\n        (iff P (or P (and (not P) P))) +{\"expected validation result\":\"valid\"}\n    }\n    (implies P (iff P (or P (and (not P) P)))) +{\"expected validation result\":\"valid\"}\n    {\n        :(not (and P Q))\n        {\n            :(not (or (not P) (not Q)))\n            {\n                :(not P)\n                (or (not P) (not Q)) +{\"expected validation result\":\"valid\"}\n                contradiction +{\"expected validation result\":\"valid\"}\n            }\n            P +{\"expected validation result\":\"valid\"}\n            {\n                :(not Q)\n                (or (not P) (not Q)) +{\"expected validation result\":\"valid\"}\n                contradiction +{\"expected validation result\":\"valid\"}\n            }\n            Q +{\"expected validation result\":\"valid\"}\n            (and P Q) +{\"expected validation result\":\"valid\"}\n            contradiction +{\"expected validation result\":\"valid\"}\n        }\n        (or (not P) (not Q)) +{\"expected validation result\":\"valid\"}\n    }\n    (implies (not (and P Q)) (or (not P) (not Q))) +{\"expected validation result\":\"valid\"}\n    {\n        :(or (not P) (not Q))\n        {\n            :(and P Q)\n            P +{\"expected validation result\":\"valid\"}\n            Q +{\"expected validation result\":\"valid\"}\n            {\n                :(not P)\n                contradiction +{\"expected validation result\":\"valid\"}\n            }\n            {\n                :(not Q)\n                contradiction +{\"expected validation result\":\"valid\"}\n            }\n            contradiction +{\"expected validation result\":\"valid\"}\n        }\n        (not (and P Q)) +{\"expected validation result\":\"valid\"}\n    }\n    (implies (or (not P) (not Q)) (not (and P Q))) +{\"expected validation result\":\"valid\"}\n    (iff (not (and P Q)) (or (not P) (not Q))) +{\"expected validation result\":\"valid\"}\n}\n"
  },
  {
    "filename": "/validation tests/prop test 04.putdown",
    "metadata": {
      "testing": {
        "type": "validation",
        "subtype": "propositional"
      }
    },
    "content": "\n{\n  :{\n    :G\n    {\n      :A\n      B\n    }\n  }\n  {\n    :G\n    :A\n    B +{\"expected validation result\":\"valid\"}\n  }\n}\n"
  },
  {
    "filename": "/validation tests/prop test 05.putdown",
    "metadata": {
      "testing": {
        "type": "validation",
        "subtype": "propositional"
      }
    },
    "content": "\n{\n  :{\n    :{\n      :A\n      B\n    }\n    {\n      :A\n      C\n    }\n  }\n  {\n    :{\n      :B\n      C\n    }\n    C +{\"expected validation result\":\"invalid\"}\n  }\n}\n"
  },
  {
    "filename": "/validation tests/prop test 06.putdown",
    "metadata": {
      "testing": {
        "type": "validation",
        "subtype": "propositional"
      }
    },
    "content": "\n{\n  :{ :A B }\n  :{ :C D }\n  :{ :E F }\n  :{ :G H }\n  :{ :I J }\n  :{ :K L }\n  :{ M N }\n  :{ :O P }\n  :{ :Q R }\n  :{ :R A }\n  :{ :P C }\n  :{ :N E }\n  :{ :L G }\n  :{ :I E }\n  :{ :K F }\n  :{ :M G }\n  :{ :O H }\n  :{ :Q I }\n  A +{\"expected validation result\":\"invalid\"}\n}\n"
  }
]


// This file is a footer that will be embedded within /src/database.js when
// that file is regenerated using the "npm run build-db" command, as
// documented in /src/database/generate.js.

/**
 * The testing database is built from a hierarchy of folders in the source
 * code repository, containing `.putdown` and `.smackdown` files.  The
 * functions in this namespace are for querying that database.  They are used
 * in some of our testing suite, so that a library of large expressions, even
 * large proofs, can be created outside of code, and just loaded from disk.
 * 
 * The documentation of each function below assumes you have imported the
 * database using the code `import Database from '/path/to/database.js'`.
 * For example, importing it from a script in the `/tests` folder would use
 * `import Database from '../src/database.js'`.  Thus when the identifier
 * `Database` appears in the documentation below, it is referring to the
 * database module itself, as documented in this namespace.
 * 
 * The source code file `database.js` is not intended to be imported into
 * application code with the LDE itself, because it contains a large block of
 * JSON in the code itself that is the entire contents of the database; that
 * would significantly bloat the size of any app that used the LDE.  However,
 * that file is available for use in all of our testing scripts, and it is very
 * useful in that regard.
 * 
 * @namespace Database
 */

// The features added by this file are various querying conveniences for the
// database, which include conversion of putdown notation to LogicConcept
// instances and smackdown notation to MathConcept instances.  For that, we
// need the relevant classes.
import { LogicConcept } from './logic-concept.js'
import { MathConcept } from './math-concept.js'

/**
 * Each entry in the database has a unique name by which it is identified, and
 * we call those names "keys."  You can get a list of all keys using this
 * function.
 * 
 * The keys are simply the paths in the filesystem from which the data was
 * loaded.  So you might get a response of the form
 * `['/folder1/file1.putdown','/folder2/subfolder/file2.smackdown']` and so on,
 * containing as many files as there are in the database.  If you think of the
 * database as a filesystem, this function is like a recursive directory
 * listing, filtering for only the `.putdown` and `.smackdown` files.
 * 
 * @returns {string[]} all keys in the database
 * @see {@link Database.keysStartingWith keysStartingWith()}
 * @see {@link Database.keysPaths keysPaths()}
 * @memberof Database
 * @alias Database.keys
 */
export const keys = () =>
    testingDatabase.map( entry => entry.filename )

/**
 * This is a convenience function that returns just those keys in the database
 * that begin with a certain prefix.  You can use this to get all files
 * recursively beneath a certain folder, for example, with a call like
 * `Database.keysStartingWith('/my/folder/name/')`.
 * 
 * @param {string} prefix - the prefix by which to filter
 * @returns {string[]} all keys in the database that begin with the given
 *   prefix
 * @see {@link Database.keys keys()}
 * @see {@link Database.keysPaths keysPaths()}
 * @memberof Database
 * @alias Database.keysStartingWith
 */
export const keysStartingWith = prefix =>
    keys().filter( key => key.startsWith( prefix ) )

/**
 * Since the keys in the database are file paths, we might want to ask for the
 * list of files inside a certain folder.  We can do so recursively with
 * {@link Database.keysStartingWith keysStartingWith()}, but this function
 * lets us do so non-recursively.
 * 
 * For example, if we call `Database.keysPaths('/example')`, we might get a
 * response like `['one','two','x.putdown']` if indeed there were three things
 * in the `/example` folder, including subfolders `one` and `two` and a file
 * `x.putdown`.  If the database is viewed as a filesystem, this function is
 * like a directory listing.
 * 
 * @param {string} folder - the folder whose contents should be listed
 * @returns {string[]} all subfolder names or filenames that sit within the
 *   given folder (or the empty list if there are none, or if the folder name
 *   was invalid)
 * @see {@link Database.keys keys()}
 * @see {@link Database.keysStartingWith keysStartingWith()}
 * @memberof Database
 * @alias Database.keysPaths
 */
export const keysPaths = ( folder = '' ) => {
    if ( !folder.endsWith( '/' ) ) folder += '/'
    return Array.from( new Set( keysStartingWith( folder ).map(
        key => key.substring( folder.length ).split( '/' )[0] ) ) )
}

/**
 * Get the list of all keys in the database that refer to entries whose
 * metadata satisfies a given predicate.  For details on metadata content,
 * see {@link Database.getMetadata getMetadata()}.
 * 
 * @param {function} predicate - a function that takes as input a JSON object
 *   containing the metadata for a database entry and returns a boolean
 * @returns {string[]} an array of all keys in the database whose
 *   corresponding entries pass the test inherent in the given predicate,
 *   that is, the predicate returns true when run on their metadata
 * @see {@link Database.getMetadata getMetadata()}
 * @memberof Database
 * @alias Database.filterByMetadata
 */
export const filterByMetadata = predicate =>
    testingDatabase.filter( entry => predicate( entry.metadata ) )
    .map( entry => entry.filename )

// Read attributes from database entries; internal module helper function.
const getEntryAttribute = ( entryName, attribute ) => {
    const entry = testingDatabase.find( entry => entry.filename == entryName )
    return entry ? entry[attribute] : undefined
}

// Set attributes on database entries; internal module helper function.
const setEntryAttribute = ( entryName, attribute, value ) => {
    const entry = testingDatabase.find( entry => entry.filename == entryName )
    if ( entry ) entry[attribute] = value
    return value
}

/**
 * Look up the metadata associated with a database entry.  The result will be
 * a JavaScript `Object` instance, as if produced by `JSON.parse()`, possibly
 * the empty object `{}` if the entry had no metadata, or `undefined` if the
 * given key is invalid.
 * 
 * The metadata of any entry in the database is a JSON object extracted from
 * the (optional) YAML header in the original `.putdown` or `.smackdown` file.
 * It can contain any information the original author put there.  For example,
 * it might state that the contents of the file are (or are not) valid
 * `.putdown` (or `.smackdown`) syntax, so that the file can be used for
 * testing the putdown (or smackdown) parser.  Or it might be used to include
 * other `.putdown` or `.smackdown` files as headers.  The list of uses for
 * this metadata is intended to grow over time, and thus not be fully specified
 * in advance.
 * 
 * The object returned is the actual metadata stored in the database, not a
 * copy, so altering it will alter the contents of the database in memory (but
 * not on the filesystem).
 * 
 * @param {string} key - the key for the entry to look up
 * @returns {Object} a JSON object containing the metadata for the entry
 * @see {@link Database.filterByMetadata filterByMetadata()}
 * @see {@link Database.getCode getCode()}
 * @memberof Database
 * @alias Database.getMetadata
 */
export const getMetadata = key => getEntryAttribute( key, 'metadata' )

/**
 * Look up the original code associated with a database entry, which will be in
 * either putdown or smackdown notation.  The result will a string containing
 * whatever was in the original `.putdown` or `.smackdown` file on disk when
 * the database was created, or `undefined` if the key is invalid.
 * 
 * If the entry's metadata has an `"includes"` member, the database build
 * process respects this and includes other `.putdown` or `.smackdown` files as
 * headers within this one.  The result of this function will include the full
 * `.putdown` or `.smackdown` code for this entry, which includes any code that
 * was imported using the `"includes"` member of the metadata.  To get just the
 * original code without the other included files, see
 * {@link Database.getCodeWithoutIncludes getCodeWithoutIncludes()}.
 * 
 * The return value includes only putdown or smackdown code, not the YAML
 * header that was converted into metadata.  To get access to that information,
 * see * {@link Database.getMetadata getMetadata()}.
 * 
 * The return value is just the code, not the actual objects signified by that
 * code.  To get access to those objects, see
 * {@link Database.getObjects getObjects()}.
 * 
 * @param {string} key - the key for the entry to look up
 * @returns {string} the putdown or smackdown source code for the entry
 * @see {@link Database.getCodeWithoutIncludes getCodeWithoutIncludes()}
 * @see {@link Database.getMetadata getMetadata()}
 * @see {@link Database.getObjects getObjects()}
 * @memberof Database
 * @alias Database.getCode
 */
export const getCode = key => getEntryAttribute( key, 'content' )

/**
 * This function works exactly the same as
 * {@link Database.getCode getCode()}, except that any code included
 * from a separate file using the `"includes"` member of the metadata object
 * will not be included here.  Thus the return value from this function is
 * always a terminal substring of the return value of
 * {@link Database.getCode getCode()}.
 * 
 * @param {string} key - the key for the entry to look up
 * @returns {string} the putdown or smackdown source code for the entry
 * @see {@link Database.getCode getCode()}
 * @see {@link Database.getMetadata getMetadata()}
 * @memberof Database
 * @alias Database.getCodeWithoutIncludes
 */
export const getCodeWithoutIncludes = key => {
    const original = getEntryAttribute( key, 'original' )
    return typeof( original ) == 'undefined' ?
        getEntryAttribute( key, 'content' ) : original
}

// Get a cached parsed result of the given entry's full putdown/smackdown
// source, if any exists yet in the database.
const getParsedResult = key => getEntryAttribute( key, 'parsed' )

// Store in the cache the parsed result of the given entry's putdown/smackdown
// source, overwriting any previous cache value if there was one.
const setParsedResult = ( key, result ) =>
    setEntryAttribute( key, 'parsed', result )

/**
 * This function works exactly the same as
 * {@link Database.getCode getCode()}, with two exceptions.
 * 
 *  1. In addition to fetching the putdown or smackdown code, it also
 *     interprets it if possible, yielding an array of {@link MathConcept
 *     MathConcepts} or {@link LogicConcept LogicConcepts} as the result.
 *     (Putdown notation produces {@link LogicConcept LogicConcepts} and
 *     smackdown notation produces {@link MathConcept MathConcepts}, although
 *     since every {@link LogicConcept LogicConcept} is a {@link MathConcept
 *     MathConcept}, smackdown notation may produce either type, but putdown
 *     notation always produces {@link LogicConcept LogicConcepts}.)
 *  2. Such results are cached so that future calls to this function with the
 *     same arguments will return the exact same {@link MathConcept
 *     MathConcept} or {@link LogicConcept LogicConcepts} instances.  In
 *     particular, this means that if you manipulate the copies you get, you
 *     are mainpulating the copies in the cache.  If this is not what you want,
 *     make separate copies.
 * 
 * If the putdown or smackdown code fetched for the entry is not valid, then
 * this function will instead throw a parsing error.  If the key is an invalid
 * key for the database, this function will return undefined.  If the file
 * contains the putdown or smackdown code for zero actual objects (e.g., only
 * whitespace and comments) then this function will return an empty array.
 * 
 * If you know that there is only one object in the file, and you want to get
 * it without bothering to do `getObjects(key)[0]`, you can just call
 * {@link Database.getObject getObject()} instead.
 * 
 * @param {string} key - the key for the entry to look up
 * @returns {LogicConcept[]} the meaning of the putdown or smackdown source
 *   code for the entry, as an array of {@link MathConcept MathConcept} or
 *   {@link LogicConcept LogicConcept} instances
 * @see {@link Database.getCode getCode()}
 * @see {@link Database.getObject getObject()}
 * @memberof Database
 * @alias Database.getObjects
 */
 export const getObjects = key => {
    const cached = getParsedResult( key )
    // if we cached a list of LCs, return them
    if ( cached instanceof Array ) return cached
    // if we cached something else, it was an error object; re-throw it
    if ( cached ) throw cached
    // we have no cache, so we must parse; get the putdown/smackdown code
    const code = getCode( key )
    // if we have no code, we cannot proceed
    if ( !code ) return undefined
    try {
        // if we parse without error, cache the result and then return it
        return setParsedResult( key,
            key.endsWith( '.putdown' ) ? LogicConcept.fromPutdown( code )
                                       : MathConcept.fromSmackdown( code ) )
    } catch ( error ) {
        // otherwise, cache the error and also throw it
        throw setParsedResult( key, error )
    }
}

/**
 * This function works exactly the same as
 * {@link Database.getObjects getObjects()}, with one exception:
 * If the putdown or smackdown source code parses into an array of length one,
 * this function just returns the sole entry of that array, but if instead the
 * array has any other length, this function throws an error, whose message
 * states that it expected an array of length one.
 * 
 * @param {string} key - the key for the entry to look up
 * @returns {LogicConcept} the meaning of the putdown or smackdown source code
 *   for the entry, as a single {@link MathConcept MathConcept} or
 *   {@link LogicConcept LogicConcept} instance
 * @see {@link Database.getCode getCode()}
 * @see {@link Database.getObjects getObjects()}
 * @memberof Database
 * @alias Database.getObject
 */
 export const getObject = key => {
    const all = getObjects( key )
    if ( all.length != 1 )
        throw `Expected 1 LogicConcept, got ${all.length}`
    return all[0]
}

// create a default object so that clients can do:
// import Database from './database.js'
export default {
    keys, keysStartingWith, keysPaths, filterByMetadata,
    getMetadata, getCode, getCodeWithoutIncludes, getObjects, getObject
}

