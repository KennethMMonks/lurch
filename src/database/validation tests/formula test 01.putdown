---
testing:
  type: validation
  subtype: formula
  description: "A basic valid single formula test."
---

(⇒ ¬ or),{                         // declare non-metavars
  
  "alt def of ⇒">                  // using X> as a label
  :{ :(⇒ P Q) (or (¬ P) Q) }       // a theorem turned formula
  
  // start a proof
  {  
1>   :(⇒ A B)                          // assume something
     (or (¬ A) B)                      // prove this
                   by "alt def of ⇒"   // using 'by "label"' as reason for
                                       // the previous sibling
                   using 1             // citing a premise to optionally
                                       // restrict the sequent by 'using label1 ...  labeln'      
                   with P=A Q=B        // using 'with A1=B1 ... An=Bn' to specify
                                       // instantiations of metavars   
                                       // assuming you can chain attributes
                   ⟨"valid"⟩           // expected validation result
  }
}

//
// incorrect variants
//

// no such reason
(⇒ ¬ or),{                         
  "alt def of ⇒">                  
  :{ :(⇒ P Q) (or (¬ P) Q) }       
  
  {  
1>   :(⇒ A B)                         
     (or (¬ A) B) by "Stewart's Thm"    // wrong reason
                   using 1
                   with P=A Q=B                                       
                   ⟨"no such reason"⟩ 
  }
}

// no such premise
(⇒ ¬ or),{                         
  "alt def of ⇒">                  
  :{ :(⇒ P Q) (or (¬ P) Q) }       
  {  
1>   :(⇒ A B)                         
     (or (¬ A) B) by "alt def of ⇒"    
                   using 2              // missing premise
                   with P=A Q=B                                       
                   ⟨"no such premise"⟩ 
  }
}

// formula not accessible (and meaningless)
(⇒ ¬ or),{                         
  {                             // accidentally make it inaccessible/meaningless
    "alt def of ⇒">                  
    :{ :(⇒ P Q) (or (¬ P) Q) }
  }          
  {  
1>   :(⇒ A B)                         
     (or (¬ A) B) by "alt def of ⇒"    
                   using 1              
                   with P=A Q=B                                       
                   ⟨"formula not accessible"⟩   
  }
}

// premise not accessible (and meaningless)
(⇒ ¬ or),{                         
    "alt def of ⇒">                  
    :{ :(⇒ P Q) (or (¬ P) Q) }
  {  
    {              // accidentally make it inaccessible/meaningless
1>   :(⇒ A B)
    }
     (or (¬ A) B) by "alt def of ⇒"    
                   using 1              
                   with P=A Q=B                                       
                   ⟨"formula not accessible"⟩   
  }
}


// bound, so not a metavariable
(⇒ ¬ or),{                         
                              
    "alt def of ⇒">                  
    :{ :(⇒ P Q) (or (¬ P) Q) }                                 
 
  {  
1>   :(⇒ A B)                         
     (or (¬ A) B) by "alt def of ⇒"    
                  using 1              
                  with P=A Q=B ⇒=A                                      
                  ⟨"not a metavariable"⟩   
  }
}

// extraneous metavariable
(⇒ ¬ or),{                                                       
    "alt def of ⇒">                  
    :{ :(⇒ P Q) (or (¬ P) Q) }                                 
 
  {  
1>   :(⇒ A B)                         
     (or (¬ A) B) by "alt def of ⇒"    
                  using 1            
                  with P=A Q=B R=A                                      
                  ⟨"extraneous metavariable"⟩   
  }
}

// syntactically valid, but not logically
(⇒ ¬ or),{                         
                              
    "alt def of ⇒">                  
    :{ :(⇒ P Q) (or (¬ P) Q) }                                 
 
  {  
1>   :(⇒ A B)                         
     (or (¬ A) B) by "alt def of ⇒"    
                  using 1            
                  with P=A Q=A           // Q should be B
                  ⟨"invalid"⟩   
  }
}

// syntactically valid, but not logically
(⇒ ¬ or),{                         
                              
    "alt def of ⇒">                  
    :{ :(⇒ P Q) (or (¬ P) Q) }                                 
 
  {  
1>   :(⇒ A B)
2>   :(⇒ B A)                                                  
     (or (¬ A) B) by "alt def of ⇒"    
                  using 2                // wrong premise            
                  with P=A Q=A 
                  ⟨"invalid"⟩   
  }
}

// syntactically valid, but not logically
(⇒ ¬ or),{                         
                              
    "alt def of ⇒">                  
    :{ :(⇒ P Q) (or (¬ P) Q) }                                 
    "reflexive of ⇒">                  
    :{ (⇒ P P) }
 
  {  
1>   :(⇒ A B)
2>   :(⇒ B A)                                                  
     (or (¬ A) B) by "reflexive of ⇒"   // wrong reason
                  using 1
                  with P=A Q=B 
                  ⟨"invalid","extraneous metavariable"⟩   
  }
}
