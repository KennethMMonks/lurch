{"version":3,"sources":["structure.litcoffee"],"names":["Structure","bind","fn","me","apply","arguments","exports","c","child","children","i","len","ref","length","slice","call","this","computedAttributes","externalAttributes","parentNode","childList","results","removeFromParent","wasInserted","IDs","instanceWithID","id","prototype","nextUnusedID","result","indexOf","getID","ID","releaseID","pop","parent","indexInParent","ref1","originalIndex","originalParent","splice","wasRemoved","removeChild","atIndex","insertChild","beforeIndex","concat","replaceWith","other","getComputedAttribute","key","setComputedAttribute","value","wasChanged","clearComputedAttributes","keys","Object","compute","arg","args","func","params","Array","getExternalAttribute","setExternalAttribute","clearExternalAttributes"],"mappings":"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","file":"structure.js","sourcesContent":["\n# LDE Structures\n\nThe very generic word \"structure\" is used in the LDE to describe a subtree\nof the LDE Document.  For more details on this, see\n[the design overview docs](https://lurchmath.github.io/lde/site/overview/).\n\n    exports.Structure = class Structure\n\n## Unique IDs for instances\n\nWe want to be able to give instance of this class unique IDs.  To do so, we\nwill track those IDs in a class variable defined here, and provide class\nmethods for assigning and revoking IDs to instances.  IDs will be\nnonnegative integers, and we will track them using an array.\n\n        IDs : [ ]\n        @instanceWithID : ( id ) -> Structure::IDs[id]\n        @nextUnusedID : ->\n            result = Structure::IDs.indexOf null\n            if result >= 0 then result else Structure::IDs.length\n\nThe following two functions, which can be called in an instance to request a\nnew, unique ID, or to relinquish one back into the pool, are optional for\nany given instance.  That is, it is not required that each instance have an\nID.  But this system ensures that if IDs are assigned in this way, then they\nwill be globally unique for all instances.\n\nEnsure that any instance that calls `getID` at some point later calls\n`releaseID`, or the `IDs` array will become enormous, a memory leak.\n\n        getID : =>\n            return if @ID?\n            @ID = Structure.nextUnusedID()\n            Structure::IDs[@ID] = this\n        releaseID : =>\n            if @ID?\n                Structure::IDs[@ID] = null\n                delete @ID\n                while Structure::IDs[Structure::IDs.length-1] is null\n                    Structure::IDs.pop()\n\n## Constructor\n\nThe constructor body just initializes internal fields, but it accepts an\narray of initial children as its argument.  Any non-Structure passed as an\nargument is ignored.  See the next section for more details of child\nstructures.\n\n        constructor : ( children... ) ->\n            @computedAttributes = { }\n            @externalAttributes = { }\n            @parentNode = null\n            @childList = ( c for c in children when c instanceof Structure )\n            for child in @childList\n                child.removeFromParent()\n                child.parentNode = this\n                child.wasInserted?()\n\n## Tree structure\n\nStructures form a hierarchy, an n-ary tree.  We thus need functions for\ninserting, removing, and querying parents and children.\n\nFirst, the getters.  When querying the children, we make a copy of the list\nso that clients can feel free to manipulate it without messing up the\nintegrity of the hierarchy.\n\n        parent : => @parentNode\n        children : => @childList[..]\n        indexInParent : => @parentNode?.childList?.indexOf this\n\nNext, the setters.  There is no setter for the parent, because the parent\npointer of a structure S must be kept consistent with the children list of\nthe parent of S, and so we update both in the setters for children.\n\nWe permit removing children from parents, either with a method in the child\nor in the parent.\n\n        removeFromParent : =>\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @parentNode.childList.splice originalIndex, 1\n                @parentNode = null\n                @wasRemoved? originalParent, originalIndex\n        removeChild : ( atIndex ) => @childList[atIndex]?.removeFromParent()\n\nWe permit inserting a new child into the parent's child array at any valid\nindex (including the old length of the child array, which appends).  The\nchild to be inserted is first removed from any parent it has when this\nmethod is called.  The default index is 0, so that a call of\n`insertChild(x)` inserts it as the first child.\n\n        insertChild : ( child, beforeIndex = 0 ) ->\n            return unless child instanceof Structure and \\\n                0 <= beforeIndex <= @childList.length\n            child.removeFromParent()\n            @childList = [\n                @childList[...beforeIndex]...\n                child\n                @childList[beforeIndex...]...\n            ]\n            child.parentNode = this\n            child.wasInserted?()\n\nA convenient combination of the above methods is to replace a child with a\nnew structure, deparenting the old child and putting the replacement at the\nsame index in the same parent.\n\n        replaceWith : ( other ) =>\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @removeFromParent()\n                originalParent.insertChild other, originalIndex\n\n## Computed attributes\n\nThe dictionary of computed attributes has getters and setters that work on\nkeys or key-value pairs (respectively).  The intent is for them to store the\nresults of computations done by the LDE.  There is also a corresponding\n\"clear\" function for deleting entries from the computed attributes\ndictionary.\n\nThe client is permitted to use any keys they like here, but the `feedback`\nkey is special; see [the documentation\nhere](https://lurchmath.github.io/lde/site/phase0-structures/#methods-in-the-structure-class)\nfor details.\n\n        getComputedAttribute : ( key ) => @computedAttributes[key]\n        setComputedAttribute : ( key, value ) =>\n            if @computedAttributes[key] isnt value\n                @computedAttributes[key] = value\n                @wasChanged?()\n        clearComputedAttributes : ( keys... ) =>\n            if keys.length is 0 then keys = Object.keys @computedAttributes\n            for key in keys\n                if key of @computedAttributes\n                    delete @computedAttributes[key]\n                    @wasChanged?()\n\nThe default implementation of the `compute` member takes any number of keys\nas string arguments, and runs them as member functions, storing the results\nas computed attributes.  Arrays can be used to pass additional arguments.\nSpecifically:\n\n * `S.compute('foo')` means `S.setComputedAttribute('foo',S.foo())`.\n * `S.compute(['foo',1,2,3])` means\n   `S.setComputedAttribute('foo',S.foo(1,2,3))`.\n * `S.compute(arg1,arg2,...)` means `S.compute(arg1)` and then\n   `S.compute(arg2)` and so on.\n\nMore details re in [the documentation\nhere](https://lurchmath.github.io/lde/site/phase0-structures/#methods-in-the-structure-class).\n\n        compute : ( args... ) =>\n            for arg in args\n                if arg not instanceof Array then arg = [ arg ]\n                [ func, params... ] = arg\n                @setComputedAttribute func, @[func] params...\n\n## External attributes\n\nThe dictionary of external attributes has get/set/clear functions just as we\nhave for computed attributes.  The intent is for them to store data provided\nby the client, and the LDE will not alter it.\n\n        getExternalAttribute : ( key ) => @externalAttributes[key]\n        setExternalAttribute : ( key, value ) =>\n            if @externalAttributes[key] isnt value\n                @externalAttributes[key] = value\n                @wasChanged?()\n        clearExternalAttributes : ( keys... ) =>\n            if keys.length is 0 then keys = Object.keys @externalAttributes\n            for key in keys\n                if key of @externalAttributes\n                    delete @externalAttributes[key]\n                    @wasChanged?()\n"]}