{"version":3,"sources":["structure.litcoffee"],"names":["Structure","slice","exports","c","child","children","j","len","ref","arguments","length","call","this","computedAttributes","externalAttributes","parentNode","childList","results","removeFromParent","wasInserted","IDs","instanceWithID","id","prototype","nextUnusedID","result","indexOf","getID","ID","releaseID","pop","parent","indexInParent","ref1","previousSibling","index","nextSibling","originalIndex","originalParent","splice","wasRemoved","removeChild","atIndex","insertChild","beforeIndex","concat","replaceWith","other","copy","C","S","JSON","parse","stringify","isEarlierThan","ancestorsOfOther","commonAncestorIndex","myAncestorIndex","nextAncestor","otherAncestorIndex","otherRelevantAncestor","relevantAncestor","walk","unshift","getComputedAttribute","key","setComputedAttribute","value","wasChanged","clearComputedAttributes","keys","Object","compute","arg","args","func","params","Array","apply","getExternalAttribute","setExternalAttribute","clearExternalAttributes","attr","object","setup","recurConnect","recurFindTargets","recurGetID","targets","node","k","len1","target","hasOwnProperty","connectTo","fillOutConnections","T","arrayToObject","count","ins","moreData","name","name1","objectToArray","outs","ref2","ref3","ref4","ref5","ref6","source","sourceOuts","targetIns","type","push","Number","array","base","connection","Math","max","otherStructure","connectionType","disconnectFrom","inIndex","outIndex","allConnectionsOut","ofThisType","conn","allConnectionsIn","allConnectionsTo","properties"],"mappings":"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","file":"structure.js","sourcesContent":["\n# LDE Structures\n\nThe very generic word \"structure\" is used in the LDE to describe a subtree\nof the LDE Document.  For more details on this, see\n[the design overview docs](https://lurchmath.github.io/lde/site/overview/).\n\n    exports.Structure = class Structure\n\n## Unique IDs for instances\n\nWe want to be able to give instance of this class unique IDs.  To do so, we\nwill track those IDs in a class variable defined here, and provide class\nmethods for assigning and revoking IDs to instances.  IDs will be\nnonnegative integers, and we will track them using an array.\n\n        IDs : [ ]\n        @instanceWithID : ( id ) -> Structure::IDs[id]\n        @nextUnusedID : ->\n            result = Structure::IDs.indexOf null\n            if result >= 0 then result else Structure::IDs.length\n\nThe following two functions, which can be called in an instance to request a\nnew, unique ID, or to relinquish one back into the pool, are optional for\nany given instance.  That is, it is not required that each instance have an\nID.  But this system ensures that if IDs are assigned in this way, then they\nwill be globally unique for all instances.\n\nEnsure that any instance that calls `getID` at some point later calls\n`releaseID`, or the `IDs` array will become enormous, a memory leak.\n\n        getID : ->\n            return if @ID?\n            @ID = Structure.nextUnusedID()\n            Structure::IDs[@ID] = this\n        releaseID : ->\n            if @ID?\n                Structure::IDs[@ID] = null\n                delete @ID\n                while Structure::IDs[Structure::IDs.length-1] is null\n                    Structure::IDs.pop()\n\n## Constructor\n\nThe constructor body just initializes internal fields, but it accepts an\narray of initial children as its argument.  Any non-Structure passed as an\nargument is ignored.  See the next section for more details of child\nstructures.\n\n        constructor : ( children... ) ->\n            @computedAttributes = { }\n            @externalAttributes = { }\n            @parentNode = null\n            @childList = ( c for c in children when c instanceof Structure )\n            for child in @childList\n                child.removeFromParent()\n                child.parentNode = this\n                child.wasInserted?()\n\n## Tree structure\n\nStructures form a hierarchy, an n-ary tree.  We thus need functions for\ninserting, removing, and querying parents and children.\n\nFirst, the getters.  When querying the children, we make a copy of the list\nso that clients can feel free to manipulate it without messing up the\nintegrity of the hierarchy.\n\n        parent : -> @parentNode\n        children : -> @childList[..]\n        indexInParent : -> @parentNode?.childList?.indexOf this\n        previousSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index-1]\n        nextSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index+1]\n\nNext, the setters.  There is no setter for the parent, because the parent\npointer of a structure S must be kept consistent with the children list of\nthe parent of S, and so we update both in the setters for children.\n\nWe permit removing children from parents, either with a method in the child\nor in the parent.\n\n        removeFromParent : ->\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @parentNode.childList.splice originalIndex, 1\n                @parentNode = null\n                @wasRemoved? originalParent, originalIndex\n        removeChild : ( atIndex ) -> @childList[atIndex]?.removeFromParent()\n\nWe permit inserting a new child into the parent's child array at any valid\nindex (including the old length of the child array, which appends).  The\nchild to be inserted is first removed from any parent it has when this\nmethod is called.  The default index is 0, so that a call of\n`insertChild(x)` inserts it as the first child.\n\n        insertChild : ( child, beforeIndex = 0 ) ->\n            return unless child instanceof Structure and \\\n                0 <= beforeIndex <= @childList.length\n            child.removeFromParent()\n            @childList = [\n                @childList[...beforeIndex]...\n                child\n                @childList[beforeIndex...]...\n            ]\n            child.parentNode = this\n            child.wasInserted?()\n\nA convenient combination of the above methods is to replace a child with a\nnew structure, deparenting the old child and putting the replacement at the\nsame index in the same parent.\n\n        replaceWith : ( other ) ->\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @removeFromParent()\n                originalParent.insertChild other, originalIndex\n\nAnother possibly convenient utility is to make a copy of the Structure S\n(or equivalently the subtree with root S).\n\n        copy : ->\n            S = new Structure\n            S.computedAttributes = JSON.parse JSON.stringify @computedAttributes\n            S.externalAttributes = JSON.parse JSON.stringify @externalAttributes\n            S.childList = [C.copy() for C in @childList]\n\nWe can ask which of two structures comes earlier in their common ancestor,\nunder pre-order tree traversal, lowest-indexed children first.  The ordering\ndefined here is strict (`A.isEarlierThan A` is false).\n\n        isEarlierThan : ( other ) ->\n            if other not instanceof Structure then return undefined\n            if other is this then return no\n\nGet a list of all ancestors of the other structure.  If it is the root,\nthen I am strictly later than it, and we can return that now.\n\n            ancestorsOfOther = [ other ]\n            while ( nextAncestor = ancestorsOfOther[0].parent() )?\n                ancestorsOfOther.unshift nextAncestor\n\nFind my nearest ancestor that appears in that list.\n\n            walk = this\n            relevantAncestor = null\n            while walk? and walk not in ancestorsOfOther\n                relevantAncestor = walk\n                walk = walk.parent()\n\nIf there was none, we are incomparable; return undefined.  If the nearest\nancestor was me, then other is one of my descendants, so I am earlier than\nit.  If the nearest ancestor was the other structure, then the reverse is\ntrue.\n\n            if not walk? then return undefined\n            if walk is this then return yes\n            if walk is other then return no\n\nCompare the child indices in the common ancestor to determine ordering.\n\n            commonAncestorIndex = ancestorsOfOther.indexOf walk\n            otherRelevantAncestor = ancestorsOfOther[commonAncestorIndex+1]\n            myAncestorIndex = relevantAncestor.indexInParent()\n            otherAncestorIndex = otherRelevantAncestor.indexInParent()\n            myAncestorIndex < otherAncestorIndex\n\n## Computed attributes\n\nThe dictionary of computed attributes has getters and setters that work on\nkeys or key-value pairs (respectively).  The intent is for them to store the\nresults of computations done by the LDE.  There is also a corresponding\n\"clear\" function for deleting entries from the computed attributes\ndictionary.\n\nThe client is permitted to use any keys they like here, but the `feedback`\nkey is special; see [the documentation\nhere](https://lurchmath.github.io/lde/site/phase0-structures/#methods-in-the-structure-class)\nfor details.\n\n        getComputedAttribute : ( key ) -> @computedAttributes[key]\n        setComputedAttribute : ( key, value ) ->\n            if @computedAttributes[key] isnt value\n                @computedAttributes[key] = value\n                @wasChanged?()\n        clearComputedAttributes : ( keys... ) ->\n            if keys.length is 0 then keys = Object.keys @computedAttributes\n            for key in keys\n                if key of @computedAttributes\n                    delete @computedAttributes[key]\n                    @wasChanged?()\n\nThe default implementation of the `compute` member takes any number of keys\nas string arguments, and runs them as member functions, storing the results\nas computed attributes.  Arrays can be used to pass additional arguments.\nSpecifically:\n\n * `S.compute('foo')` means `S.setComputedAttribute('foo',S.foo())`.\n * `S.compute(['foo',1,2,3])` means\n   `S.setComputedAttribute('foo',S.foo(1,2,3))`.\n * `S.compute(arg1,arg2,...)` means `S.compute(arg1)` and then\n   `S.compute(arg2)` and so on.\n\nMore details re in [the documentation\nhere](https://lurchmath.github.io/lde/site/phase0-structures/#methods-in-the-structure-class).\n\n        compute : ( args... ) ->\n            for arg in args\n                if arg not instanceof Array then arg = [ arg ]\n                [ func, params... ] = arg\n                @setComputedAttribute func, @[func] params...\n\n## External attributes\n\nThe dictionary of external attributes has get/set/clear functions just as we\nhave for computed attributes.  The intent is for them to store data provided\nby the client, and the LDE will not alter it.\n\n        getExternalAttribute : ( key ) -> @externalAttributes[key]\n        setExternalAttribute : ( key, value ) ->\n            if @externalAttributes[key] isnt value\n                @externalAttributes[key] = value\n                @wasChanged?()\n        clearExternalAttributes : ( keys... ) ->\n            if keys.length is 0 then keys = Object.keys @externalAttributes\n            for key in keys\n                if key of @externalAttributes\n                    delete @externalAttributes[key]\n                    @wasChanged?()\n\nExternal attributes can also be added with an `attr()` function that returns\nthe instance, thus supporting method chaining.  This is useful when\nconstructing objects of this class, especially for unit testing, using\ncode like `Structure( Structure().attr(...), ... )`.  It takes an object and\ninstalls all of its key-value pairs as external attributes.\n\n        attr : ( object ) ->\n            @setExternalAttribute key, value for own key, value of object\n            this\n\nOn the topic of conveniences for constructing instances, the following\nmethod can be used at the top level of a nested set of constructor calls,\nto traverse the final tree after constructing it, and performs the\nconvenience cleanup routines described within the function itself.\n\nThis is intended to be used when constructing large structures, as in\n`result = Structure( ...lots of children... ).setup()`.\n\n        setup : ->\n\nEvery structure and substructure will be given a unique ID.\n\n            recurGetID = ( node ) ->\n                node.getID()\n                recurGetID child for child in node.children()\n            recurGetID this\n\nEvery structure with an external attribute key \"label for\", \"reason for\", or\n\"premise for\" and value X will be converted into a connection to node X of\ntype \"label\", \"reason\", or \"premise\", respectively.  Node X will be found by\nseeking a node with attribute key \"id\" and value X.\n\nAll attributes with key id are then deleted.\n\nAlternately the same keys could be associated with value \"previous\" or\n\"next\" to indicate connection to a sibling, with no id required.\n\n            targets = { }\n            recurFindTargets = ( node ) ->\n                if ( id = node.getExternalAttribute 'id' )?\n                    targets[id] = node\n                    node.clearExternalAttributes 'id'\n                recurFindTargets child for child in node.children()\n            recurFindTargets this\n            recurConnect = ( node ) ->\n                for attr in [ 'label', 'premise', 'reason' ]\n                    if ( value = node.getExternalAttribute \"#{attr} for\" )?\n                        if value is 'previous'\n                            target = node.previousSibling()\n                        else if value is 'next'\n                            target = node.nextSibling()\n                        else if targets.hasOwnProperty value\n                            target = targets[value]\n                        else\n                            target = null\n                        if target? then node.connectTo target, attr\n                        node.clearExternalAttributes \"#{attr} for\"\n                recurConnect child for child in node.children()\n            recurConnect this\n\nWe then check all connections within this structure for consistency, and\nreturn the structure for use in chaining.\n\n            @fillOutConnections()\n            this\n\n## Connections\n\nStructures may have connections among them, specified using external\nattributes.  The documentation\n[here](https://lurchmath.github.io/lde/site/phase0-structures/#connections)\ncovers the concept in detail.  We provide the following functions to make it\neasier for clients to create, remove, or query connections.\n\n### Making connections consistent\n\nThe first function ensures that all connections in a hierarchy are properly\nrecorded twice, once as outgoing from the source, and once as incoming to\nthe target.  This consistency is assumed by the query functions.  Run this\non the root of your hierarchy if you have any reason to believe that the\nconnections may not be stored consistently.\n\nBecause connections depend on IDs, this routine does nothing if this\nStructure does not already have an ID.\n\n        fillOutConnections : ->\n\nRecur on children, but if this object has no ID, we can't go beyond that.\n\n            child.fillOutConnections() for child in @childList\n            if not @ID? then return\n\nWe define an internal function for converting multisets of target-type pairs\nfrom array representation to an easier-to-work-with object representation,\nand then an inverse of that function.  These make the rest of this function\neaiser to write.\n\nThe \"array\" form is as in the docs linked to above,\n`[ [targID, connType], ... ]`.  The \"object\" form maps target keys to\nobjects whose key-value pairs are type-count pairs, where the count is the\nnumber of times the `[targID,connType]` pair appeared in the array.\nThat is, `{ targID: { type: count, ... }, ... }`.\n\n            arrayToObject = ( array ) ->\n                result = { }\n                for connection in array\n                    [ target, type ] = connection\n                    result[target] ?= { }\n                    result[target][type] ?= 0\n                    result[target][type]++\n                result\n            objectToArray = ( object ) ->\n                result = [ ]\n                for own target, moreData of object\n                    for own type, count of moreData\n                        for i in [1..count]\n                            result.push [ Number( target ), type ]\n                result\n\nNow find all my outgoing connections, and ensure they exist in at least the\nsame quantity on both sides.\n\n            outs = arrayToObject \\\n                ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            for own target, moreData of outs\n                continue unless ( T = Structure.instanceWithID target )?\n                targetIns = arrayToObject \\\n                    ( T.getExternalAttribute 'connectionsIn' ) ? [ ]\n                targetIns[@ID] ?= { }\n                for own type, count of moreData\n                    moreData[type] = targetIns[@ID][type] =\n                        Math.max count, targetIns[@ID][type] ? 0\n                T.setExternalAttribute 'connectionsIn',\n                    objectToArray targetIns\n\nRepeat the same exrecise for my incoming connections.\n\n            ins = arrayToObject \\\n                ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n            for own source, moreData of ins\n                continue unless ( S = Structure.instanceWithID source )?\n                sourceOuts = arrayToObject \\\n                    ( S.getExternalAttribute 'connectionsOut' ) ? [ ]\n                sourceOuts[@ID] ?= { }\n                for own type, count of moreData\n                    moreData[type] = sourceOuts[@ID][type] =\n                        Math.max count, sourceOuts[@ID][type] ? 0\n                S.setExternalAttribute 'connectionsOut',\n                    objectToArray sourceOuts\n\n### Making consistent connections\n\nAnother way to ensure that connections among structures in a hierarchy are\nconsistent is to avoid directly editing the external attribute containing\nthe connections data, and instead use the following two convenience\nfunctions for creating or deleting connections.\n\nThe first one creates a new connection of the given type from this structure\nto another.  Because there may be multiple connections of a given type\nbetween the same two structures, calling this repeatedly adds new\nconnections.\n\nThese functions do nothing if either of the two structures is lacking an ID.\nThey return true on success and false on failure.\n\n        connectTo : ( otherStructure, connectionType ) ->\n            return no unless @ID? and \\\n                otherStructure instanceof Structure and otherStructure.ID?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ins = ( otherStructure.getExternalAttribute 'connectionsIn' ) \\\n                ? [ ]\n            outs.push [ otherStructure.ID, connectionType ]\n            ins.push [ @ID, connectionType ]\n            @setExternalAttribute 'connectionsOut', outs\n            otherStructure.setExternalAttribute 'connectionsIn', ins\n            yes\n\nThe delete function does nothing if there is no connection to delete.\n\n        disconnectFrom : ( otherStructure, connectionType ) ->\n            return no unless @ID? and \\\n                otherStructure instanceof Structure and otherStructure.ID?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ins = ( otherStructure.getExternalAttribute 'connectionsIn' ) \\\n                ? [ ]\n            outIndex = inIndex = 0\n            while outIndex < outs.length and \\\n                  ( outs[outIndex][0] isnt otherStructure.ID or \\\n                    outs[outIndex][1] isnt connectionType )\n                outIndex++\n            if outIndex is outs.length then return no\n            while inIndex < ins.length and \\\n                  ( ins[inIndex][0] isnt @ID or \\\n                    ins[inIndex][1] isnt connectionType )\n                inIndex++\n            if inIndex is ins.length then return no\n            outs.splice outIndex, 1\n            ins.splice inIndex, 1\n            @setExternalAttribute 'connectionsOut', outs\n            otherStructure.setExternalAttribute 'connectionsIn', ins\n            yes\n\n### Querying connections\n\nThe following functions are some conveniences for querying what connections\nexist from a given structure object to/from others.\n\nFirst, we can fetch all connections of a given type that exit a given\nstructure object.  It returns a multiset of target structure IDs, in the\nform of an array with possible repeated entries.  If the user omits the\ntype, then all outgoing connections are returned, not as targets only, but\nas target-type pairs, `[[targetID,typeString],...]`.\n\n        allConnectionsOut : ( ofThisType ) ->\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            if not ofThisType? then return outs\n            ( conn[0] for conn in outs when conn[1] is ofThisType )\n\nThen we can do the same thing for incoming connections.\n\n        allConnectionsIn : ( ofThisType ) ->\n            ins = ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n            if not ofThisType? then return ins\n            ( conn[0] for conn in ins when conn[1] is ofThisType )\n\nWe can also request all connections between two given structures, which will\nreturn a multiset of connection types, in the form of an array with possible\nrepeated entries.  Returns null if the argument is not a structure, or is\none without an ID.\n\n        allConnectionsTo : ( otherStructure ) ->\n            return null unless otherStructure instanceof Structure and \\\n                otherStructure.ID?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ( conn[1] for conn in outs when conn[0] is otherStructure.ID )\n\nThe final query treats all incoming connections to a structure as if they\ngive it \"properties.\"  If A connects to B with type T, then when we look up\nthe key T in B's properties, we get an array that will contain A.  For\nmore information, see the documentation\n[here](https://lurchmath.github.io/lde/site/phase0-structures/#connections).\n\n        properties : ->\n            result = { }\n            for conn in ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n                if ( source = Structure.instanceWithID conn[0] )?\n                    ( result[conn[1]] ?= [ ] ).push source\n            result\n"]}