{"version":3,"sources":["structure.litcoffee"],"names":["Structure","slice","child","children","j","len","arguments","length","call","this","externalAttributes","parentNode","childList","insertChild","all","first","subclasses","addSubclass","name","classObj","prototype","className","toJSON","includeID","externals","id","JSON","parse","stringify","results","ref","fromJSON","json","result","func","args","ctor","parent","indexInParent","ref1","indexOf","previousSibling","index","nextSibling","copy","C","S","isEarlierThan","other","ancestorsOfOther","commonAncestorIndex","myAncestorIndex","nextAncestor","otherAncestorIndex","otherRelevantAncestor","relevantAncestor","walk","unshift","removeFromParent","originalIndex","originalParent","willBeRemoved","splice","wasRemoved","removeChild","atIndex","beforeIndex","willBeInserted","wasInserted","replaceWith","getExternalAttribute","key","setExternalAttribute","value","willBeChanged","wasChanged","clearExternalAttributes","keys","Object","attr","object","setup","recurConnect","recurFindTargets","targets","node","k","len1","target","hasOwnProperty","connectTo","fillOutConnections","IDs","instanceWithID","trackIDs","recursive","untrackIDs","clearIDs","T","arrayToObject","count","ins","moreData","name1","name2","objectToArray","outs","ref2","ref3","ref4","ref5","ref6","source","sourceOuts","targetIns","type","push","array","base","connection","Math","max","otherStructure","connectionType","disconnectFrom","inIndex","outIndex","allConnectionsOut","ofThisType","conn","allConnectionsIn","allConnectionsTo","isAccessibleTo","isInTheScopeOf","iteratorOverAccessibles","ancestor","sibling","next","iteratorOverScope","chain","last","pop","iterator","predicate","firstAccessible","allAccessibles","firstInScope","allInScope","exports"],"mappings":"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","file":"structure.js","sourcesContent":["\n# LDE Structures\n\nThe very generic word \"structure\" is used in the LDE to describe a subtree\nof the LDE Document.  For more details on this, see\n[the design overview docs](https://lurchmath.github.io/lde/site/overview/).\n\n    class Structure\n\nIf you plan to develop a subclass of `Structure`, be sure to follow the\nrequirement listed in the\n[Serialization and Deserialization](#serialization-and-deserialization)\nsection, below.\n\n## Constructor\n\nThe constructor body just initializes internal fields, but it accepts an\narray of initial children as its argument.  Any non-Structure passed as an\nargument is ignored.  See the next section for more details of child\nstructures.\n\n        constructor : ( children... ) ->\n            @externalAttributes = { }\n            @parentNode = null\n            @childList = [ ]\n            for child in children\n                @insertChild child, @childList.length\n\n## Serialization and deserialization\n\nWe need to be able to convert structure hierarchies to/from JSON data.  We\ndo so with the routines in this section.\n\n### Registering class names\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nAfter all, there will be sublcasses of this class defined, and during\ndeserialization, instances of those subclasses will need to be created, as\nopposed to generic `Structure`s.\n\nTo facilitate this, we track all subclasses in a single global variable,\nhere.  Add one using the registration function provided.\n\n        subclasses : { }\n        @addSubclass : ( name, classObj ) ->\n            Structure::subclasses[name] = classObj\n            name\n\nWhen should you call it?  In your subclass, create a class variable called\n`className` and assign `Structure.addSubclass 'your class name', YourClass`\nto that member.  Follow this example, which we do here for the `Structure`\nbase class:\n\n        className : Structure.addSubclass 'Structure', Structure\n\n### Serialization to JSON\n\nThe serialized version of a class contains some objects from within the\nclass, not copies but the same objects, so that serialization can be fast.\nThus you should not modify the serialized version's members.  If you want an\nindependent copy, run `JSON.parse` on `JSON.stringify` of the serialized\nversion.\n\n        toJSON : ( includeID = yes ) ->\n            if includeID or not @id()?\n                externals = @externalAttributes\n            else\n                externals = JSON.parse JSON.stringify @externalAttributes\n                delete externals.id\n            className : @className\n            externalAttributes : externals\n            children : ( child.toJSON includeID for child in @childList )\n\n### Deserialization from JSON\n\nDeserialization is a method in the class, because of course it is called\nwhen you have no instance at hand, and wish to create one.\n\nIt does not re-use the members from the parameter, but explicitly copies\nthem using a combination of `JSON.parse` and `JSON.stringify`, so that a\ndeserialized version of an existing object will share no members with that\nobject.\n\n        @fromJSON : ( json ) ->\n            classObj = Structure::subclasses[json.className]\n            children =\n                ( Structure.fromJSON child for child in json.children )\n            result = new classObj children...\n            result.externalAttributes =\n                JSON.parse JSON.stringify json.externalAttributes\n            result\n\n## Tree structure\n\nStructures form a hierarchy, an n-ary tree.  We thus need functions for\ninserting, removing, and querying parents and children.\n\nFirst, the getters.  When querying the children, we make a copy of the list\nso that clients can feel free to manipulate it without messing up the\nintegrity of the hierarchy.\n\n        parent : -> @parentNode\n        children : -> @childList[..]\n        indexInParent : -> @parentNode?.childList?.indexOf this\n        previousSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index-1]\n        nextSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index+1]\n\nAnother possibly convenient utility is to make a copy of the Structure S\n(or equivalently the subtree with root S).\n\n        copy : ->\n            S = new Structure\n            S.externalAttributes =\n                JSON.parse JSON.stringify @externalAttributes\n            S.childList = ( C.copy() for C in @childList )\n            child.parentNode = S for child in S.childList\n            S\n\nWe can ask which of two structures comes earlier in their common ancestor,\nunder pre-order tree traversal, lowest-indexed children first.  The ordering\ndefined here is strict (`A.isEarlierThan A` is false).\n\n        isEarlierThan : ( other ) ->\n            if other not instanceof Structure then return undefined\n            if other is this then return no\n\nGet a list of all ancestors of the other structure.  If it is the root,\nthen I am strictly later than it, and we can return that now.\n\n            ancestorsOfOther = [ other ]\n            while ( nextAncestor = ancestorsOfOther[0].parent() )?\n                ancestorsOfOther.unshift nextAncestor\n\nFind my nearest ancestor that appears in that list.\n\n            walk = this\n            relevantAncestor = null\n            while walk? and walk not in ancestorsOfOther\n                relevantAncestor = walk\n                walk = walk.parent()\n\nIf there was none, we are incomparable; return undefined.  If the nearest\nancestor was me, then other is one of my descendants, so I am earlier than\nit.  If the nearest ancestor was the other structure, then the reverse is\ntrue.\n\n            if not walk? then return undefined\n            if walk is this then return yes\n            if walk is other then return no\n\nCompare the child indices in the common ancestor to determine ordering.\n\n            commonAncestorIndex = ancestorsOfOther.indexOf walk\n            otherRelevantAncestor = ancestorsOfOther[commonAncestorIndex+1]\n            myAncestorIndex = relevantAncestor.indexInParent()\n            otherAncestorIndex = otherRelevantAncestor.indexInParent()\n            myAncestorIndex < otherAncestorIndex\n\nNext, the setters.  There is no setter for the parent, because the parent\npointer of a structure S must be kept consistent with the children list of\nthe parent of S, and so we update both in the setters for children.\n\nWe permit removing children from parents, either with a method in the child\nor in the parent.\n\nWe notify the child of its removal through calling two event handlers (if\nthey exist) in the child object: `willBeRemoved()` immediately before the\nremoval and `wasRemoved(parent,index)` after the removal, passing the former\nparent and child index within that parent.\n\n        removeFromParent : ->\n            if ( originalParent = @parentNode )?\n                @willBeRemoved?()\n                originalIndex = @indexInParent()\n                @parentNode.childList.splice originalIndex, 1\n                @parentNode = null\n                @wasRemoved? originalParent, originalIndex\n        removeChild : ( atIndex ) -> @childList[atIndex]?.removeFromParent()\n\nWe permit inserting a new child into the parent's child array at any valid\nindex (including the old length of the child array, which appends).  The\nchild to be inserted is first removed from any parent it has when this\nmethod is called.  The default index is 0, so that a call of\n`insertChild(x)` inserts it as the first child.\n\nIf the child to be inserted is an ancestor of this structure, then we\nremove this structure from its parent, to obey the insertion command given\nwhile still maintaining acyclicity in the tree structure.  If the child to\nbe inserted is this node itself, this function does nothing.\n\nWe notify the child of its insertion through calling two event handlers (if\nthey exist) in the child object: `willBeInserted(parent,index)` immediately\nbefore the removal and `wasInserted()` after the removal.  The parameters to\nthe first of these routines are the soon-to-be parent and the index within\nthat parent at which the insertion will take place.\n\nIf the child or this object needs to first be removed from a parent as\ndescribed above, there will also be removal events, as documented in the\n`removeFromParent()` function, above.\n\n        insertChild : ( child, beforeIndex = 0 ) ->\n            return unless child instanceof Structure and \\\n                child isnt this and \\\n                0 <= beforeIndex <= @childList.length\n            walk = this\n            while ( walk = walk.parent() )?\n                if walk is child then @removeFromParent() ; break\n            child.removeFromParent()\n            child.willBeInserted? this, beforeIndex\n            @childList.splice beforeIndex, 0, child\n            child.parentNode = this\n            child.wasInserted?()\n\nA convenient combination of the above methods is to replace a child with a\nnew structure, deparenting the old child and putting the replacement at the\nsame index in the same parent.\n\nBecause this calls `removeFromParent()` and `insertChild()`, it also\ngenerates calls to the four event handlers mentioned in those functions,\nabove.\n\n        replaceWith : ( other ) ->\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @removeFromParent()\n                originalParent.insertChild other, originalIndex\n\n## External attributes\n\nThe dictionary of external attributes has getters and setters that work on\nkeys or key-value pairs (respectively).  There is also a corresponding\n\"clear\" function for deleting entries from the external attributes\ndictionary.\n\nNo checks are put on what kind of data can be used for the values of this\ndictionary, but they should be JSON data only, to support serialization.\n(Checks are omitted for efficiency.)\n\nWe notify the structure of changes to its external attributes through\ncalling two event handlers (if they exist) in the object:\n`willBeChanged(key)` immediately before the change and `wasChanged(key)`\nafter the removal, in both cases passing the key from the changing key-value\npair.  These events are the same whether the key-value pair is inserted,\nmodified, or removed.\n\n        getExternalAttribute : ( key ) -> @externalAttributes[key]\n        setExternalAttribute : ( key, value ) ->\n            if @externalAttributes[key] isnt value\n                @willBeChanged? key\n                @externalAttributes[key] = value\n                @wasChanged? key\n        clearExternalAttributes : ( keys... ) ->\n            if keys.length is 0 then keys = Object.keys @externalAttributes\n            for key in keys\n                if key of @externalAttributes\n                    @willBeChanged? key\n                    delete @externalAttributes[key]\n                    @wasChanged? key\n\nExternal attributes can also be added with an `attr()` function that returns\nthe instance, thus supporting method chaining.  This is useful when\nconstructing objects of this class, especially for unit testing, using\ncode like `Structure( Structure().attr(...), ... )`.  It takes an object and\ninstalls all of its key-value pairs as external attributes.\n\n        attr : ( object ) ->\n            @setExternalAttribute key, value for own key, value of object\n            this\n\nOn the topic of conveniences for constructing instances, the following\nmethod can be used at the top level of a nested set of constructor calls,\nto traverse the final tree after constructing it, and performs the\nconvenience cleanup routines described within the function itself.\n\nThis is intended to be used when constructing large structures, as in\n`result = Structure( ...lots of children... ).setup()`.\n\n        setup : ->\n\nEvery structure with an external attribute key \"label for\", \"reason for\", or\n\"premise for\" and value X will be converted into a connection to node X of\ntype \"label\", \"reason\", or \"premise\", respectively.  Node X will be found by\nseeking a node with attribute key \"id\" and value X.\n\nAll attributes with key id are then deleted.\n\nAlternately the same keys could be associated with value \"previous\" or\n\"next\" to indicate connection to a sibling, with no id required.\n\n            targets = { }\n            recurFindTargets = ( node ) ->\n                if ( id = node.getExternalAttribute 'id' )?\n                    targets[id] = node\n                recurFindTargets child for child in node.children()\n            recurFindTargets this\n            recurConnect = ( node ) ->\n                for attr in [ 'label', 'premise', 'reason' ]\n                    if ( value = node.getExternalAttribute \"#{attr} for\" )?\n                        if value is 'previous'\n                            target = node.previousSibling()\n                        else if value is 'next'\n                            target = node.nextSibling()\n                        else if targets.hasOwnProperty value\n                            target = targets[value]\n                        else\n                            target = null\n                        if target? then node.connectTo target, attr\n                        node.clearExternalAttributes \"#{attr} for\"\n                recurConnect child for child in node.children()\n            recurConnect this\n\nWe then check all connections within this structure for consistency, and\nreturn the structure for use in chaining.\n\n            @fillOutConnections()\n            this\n\n## Unique IDs for instances\n\nClients of this class may give instances of it unique IDs stored in external\nattributes.  (See the corresponding convenience function for querying such\nIDs in the [Attribute Conventions section](#attribute-conventions).)  To\ntrack those IDs, we use a class variable defined here, and provide class\nmethods for tracking and untracking IDs in a structure hierarchy.  IDs can\nbe any string, and thus we track them in an object, using the strings as\nkeys.\n\n        IDs : { }\n        @instanceWithID : ( id ) -> Structure::IDs[id]\n\nThe following two functions recur through a given structure hierarchy and\nsave all of its IDs into (or delete all of its IDs from) the above class\nvariable.  Whenever a structure hierarchy is no longer used by the client,\n`untrackIDs` should be called on that hierarchy to prevent memory leaks.\n\n        id : -> @getExternalAttribute 'id'\n        trackIDs : ( recursive = yes ) ->\n            if @id()? then Structure::IDs[@id()] = @\n            if recursive then child.trackIDs() for child in @children()\n        untrackIDs : ( recursive = yes ) ->\n            if @id()? then delete Structure::IDs[@id()]\n            if recursive then child.untrackIDs() for child in @children()\n\nThe following function removes all ID attributes from a structure hierarchy.\nThis is useful, for example, after making a deep copy of a structure, so\nthat the copied version does not violate the global uniqueness of IDs.\n\n        clearIDs : ( recursive = yes ) ->\n            @clearExternalAttributes 'id'\n            if recursive then child.clearIDs() for child in @children()\n\n## Connections\n\nStructures may have connections among them, specified using external\nattributes.  The documentation\n[here](https://lurchmath.github.io/lde/site/phase0-structures/#connections)\ncovers the concept in detail.  We provide the following functions to make it\neasier for clients to create, remove, or query connections.\n\n### Making connections consistent\n\nThe first function ensures that all connections in a hierarchy are properly\nrecorded twice, once as outgoing from the source, and once as incoming to\nthe target.  This consistency is assumed by the query functions.  Run this\non the root of your hierarchy if you have any reason to believe that the\nconnections may not be stored consistently.\n\nBecause connections depend on IDs, this routine does nothing if this\nStructure does not already have an ID.\n\n        fillOutConnections : ->\n\nRecur on children, but if this object has no ID, we can't go beyond that.\n\n            child.fillOutConnections() for child in @childList\n            if not @id()? then return\n\nWe define an internal function for converting multisets of target-type pairs\nfrom array representation to an easier-to-work-with object representation,\nand then an inverse of that function.  These make the rest of this function\neaiser to write.\n\nThe \"array\" form is as in the docs linked to above,\n`[ [targID, connType], ... ]`.  The \"object\" form maps target keys to\nobjects whose key-value pairs are type-count pairs, where the count is the\nnumber of times the `[targID,connType]` pair appeared in the array.\nThat is, `{ targID: { type: count, ... }, ... }`.\n\n            arrayToObject = ( array ) ->\n                result = { }\n                for connection in array\n                    [ target, type ] = connection\n                    result[target] ?= { }\n                    result[target][type] ?= 0\n                    result[target][type]++\n                result\n            objectToArray = ( object ) ->\n                result = [ ]\n                for own target, moreData of object\n                    for own type, count of moreData\n                        for i in [1..count]\n                            result.push [ target, type ]\n                result\n\nNow find all my outgoing connections, and ensure they exist in at least the\nsame quantity on both sides.\n\n            outs = arrayToObject \\\n                ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            for own target, moreData of outs\n                continue unless ( T = Structure.instanceWithID target )?\n                targetIns = arrayToObject \\\n                    ( T.getExternalAttribute 'connectionsIn' ) ? [ ]\n                targetIns[@id()] ?= { }\n                for own type, count of moreData\n                    moreData[type] = targetIns[@id()][type] =\n                        Math.max count, targetIns[@id()][type] ? 0\n                T.setExternalAttribute 'connectionsIn',\n                    objectToArray targetIns\n\nRepeat the same exrecise for my incoming connections.\n\n            ins = arrayToObject \\\n                ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n            for own source, moreData of ins\n                continue unless ( S = Structure.instanceWithID source )?\n                sourceOuts = arrayToObject \\\n                    ( S.getExternalAttribute 'connectionsOut' ) ? [ ]\n                sourceOuts[@id()] ?= { }\n                for own type, count of moreData\n                    moreData[type] = sourceOuts[@id()][type] =\n                        Math.max count, sourceOuts[@id()][type] ? 0\n                S.setExternalAttribute 'connectionsOut',\n                    objectToArray sourceOuts\n\n### Making consistent connections\n\nAnother way to ensure that connections among structures in a hierarchy are\nconsistent is to avoid directly editing the external attribute containing\nthe connections data, and instead use the following two convenience\nfunctions for creating or deleting connections.\n\nNote that the LDE should not be directly editing external attributes anyway,\nbecause they are defined to be read-only from this side.  But these two\nfunctions are useful when constructing structures to use in testing, and in\nparticular for implementing the `attr` and `setup` functions above, which\nare very useful in the unit testing suite.\n\nThe first one creates a new connection of the given type from this structure\nto another.  Because there may be multiple connections of a given type\nbetween the same two structures, calling this repeatedly adds new\nconnections.\n\nThese functions do nothing if either of the two structures is lacking an ID.\nThey return true on success and false on failure.\n\n        connectTo : ( otherStructure, connectionType = '' ) ->\n            return no unless @id()? and \\\n                otherStructure instanceof Structure and otherStructure.id()?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ins = ( otherStructure.getExternalAttribute 'connectionsIn' ) \\\n                ? [ ]\n            outs.push [ otherStructure.id(), connectionType ]\n            ins.push [ @id(), connectionType ]\n            @setExternalAttribute 'connectionsOut', outs\n            otherStructure.setExternalAttribute 'connectionsIn', ins\n            yes\n\nThe delete function does nothing if there is no connection to delete.\n\n        disconnectFrom : ( otherStructure, connectionType = '' ) ->\n            return no unless @id()? and \\\n                otherStructure instanceof Structure and otherStructure.id()?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ins = ( otherStructure.getExternalAttribute 'connectionsIn' ) \\\n                ? [ ]\n            outIndex = inIndex = 0\n            while outIndex < outs.length and \\\n                  ( outs[outIndex][0] isnt otherStructure.id() or \\\n                    outs[outIndex][1] isnt connectionType )\n                outIndex++\n            if outIndex is outs.length then return no\n            while inIndex < ins.length and \\\n                  ( ins[inIndex][0] isnt @id() or \\\n                    ins[inIndex][1] isnt connectionType )\n                inIndex++\n            if inIndex is ins.length then return no\n            outs.splice outIndex, 1\n            ins.splice inIndex, 1\n            @setExternalAttribute 'connectionsOut', outs\n            otherStructure.setExternalAttribute 'connectionsIn', ins\n            yes\n\n### Querying connections\n\nThe following functions are some conveniences for querying what connections\nexist from a given structure object to/from others.\n\nFirst, we can fetch all connections of a given type that exit a given\nstructure object.  It returns a multiset of target structure IDs, in the\nform of an array with possible repeated entries.  If the user omits the\ntype, then all outgoing connections are returned, not as targets only, but\nas target-type pairs, `[[targetID,typeString],...]`.\n\n        allConnectionsOut : ( ofThisType ) ->\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            if not ofThisType? then return outs\n            ( conn[0] for conn in outs when conn[1] is ofThisType )\n\nThen we can do the same thing for incoming connections.\n\n        allConnectionsIn : ( ofThisType ) ->\n            ins = ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n            if not ofThisType? then return ins\n            ( conn[0] for conn in ins when conn[1] is ofThisType )\n\nWe can also request all connections between two given structures, which will\nreturn a multiset of connection types, in the form of an array with possible\nrepeated entries.  Returns null if the argument is not a structure, or is\none without an ID.\n\n        allConnectionsTo : ( otherStructure ) ->\n            return null unless otherStructure instanceof Structure and \\\n                otherStructure.id()?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ( conn[1] for conn in outs when conn[0] is otherStructure.id() )\n\n## Accessibility\n\nA structure A is accessible to a structure B if they have a common ancestor\nand are positioned within that ancestor in such a way that B could cite A as\na premise.\n\nThe officially definition is that a structure is accessible to all of its\nprevious siblings, all the previous siblings of its parent, all the previous\nsiblings of its grandparent, and so on up the ancestor chain.  Note that a\nstructure is not accessible to itself, nor to any of its ancestors.\nConversely, if A is accessible to B, then we say that B is in the scope of\nA.\n\n### Foundational accessibility functions\n\nWe begin with two functions, implementing the accessibility/scope relations.\n\n        isAccessibleTo : ( other ) ->\n            if other not instanceof Structure then return no\n            if not other.parent()? then return no\n            if @parent() is other.parent()\n                @indexInParent() < other.indexInParent()\n            else\n                @isAccessibleTo other.parent()\n        isInTheScopeOf : ( other ) -> other.isAccessibleTo this\n\nFor all the other computations we will want to do with scopes and\naccessibility, we will need iterators over all structures accessible to (or\nin the scope of, respectively) this one.  An iterator for a set S is an\nobject `I` such that repeated calls to `I.next()` yield new elements of S\nuntil S is exhausted, at which point all future calls to `I.next()` return\nnull.\n\nThe first iterator function lists all structures accessible to this one, in\nreverse order in the hierarchy.  That is, all previous siblings are yielded\nfrom right to left, then all previous siblings of the parent, and so on.\n\n        iteratorOverAccessibles : ->\n            ancestor : this\n            sibling : this\n            next : ->\n                if not @ancestor? then return null\n                if ( @sibling = @sibling.previousSibling() )?\n                    return @sibling\n                @sibling = @ancestor = @ancestor.parent()\n                @next()\n\nThe second iterator function lists all structures in the scope of this one,\nin forward order in the hierarchy.  That is, all descendants of the next\nsibling are yielded, then all descendants of the subsequent sibling, and so\non, in the order of a postorder tree traversal.\n\n        iteratorOverScope : ->\n            chain : [ this ]\n            next : ->\n                if @chain.length is 0 then return null\n                last = @chain.pop()\n                if ( walk = last.nextSibling() )?\n                    @chain.push walk\n                    @chain.push walk while ( walk = walk.children()[0] )?\n                    @chain[@chain.length-1]\n                else if @chain.length > 0\n                    @chain[@chain.length-1]\n                else\n                    null\n\n### Accessibility convenience functions\n\nWe then create two functions that can use these iterators for searching or\nenumeration.  Call `first(iterator,predicate)` to get the first element the\niterator yields satisfying the predicate.  Call `all(iterator,prediacte)`\nwith the obvious related meaning.  In each case, the predicate can be\nomitted to get the first element or all elements (no restrictions).  If the\npredicate is never satisfied, `first` returns undefiend, and `all` returns\nan empty array.\n\n        first = ( iterator, predicate = -> yes ) ->\n            while ( next = iterator.next() )?\n                if predicate next then return next\n        all = ( iterator, predicate = -> yes ) ->\n            result = [ ]\n            while ( next = iterator.next() )?\n                if predicate next then result.push next\n            result\n\nWe can then write useful functions whose names give their obvious meanings,\nby combining the tools above.\n\n        firstAccessible : ( predicate = -> yes ) ->\n            first @iteratorOverAccessibles(), predicate\n        allAccessibles : ( predicate = -> yes ) ->\n            all @iteratorOverAccessibles(), predicate\n        firstInScope : ( predicate = -> yes ) ->\n            first @iteratorOverScope(), predicate\n        allInScope : ( predicate = -> yes ) ->\n            all @iteratorOverScope(), predicate\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports? then exports.Structure = Structure\n"]}