{"version":3,"sources":["structure.litcoffee"],"names":["Structure","slice","child","children","i","len","arguments","length","call","this","attributes","parentNode","childList","insertChild","dirty","all","first","isDirty","subclasses","addSubclass","name","classObj","prototype","className","toJSON","includeID","id","JSON","parse","stringify","results","ref","fromJSON","json","result","func","args","ctor","parent","indexInParent","ref1","indexOf","previousSibling","index","nextSibling","copy","C","S","isEarlierThan","other","ancestorsOfOther","commonAncestorIndex","myAncestorIndex","nextAncestor","otherAncestorIndex","otherRelevantAncestor","relevantAncestor","walk","unshift","removeFromParent","originalIndex","originalParent","willBeRemoved","splice","wasRemoved","removeChild","atIndex","beforeIndex","willBeInserted","wasInserted","replaceWith","getAttribute","key","setAttribute","value","willBeChanged","wasChanged","clearAttributes","keys","Object","attr","object","IDs","instanceWithID","trackIDs","recursive","noticeAllConnections","untrackIDs","removeAllConnections","clearIDs","connectionIDs","sourceOfConnection","connect","source","target","data","hasOwnProperty","connectionWillBeInserted","connectionWasInserted","connectTo","getConnectionSource","connectionID","getConnectionTarget","targetID","getConnectionData","getConnectionsIn","push","sort","getConnectionsOut","getAllConnections","out","disconnect","connectionWillBeRemoved","connectionWasRemoved","setConnectionData","connectionWillBeChanged","connectionWasChanged","j","len1","success","transferConnectionsTo","recipient","sourceID","isAccessibleTo","isInTheScopeOf","iteratorOverAccessibles","ancestor","sibling","next","iteratorOverScope","chain","last","pop","iterator","predicate","firstAccessible","allAccessibles","firstInScope","allInScope","feedback","feedbackData","console","log","exports"],"mappings":"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","file":"structure.js","sourcesContent":["\n# LDE Structures\n\nThe very generic word \"structure\" is used in the LDE to describe a subtree\nof the LDE Document.  For more details on this, see\n[the design overview docs](https://lurchmath.github.io/lde/site/overview/).\n\n    class Structure\n\nIf you plan to develop a subclass of `Structure`, be sure to follow the\nrequirement listed in the\n[Serialization and Deserialization](#serialization-and-deserialization)\nsection, below.\n\n## Constructor\n\nThe constructor body just initializes internal fields, but it accepts an\narray of initial children as its argument.  Any non-Structure passed as an\nargument is ignored.  See the next section for more details of child\nstructures.\n\n        constructor : ( children... ) ->\n            @attributes = { }\n            @parentNode = null\n            @childList = [ ]\n            for child in children\n                @insertChild child, @childList.length\n            @dirty = no\n\nWe also include here a simple getter for the `dirty` attribute.  Subclasses\nwill define appropriate setters.\n\n        isDirty : -> @dirty\n\n## Serialization and deserialization\n\nWe need to be able to convert structure hierarchies to/from JSON data.  We\ndo so with the routines in this section.\n\n### Registering class names\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nAfter all, there will be sublcasses of this class defined, and during\ndeserialization, instances of those subclasses will need to be created, as\nopposed to generic `Structure`s.\n\nTo facilitate this, we track all subclasses in a single global variable,\nhere.  Add one using the registration function provided.\n\n        subclasses : { }\n        @addSubclass : ( name, classObj ) ->\n            Structure::subclasses[name] = classObj\n            name\n\nWhen should you call it?  In your subclass, create a class variable called\n`className` and assign `Structure.addSubclass 'your class name', YourClass`\nto that member.  Follow this example, which we do here for the `Structure`\nbase class:\n\n        className : Structure.addSubclass 'Structure', Structure\n\n### Serialization to JSON\n\nThe serialized version of a class contains some objects from within the\nclass, not copies but the same objects, so that serialization can be fast.\nThus you should not modify the serialized version's members.  If you want an\nindependent copy, run `JSON.parse` on `JSON.stringify` of the serialized\nversion.\n\n        toJSON : ( includeID = yes ) ->\n            if includeID or not @id()?\n                attributes = @attributes\n            else\n                attributes = JSON.parse JSON.stringify @attributes\n                delete attributes.id\n            className : @className\n            attributes : attributes\n            children : ( child.toJSON includeID for child in @childList )\n\n### Deserialization from JSON\n\nDeserialization is a method in the class, because of course it is called\nwhen you have no instance at hand, and wish to create one.\n\nIt does not re-use the members from the parameter, but explicitly copies\nthem using a combination of `JSON.parse` and `JSON.stringify`, so that a\ndeserialized version of an existing object will share no members with that\nobject.\n\n        @fromJSON : ( json ) ->\n            classObj = Structure::subclasses[json.className]\n            children =\n                ( Structure.fromJSON child for child in json.children )\n            result = new classObj children...\n            result.attributes = JSON.parse JSON.stringify json.attributes\n            result\n\n## Tree structure\n\nStructures form a hierarchy, an n-ary tree.  We thus need functions for\ninserting, removing, and querying parents and children.\n\nFirst, the getters.  When querying the children, we make a copy of the list\nso that clients can feel free to manipulate it without messing up the\nintegrity of the hierarchy.\n\n        parent : -> @parentNode\n        children : -> @childList[..]\n        indexInParent : -> @parentNode?.childList?.indexOf this\n        previousSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index-1]\n        nextSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index+1]\n\nAnother possibly convenient utility is to make a copy of the Structure S\n(or equivalently the subtree with root S).\n\n        copy : ->\n            S = new Structure\n            S.attributes = JSON.parse JSON.stringify @attributes\n            S.childList = ( C.copy() for C in @childList )\n            child.parentNode = S for child in S.childList\n            S\n\nWe can ask which of two structures comes earlier in their common ancestor,\nunder pre-order tree traversal, lowest-indexed children first.  The ordering\ndefined here is strict (`A.isEarlierThan A` is false).\n\n        isEarlierThan : ( other ) ->\n            if other not instanceof Structure then return undefined\n            if other is this then return no\n\nGet a list of all ancestors of the other structure.  If it is the root,\nthen I am strictly later than it, and we can return that now.\n\n            ancestorsOfOther = [ other ]\n            while ( nextAncestor = ancestorsOfOther[0].parent() )?\n                ancestorsOfOther.unshift nextAncestor\n\nFind my nearest ancestor that appears in that list.\n\n            walk = this\n            relevantAncestor = null\n            while walk? and walk not in ancestorsOfOther\n                relevantAncestor = walk\n                walk = walk.parent()\n\nIf there was none, we are incomparable; return undefined.  If the nearest\nancestor was me, then other is one of my descendants, so I am earlier than\nit.  If the nearest ancestor was the other structure, then the reverse is\ntrue.\n\n            if not walk? then return undefined\n            if walk is this then return yes\n            if walk is other then return no\n\nCompare the child indices in the common ancestor to determine ordering.\n\n            commonAncestorIndex = ancestorsOfOther.indexOf walk\n            otherRelevantAncestor = ancestorsOfOther[commonAncestorIndex+1]\n            myAncestorIndex = relevantAncestor.indexInParent()\n            otherAncestorIndex = otherRelevantAncestor.indexInParent()\n            myAncestorIndex < otherAncestorIndex\n\nNext, the setters.  There is no setter for the parent, because the parent\npointer of a structure S must be kept consistent with the children list of\nthe parent of S, and so we update both in the setters for children.\n\nWe permit removing children from parents, either with a method in the child\nor in the parent.\n\nWe notify the child of its removal through calling two event handlers (if\nthey exist) in the child object: `willBeRemoved()` immediately before the\nremoval and `wasRemoved(parent,index)` after the removal, passing the former\nparent and child index within that parent.\n\n        removeFromParent : ->\n            if ( originalParent = @parentNode )?\n                @willBeRemoved?()\n                originalIndex = @indexInParent()\n                @parentNode.childList.splice originalIndex, 1\n                @parentNode = null\n                @wasRemoved? originalParent, originalIndex\n        removeChild : ( atIndex ) -> @childList[atIndex]?.removeFromParent()\n\nWe permit inserting a new child into the parent's child array at any valid\nindex (including the old length of the child array, which appends).  The\nchild to be inserted is first removed from any parent it has when this\nmethod is called.  The default index is 0, so that a call of\n`insertChild(x)` inserts it as the first child.\n\nIf the child to be inserted is an ancestor of this structure, then we\nremove this structure from its parent, to obey the insertion command given\nwhile still maintaining acyclicity in the tree structure.  If the child to\nbe inserted is this node itself, this function does nothing.\n\nWe notify the child of its insertion through calling two event handlers (if\nthey exist) in the child object: `willBeInserted(parent,index)` immediately\nbefore the removal and `wasInserted()` after the removal.  The parameters to\nthe first of these routines are the soon-to-be parent and the index within\nthat parent at which the insertion will take place.\n\nIf the child or this object needs to first be removed from a parent as\ndescribed above, there will also be removal events, as documented in the\n`removeFromParent()` function, above.\n\n        insertChild : ( child, beforeIndex = 0 ) ->\n            return unless child instanceof Structure and \\\n                child isnt this and \\\n                0 <= beforeIndex <= @childList.length\n            walk = this\n            while ( walk = walk.parent() )?\n                if walk is child then @removeFromParent() ; break\n            child.removeFromParent()\n            child.willBeInserted? this, beforeIndex\n            @childList.splice beforeIndex, 0, child\n            child.parentNode = this\n            child.wasInserted?()\n\nA convenient combination of the above methods is to replace a child with a\nnew structure, deparenting the old child and putting the replacement at the\nsame index in the same parent.\n\nBecause this calls `removeFromParent()` and `insertChild()`, it also\ngenerates calls to the four event handlers mentioned in those functions,\nabove.\n\n        replaceWith : ( other ) ->\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @removeFromParent()\n                originalParent.insertChild other, originalIndex\n\n## Attributes\n\nThe dictionary of attributes has getters and setters that work on keys or\nkey-value pairs (respectively).  There is also a corresponding \"clear\"\nfunction for deleting entries from the attributes dictionary.\n\nNo checks are put on what kind of data can be used for the values of this\ndictionary, but they should be JSON data only, to support serialization.\n(Checks are omitted for efficiency.)\n\nWe notify the structure of changes to its attributes through calling two\nevent handlers (if they exist) in the object: `willBeChanged(key)`\nimmediately before the change and `wasChanged(key)` after the removal, in\nboth cases passing the key from the changing key-value pair.  These events\nare the same whether the key-value pair is inserted, modified, or removed.\n\n        getAttribute : ( key ) -> @attributes[key]\n        setAttribute : ( key, value ) ->\n            if @attributes[key] isnt value\n                @willBeChanged? key\n                @attributes[key] = value\n                @wasChanged? key\n        clearAttributes : ( keys... ) ->\n            if keys.length is 0 then keys = Object.keys @attributes\n            for key in keys\n                if key of @attributes\n                    @willBeChanged? key\n                    delete @attributes[key]\n                    @wasChanged? key\n\nAttributes can also be added with an `attr()` function that returns the\ninstance, thus supporting method chaining.  This is useful when constructing\nobjects of this class, especially for unit testing, using code like\n`Structure( Structure().attr(...), ... )`.  It takes an object and installs\nall of its key-value pairs as attributes.\n\n        attr : ( object ) ->\n            @setAttribute key, value for own key, value of object\n            this\n\n## Unique IDs for instances\n\nClients of this class may give instances of it unique IDs stored in\nattributes.  (See the corresponding convenience function for querying such\nIDs in the [Attribute Conventions section](#attribute-conventions).)  To\ntrack those IDs, we use a class variable defined here, and provide class\nmethods for tracking and untracking IDs in a structure hierarchy.  IDs can\nbe any string, and thus we track them in an object, using the strings as\nkeys.\n\n        IDs : { }\n        @instanceWithID : ( id ) -> Structure::IDs[id]\n\nThe following two functions recur through a given structure hierarchy and\nsave all of its IDs into (or delete all of its IDs from) the above class\nvariable.  Whenever a structure hierarchy is no longer used by the client,\n`untrackIDs` should be called on that hierarchy to prevent memory leaks.\n\nBecause connections depend on IDs, we will also disconnect in `untrackIDs()`\nany connections involving this structure.  Similarly, in `trackIDs()`, we\nmust notice any connections that exist in the structure and store them in\nthe appropriate global data structures; connection IDs are a close kin to\n`Structure` IDs.\n\n        id : -> @getAttribute 'id'\n        trackIDs : ( recursive = yes ) ->\n            @noticeAllConnections()\n            if @id()? then Structure::IDs[@id()] = @\n            if recursive then child.trackIDs() for child in @children()\n        untrackIDs : ( recursive = yes ) ->\n            @removeAllConnections()\n            if @id()? then delete Structure::IDs[@id()]\n            if recursive then child.untrackIDs() for child in @children()\n\nThe following function removes all ID attributes from a structure hierarchy.\nThis is useful, for example, after making a deep copy of a structure, so\nthat the copied version does not violate the global uniqueness of IDs.\n\nBecause connections depend on IDs, we will also disconnect here any\nconnections involving this structure.\n\n        clearIDs : ( recursive = yes ) ->\n            @removeAllConnections()\n            @clearAttributes 'id'\n            if recursive then child.clearIDs() for child in @children()\n\n## Connections\n\nStructures may have connections among them, specified using attributes.  The\ndocumentation\n[here](https://lurchmath.github.io/lde/site/phase0-structures/#connections)\ncovers the concept in detail.  We begin by providing a similar global store\nfor unique IDs of connections, like we do for instances.\n\nThe following class member will map unique connection IDs to the source\nStructure for the connection.  Thus we provide the accompanying function for\nquerying that mapping.\n\n        connectionIDs : { }\n        @sourceOfConnection : ( id ) -> Structure::connectionIDs[id]\n\nWe then define, in some class methods, the protocol for creating and\nbreaking connections.  We will then provide some instance methods for\naccessing these class methods more conveniently.\n\n### Making consistent connections\n\nForming a connection takes as input a source structure, a target structure,\nand a JSON data object describing the connection.  It may have any data it\nlikes in it, but the one requirement is that its `id` field is unique (that\nis, not yet mentioned in the `connectionIDs` member defined above).  This\nmethod also requires the source and target to both have IDs.\n\nIt writes data into the source, the target, and the `connectionIDs` object,\nrecording the connection.  It returns true if it was able to create the\nconnection, and false otherwise.  If it returns true, then just before\nreturning, it calls teh `connectionInserted` handlers in both the source and\nthe target (iff they are present), passing the new connection's ID in each\ncase.\n\n        @connect : ( source, target, data ) ->\n            return no unless \\\n                ( data instanceof Object ) and \\\n                ( data.hasOwnProperty 'id' ) and \\\n                ( not Structure::connectionIDs.hasOwnProperty data.id ) and\\\n                ( source instanceof Structure ) and source.id()? and \\\n                ( target instanceof Structure ) and target.id()?\n            source.connectionWillBeInserted? data.id\n            target.connectionWillBeInserted? data.id\n            source.setAttribute \"_conn #{data.id} data\", data\n            source.setAttribute \"_conn #{data.id} to\", target.id()\n            target.setAttribute \"_conn #{data.id} from\", source.id()\n            Structure::connectionIDs[data.id] = source\n            source.connectionWasInserted? data.id\n            target.connectionWasInserted? data.id\n            yes\n\nThe convenience function for accessing this from instances should be called\nfrom the source of the connection.\n\n        connectTo : ( target, data ) -> Structure.connect @, target, data\n\nThe following query functions simply make use of the data storage protocol\nestablished by the above function.  For each one, we provide a class method\n(to be consistent with connection creation, and so that connections can be\nqueried even without a particular instance being known) and an instance\nmethod as well, which just redirects the call to the class method, as a\nconvenience.\n\nFirst, functions that find the source, target, or data of a connection,\ngiven its unique ID.  The first one is not strictly necessary, but we\nprovide it for the sake of symmetry.\n\n        @getConnectionSource : ( connectionID ) ->\n            Structure.sourceOfConnection connectionID\n        @getConnectionTarget : ( connectionID ) ->\n            return undefined unless \\\n                ( source = Structure.sourceOfConnection connectionID ) and \\\n                targetID = source.getAttribute \"_conn #{connectionID} to\"\n            Structure.instanceWithID targetID\n        @getConnectionData : ( connectionID ) ->\n            return undefined unless \\\n                source = Structure.sourceOfConnection connectionID\n            source.getAttribute \"_conn #{connectionID} data\"\n        getConnectionSource : ( connectionID ) ->\n            Structure.getConnectionSource connectionID\n        getConnectionTarget : ( connectionID ) ->\n            Structure.getConnectionTarget connectionID\n        getConnectionData : ( connectionID ) ->\n            Structure.getConnectionData connectionID\n\nSecond, functions that can find the list of IDs associated with a given\nStructure instance, either as outgoing connections, incoming connections, or\nboth.\n\n        getConnectionsIn : ->\n            result = [ ]\n            for own key of @attributes\n                if key[...6] is '_conn ' and key[-5...] is ' from'\n                    result.push key[6...-5]\n            result.sort()\n            result\n        getConnectionsOut : ->\n            result = [ ]\n            for own key of @attributes\n                if key[...6] is '_conn ' and key[-3...] is ' to'\n                    result.push key[6...-3]\n            result.sort()\n            result\n        getAllConnections : ->\n            result = @getConnectionsIn()\n            for out in @getConnectionsOut()\n                if out not in result then result.push out\n            result.sort()\n            result\n\nBreaking a connection takes as input the unique ID for the connection, and\nit can then look up all the other relevant data in the `connectionIDs` class\nvariable.  If the ID is not in that object, this function does nothing.\n\nIt will alter both the source and the target, as well as the `connectionIDs`\nstructure.  It will call the `connectionRemoved` event handler in both the\nsource and the target if it succeeds.  It returns true on success and false\non failure.\n\n        @disconnect : ( connectionID ) ->\n            return no unless \\\n                ( source = Structure::connectionIDs[connectionID] ) and \\\n                ( targetID = source.getAttribute \\\n                    \"_conn #{connectionID} to\" ) and \\\n                ( target = Structure.instanceWithID targetID ) and \\\n                ( data = source.getAttribute \"_conn #{connectionID} data\" )\n            source.connectionWillBeRemoved? connectionID\n            target.connectionWillBeRemoved? connectionID\n            source.clearAttributes \"_conn #{connectionID} data\",\n                \"_conn #{connectionID} to\"\n            target.clearAttributes \"_conn #{connectionID} from\"\n            delete Structure::connectionIDs[connectionID]\n            source.connectionWasRemoved? connectionID\n            target.connectionWasRemoved? connectionID\n            yes\n\nThe convenience function for accessing this from instances can be called\nfrom any instance, because it needs the connection's ID.\n\n        disconnect : ( connectionID ) -> Structure.disconnect connectionID\n\nWe also permit clients to update the data for a connection that has already\nbeen made, using the following function.  They must provide the ID for the\nconnection and a key-valuep pair to update in the existing connection data.\nIf `value` is undefined, then any key-value pair associated with the given\nkey will be removed from the connection data.\n\n        @setConnectionData : ( connectionID, key, value ) ->\n            return no unless \\\n                ( key isnt 'id' ) and \\\n                ( source = Structure::connectionIDs[connectionID] ) and \\\n                ( targetID = source.getAttribute \\\n                    \"_conn #{connectionID} to\" ) and \\\n                ( target = Structure.instanceWithID targetID ) and \\\n                ( data = source.getAttribute \"_conn #{connectionID} data\" )\n            source.connectionWillBeChanged? connectionID\n            target.connectionWillBeChanged? connectionID\n            if typeof value is 'undefined'\n                delete data[key]\n            else\n                data[key] = value\n            source.connectionWasChanged? connectionID\n            target.connectionWasChanged? connectionID\n            yes\n\nThe convenience function for accessing this from instances can be called\nfrom any instance, because it needs the connection's ID.\n\n        setConnectionData : ( connectionID, key, value ) ->\n            Structure.setConnectionData connectionID, key, value\n\nWe also define the following function for removing all connections into or\nout of this structure, which is used by `untrackIDs()` and `clearIDs()`,\ndefined earlier.\n\n        removeAllConnections : ->\n            Structure.disconnect id for id in @getAllConnections()\n            child.removeAllConnections() for child in @children()\n\nA sort of inverse of the previous function is to find all connections that\nexist in the attributes of a `Structure` hierarchy and import them into the\nclass-level data structures that should store them.  This is useful if a\ntree has been removed and then moved to a new location.  When it was\nremoved, its connections were removed from `connectionIDs`; when it is\nre-inserted, they need to be re-added.\n\nThis presumes that the source node already has the `\"_conn #{id} to\"` and\n`\"_conn #{id} data\"` attributes and the target already has the\n`\"_conn #{id} from\"` attribute, and that both ends of each connection are\nregistered in `Structure::IDs`.\n\nIf this succeeds (because all the IDs that would need to be added to\n`connectionIDs` were not there, and thus could be added fresh) it returns\ntrue.  If any of the additions failed because the ID in question was already\nin `connectionIDs`, it returns false (and does not overwrite).  Even if it\nreturns false, it still adds all those that it can.\n\n        noticeAllConnections : ->\n            success = yes\n            for id in @getConnectionsOut()\n                if Structure::connectionIDs.hasOwnProperty id\n                    success = no\n                else\n                    Structure::connectionIDs[id] = @\n            # connections in will be handled at the source node\n            for child in @children\n                if not child.noticeAllConnections()\n                    success = no\n            success\n\nWhen replacing one node in a `Structure` hierarchy with another, sometimes\nit is convenient to transfer all connections into or out of the original\nover to the replacement.  We therefore provide the following function that\ndoes this work for you, to make it easier.  If the given `Structure` does\nnot have an ID, this does nothing.  It returns false on failure, true on\nsuccess.\n\n        transferConnectionsTo : ( recipient ) ->\n            return no unless recipient.id()?\n            for id in @getAllConnections()\n                if ( targetID = @getAttribute( \"_conn #{id} to\" ) ) and \\\n                   target = Structure.instanceWithID targetID\n                    @clearAttributes \"_conn #{id} to\"\n                    recipient.setAttribute \"_conn #{id} to\", targetID\n                    target.setAttribute \"_conn #{id} from\", recipient.id()\n                    data = @getAttribute \"_conn #{id} data\"\n                    @clearAttributes \"_conn #{id} data\"\n                    recipient.setAttribute \"_conn #{id} data\", data\n                if ( sourceID = @getAttribute( \"_conn #{id} from\" ) ) and \\\n                   source = Structure.instanceWithID sourceID\n                    @clearAttributes \"_conn #{id} from\"\n                    recipient.setAttribute \"_conn #{id} from\", sourceID\n                    source.setAttribute \"_conn #{id} to\", recipient.id()\n            yes\n\n## Accessibility\n\nA structure A is accessible to a structure B if they have a common ancestor\nand are positioned within that ancestor in such a way that B could cite A as\na premise.\n\nThe officially definition is that a structure is accessible to all of its\nprevious siblings, all the previous siblings of its parent, all the previous\nsiblings of its grandparent, and so on up the ancestor chain.  Note that a\nstructure is not accessible to itself, nor to any of its ancestors.\nConversely, if A is accessible to B, then we say that B is in the scope of\nA.\n\n### Foundational accessibility functions\n\nWe begin with two functions, implementing the accessibility/scope relations.\n\n        isAccessibleTo : ( other ) ->\n            if other not instanceof Structure then return no\n            if not other.parent()? then return no\n            if @parent() is other.parent()\n                @indexInParent() < other.indexInParent()\n            else\n                @isAccessibleTo other.parent()\n        isInTheScopeOf : ( other ) -> other.isAccessibleTo this\n\nFor all the other computations we will want to do with scopes and\naccessibility, we will need iterators over all structures accessible to (or\nin the scope of, respectively) this one.  An iterator for a set S is an\nobject `I` such that repeated calls to `I.next()` yield new elements of S\nuntil S is exhausted, at which point all future calls to `I.next()` return\nnull.\n\nThe first iterator function lists all structures accessible to this one, in\nreverse order in the hierarchy.  That is, all previous siblings are yielded\nfrom right to left, then all previous siblings of the parent, and so on.\n\n        iteratorOverAccessibles : ->\n            ancestor : this\n            sibling : this\n            next : ->\n                if not @ancestor? then return null\n                if ( @sibling = @sibling.previousSibling() )?\n                    return @sibling\n                @sibling = @ancestor = @ancestor.parent()\n                @next()\n\nThe second iterator function lists all structures in the scope of this one,\nin forward order in the hierarchy.  That is, all descendants of the next\nsibling are yielded, then all descendants of the subsequent sibling, and so\non, in the order of a postorder tree traversal.\n\n        iteratorOverScope : ->\n            chain : [ this ]\n            next : ->\n                if @chain.length is 0 then return null\n                last = @chain.pop()\n                if ( walk = last.nextSibling() )?\n                    @chain.push walk\n                    @chain.push walk while ( walk = walk.children()[0] )?\n                    @chain[@chain.length-1]\n                else if @chain.length > 0\n                    @chain[@chain.length-1]\n                else\n                    null\n\n### Accessibility convenience functions\n\nWe then create two functions that can use these iterators for searching or\nenumeration.  Call `first(iterator,predicate)` to get the first element the\niterator yields satisfying the predicate.  Call `all(iterator,prediacte)`\nwith the obvious related meaning.  In each case, the predicate can be\nomitted to get the first element or all elements (no restrictions).  If the\npredicate is never satisfied, `first` returns undefiend, and `all` returns\nan empty array.\n\n        first = ( iterator, predicate = -> yes ) ->\n            while ( next = iterator.next() )?\n                if predicate next then return next\n        all = ( iterator, predicate = -> yes ) ->\n            result = [ ]\n            while ( next = iterator.next() )?\n                if predicate next then result.push next\n            result\n\nWe can then write useful functions whose names give their obvious meanings,\nby combining the tools above.\n\n        firstAccessible : ( predicate = -> yes ) ->\n            first @iteratorOverAccessibles(), predicate\n        allAccessibles : ( predicate = -> yes ) ->\n            all @iteratorOverAccessibles(), predicate\n        firstInScope : ( predicate = -> yes ) ->\n            first @iteratorOverScope(), predicate\n        allInScope : ( predicate = -> yes ) ->\n            all @iteratorOverScope(), predicate\n\n## Feedback\n\nWe create a stub function here for passing feedback to the LDE client.  In\nthis module, it does nothing but report to the console that it is not yet\nimplemented.  When the LDE module imports this one, it will overwrite this\nwith a real implementation that connects into the LDE's feedback mechanisms.\n\nThe intent is to pass a single feedback JSON structure that would be passed\nto the client.\n\n        @feedback : ( feedbackData ) ->\n            console.log 'Structure class feedback not implemented:',\n                feedbackData\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports? then exports.Structure = Structure\n"]}