{"version":3,"sources":["structure.litcoffee"],"names":["Structure","slice","exports","child","children","j","len","arguments","length","call","this","computedAttributes","externalAttributes","parentNode","childList","insertChild","all","allConnectedTo","first","stringArrayAttributes","uniqueArray","IDs","instanceWithID","id","prototype","nextUnusedID","result","indexOf","getID","ID","releaseID","results","pop","subclasses","addSubclass","name","classObj","className","toJSON","ref","fromJSON","json","func","args","ctor","JSON","parse","stringify","parent","indexInParent","ref1","previousSibling","index","nextSibling","removeFromParent","originalIndex","originalParent","splice","wasRemoved","removeChild","atIndex","beforeIndex","walk","concat","wasInserted","replaceWith","other","copy","C","S","isEarlierThan","ancestorsOfOther","commonAncestorIndex","myAncestorIndex","nextAncestor","otherAncestorIndex","otherRelevantAncestor","relevantAncestor","unshift","getComputedAttribute","key","setComputedAttribute","value","wasChanged","clearComputedAttributes","keys","Object","compute","arg","params","Array","apply","getExternalAttribute","setExternalAttribute","clearExternalAttributes","attr","object","setup","recurConnect","recurFindTargets","recurGetID","targets","node","k","len1","target","hasOwnProperty","connectTo","fillOutConnections","T","arrayToObject","count","ins","moreData","name1","name2","objectToArray","outs","ref2","ref3","ref4","ref5","ref6","source","sourceOuts","targetIns","type","push","Number","array","base","connection","Math","max","otherStructure","connectionType","disconnectFrom","inIndex","outIndex","allConnectionsOut","ofThisType","conn","allConnectionsIn","allConnectionsTo","properties","isAccessibleTo","isInTheScopeOf","iteratorOverAccessibles","ancestor","sibling","next","iteratorOverScope","chain","last","iterator","predicate","firstAccessible","allAccessibles","firstInScope","allInScope","text","isAReference","structure","computed","external","item","labels","label","hasLabel","reasons","premises","lookup","cites","citations","toLookUp","whatCitesMe","_this"],"mappings":"AAOI,IAAAA,UAAAC,SAAAA,+IAAAC,QAAQF,UAAkBA,UAAA,WA+CR,SAAAA,IACV,IAAAG,EAAAC,EAAAC,EAAAC,EAIA,IALYF,EAAA,GAAAG,UAAAC,OAAAP,MAAAQ,KAAAF,UAAA,MACZG,KAACC,sBACDD,KAACE,sBACDF,KAACG,WAAa,KACdH,KAACI,aACDT,EAAA,EAAAC,EAAAF,EAAAI,OAAAH,EAAAC,EAAAD,WACIK,KAACK,YAAYZ,EAAOO,KAACI,UAAUN,QAvCvC,IAAAQ,EAAAC,EAAAC,EAAAC,EAAAC,qBAAAC,OACArB,EAACsB,eAAiB,SAAEC,UAAQvB,EAASwB,UAAEH,IAAIE,IAC3CvB,EAACyB,aAAe,WACZ,IAAAC,EACA,OADAA,EAAS1B,EAASwB,UAAEH,IAAIM,QAAQ,QACnB,EAAOD,EAAY1B,EAASwB,UAAEH,IAAIb,oBAWnDoB,MAAQ,WACJ,GAAU,MAAAlB,KAAAmB,UACVnB,KAACmB,GAAK7B,EAAUyB,eAChBzB,EAASwB,UAAEH,IAAIX,KAACmB,IAAMnB,kBAC1BoB,UAAY,WACR,IAAAC,EAAA,GAAG,MAAArB,KAAAmB,GAAH,KACI7B,EAASwB,UAAEH,IAAIX,KAACmB,IAAM,YACfnB,KAACmB,GACRE,KAAiD,OAA3C/B,EAASwB,UAAEH,IAAIrB,EAASwB,UAAEH,IAAIb,OAAO,WACvCR,EAASwB,UAAEH,IAAIW,8BAuC3BC,cACAjC,EAACkC,YAAc,SAAEC,EAAMC,UACnBpC,EAASwB,UAAES,WAAWE,GAAQC,EAC9BD,eAOJE,UAAYrC,EAAUkC,YAAY,YAAalC,eAU/CsC,OAAS,WACL,IAAAnC,SAAAkC,UAAY3B,KAAC2B,UACb1B,mBAAqBD,KAACC,mBACtBC,mBAAqBF,KAACE,mBACtBR,SAAA,2BAAa2B,KAAA1B,EAAA,EAAAC,GAAAiC,EAAA7B,KAAAI,WAAAN,OAAAH,EAAAC,EAAAD,kBAAAF,EAAMmC,iCAYvBtC,EAACwC,SAAW,SAAEC,GACV,IAAAtC,EAAAC,EAAAgC,EAAAV,SAAAU,EAAWpC,EAASwB,UAAES,WAAWQ,EAAKJ,WACtCjC,EAAA,2BACM2B,KAAA1B,EAAA,EAAAC,GAAAiC,EAAAE,EAAArC,UAAAI,OAAAH,EAAAC,EAAAD,kBAAAL,EAAUwC,SAASrC,aADzB,GAEAuB,EAAS,SAAAgB,EAAAC,EAAAC,+EAAA,CAAIR,EAAShC,EAAb,cACTsB,EAAOf,mBACHkC,KAAKC,MAAMD,KAAKE,UAAUN,EAAK9B,qBACnCe,EAAOd,mBACHiC,KAAKC,MAAMD,KAAKE,UAAUN,EAAK7B,qBACnCc,eAWJsB,OAAS,kBAAGtC,KAACG,wBACbT,SAAW,kBAAGM,KAACI,UAAUb,MAAA,gBACzBgD,cAAgB,WAAG,IAAAV,EAAAW,4DAAwBvB,QAAQjB,WAAhC,eACnByC,gBAAkB,WACd,IAAAC,EAAA,GAAG,OAAAA,EAAA1C,KAAAuC,wBACCvC,KAACG,WAAWC,UAAUsC,EAAM,gBACpCC,YAAc,WACV,IAAAD,EAAA,GAAG,OAAAA,EAAA1C,KAAAuC,wBACCvC,KAACG,WAAWC,UAAUsC,EAAM,gBASpCE,iBAAmB,WACf,IAAAC,EAAAC,EAAA,GAAG,OAAAA,EAAA9C,KAAAG,mBACC0C,EAAgB7C,KAACuC,gBACjBvC,KAACG,WAAWC,UAAU2C,OAAOF,EAAe,GAC5C7C,KAACG,WAAa,wCACdH,KAACgD,WAAYF,EAAgBD,QAAA,eACrCI,YAAc,SAAEC,GAAa,IAAArB,uCAAqBe,wBAArB,eAa7BvC,YAAc,SAAEZ,EAAO0D,GACnB,IAAAC,EAAA,aADmBD,EAAc,GACnB1D,aAAiBH,GAC3BG,IAAWO,MACX,GAAKmD,GAAAA,GAAenD,KAACI,UAAUN,OAFnC,CAIA,IADAsD,EAAOpD,KACD,OAAAoD,EAAAA,EAAAd,WACF,GAAGc,IAAQ3D,EAAX,CACIO,KAAC4C,mBACD,aACRnD,EAAMmD,mBACN5C,KAACI,UACGb,MAAAQ,KAAAC,KAACI,UAAUb,MAAA,EAAA4D,IAAXE,QACA5D,GACAF,MAAAQ,KAAAC,KAACI,UAAUb,MAAA4D,KAEf1D,EAAMU,WAAaH,sCACnBP,EAAM6D,mBAAA,gBAMVC,YAAc,SAAEC,GACZ,IAAAX,EAAAC,EAAA,GAAG,OAAAA,EAAA9C,KAAAG,mBACC0C,EAAgB7C,KAACuC,gBACjBvC,KAAC4C,mBACDE,EAAezC,YAAYmD,EAAOX,gBAK1CY,KAAO,WACH,IAAAC,EAAAC,SAAAA,EAAI,IAAIrE,EACRqE,EAAE1D,mBACEkC,KAAKC,MAAMD,KAAKE,UAAUrC,KAACC,qBAC/B0D,EAAEzD,mBACEiC,KAAKC,MAAMD,KAAKE,UAAUrC,KAACE,qBAC/ByD,EAAEvD,UAAF,2BAAgBiB,KAAA1B,EAAA,EAAAC,GAAAiC,EAAA7B,KAAAI,WAAAN,OAAAH,EAAAC,EAAAD,kBAAA+D,EAAED,6BAClBE,eAMJC,cAAgB,SAAEJ,GACd,IAAAK,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAf,EAAA,GAAGI,aAAqBlE,EAAxB,CACA,GAAGkE,IAASxD,KAAU,OAAO,EAM7B,IADA6D,GAAqBL,GACf,OAAAQ,EAAAH,EAAA,GAAAvB,WACFuB,EAAiBO,QAAQJ,GAM7B,IAFAZ,EAAOpD,KACPmE,EAAmB,KACb,MAAAf,GAAUnC,QAAAlB,KAAY8D,EAAZT,GAAA,GACZe,EAAmBf,EACnBA,EAAOA,EAAKd,SAOhB,GAAO,MAAAc,EACP,OAAGA,IAAQpD,MACRoD,IAAQI,IAIXM,EAAsBD,EAAiB5C,QAAQmC,GAC/Cc,EAAwBL,EAAiBC,EAAoB,GAC7DC,EAAkBI,EAAiB5B,gBACnC0B,EAAqBC,EAAsB3B,gBAC3CwB,EAAkBE,iBAmBtBI,qBAAuB,SAAEC,UAAStE,KAACC,mBAAmBqE,gBACtDC,qBAAuB,SAAED,EAAKE,GAC1B,GAAGxE,KAACC,mBAAmBqE,KAAUE,SAC7BxE,KAACC,mBAAmBqE,GAAOE,qCAC3BxE,KAACyE,kBAAA,eACTC,wBAA0B,WACtB,IAAA/E,EAAA2E,EAAAK,EAAA/E,EAAAyB,MAAkB,KADMsD,EAAA,GAAA9E,UAAAC,OAAAP,MAAAQ,KAAAF,UAAA,OAChBC,SAAiB6E,EAAOC,OAAOD,KAAK3E,KAACC,qBAC7CoB,KAAA1B,EAAA,EAAAC,EAAA+E,EAAA7E,OAAAH,EAAAC,EAAAD,eACcK,KAACC,2BACAD,KAACC,mBAAmBqE,6CAC3BtE,KAACyE,kBAAA,yCAgBbI,QAAU,WACN,IAAAC,EAAA7C,EAAAD,EAAArC,EAAAC,EAAAmF,EAAA1D,MAAAA,KAAA1B,EAAA,EAAAC,GADQqC,EAAA,GAAApC,UAAAC,OAAAP,MAAAQ,KAAAF,UAAA,OACRC,OAAAH,EAAAC,EAAAD,uBAC0BqF,QAAWF,GAAQA,IACvC9C,EAAA8C,EAAA,GAAMC,EAAA,GAAAD,EAAAhF,OAAAP,MAAAQ,KAAA+E,EAAA,aACR9E,KAACuE,qBAAqBvC,EAAMhC,KAAEgC,GAAFiD,MAAAjF,KAAQ+E,2BAW5CG,qBAAuB,SAAEZ,UAAStE,KAACE,mBAAmBoE,gBACtDa,qBAAuB,SAAEb,EAAKE,GAC1B,GAAGxE,KAACE,mBAAmBoE,KAAUE,SAC7BxE,KAACE,mBAAmBoE,GAAOE,qCAC3BxE,KAACyE,kBAAA,eACTW,wBAA0B,WACtB,IAAAzF,EAAA2E,EAAAK,EAAA/E,EAAAyB,MAAkB,KADMsD,EAAA,GAAA9E,UAAAC,OAAAP,MAAAQ,KAAAF,UAAA,OAChBC,SAAiB6E,EAAOC,OAAOD,KAAK3E,KAACE,qBAC7CmB,KAAA1B,EAAA,EAAAC,EAAA+E,EAAA7E,OAAAH,EAAAC,EAAAD,eACcK,KAACE,2BACAF,KAACE,mBAAmBoE,6CAC3BtE,KAACyE,kBAAA,yCAQbY,KAAO,SAAEC,GACL,IAAAhB,EAAAE,EAAA,IAAAF,KAAAgB,6BAAAtF,KAACmF,qBAAqBb,EAAKE,WAC3BxE,kBAUJuF,MAAQ,WAIJ,IAAAC,EAAAC,EAAAC,EAAAC,SAAAD,EAAa,SAAEE,GACX,IAAAnG,EAAAE,EAAAC,EAAAiC,EAAAR,MAAAuE,EAAK1E,QACLG,KAAA1B,EAAA,EAAAC,GAAAiC,EAAA+D,EAAAlG,YAAAI,OAAAH,EAAAC,EAAAD,kBAAA+F,EAAWjG,eACJO,MAYX2F,MACAF,EAAmB,SAAEG,GACjB,IAAAnG,EAAAoB,EAAAlB,EAAAC,EAAAiC,EAAAR,MAAG,OAAAR,EAAA+E,EAAAV,qBAAA,SACCS,EAAQ9E,GAAM+E,EACdA,EAAKR,wBAAwB,OACjC/D,KAAA1B,EAAA,EAAAC,GAAAiC,EAAA+D,EAAAlG,YAAAI,OAAAH,EAAAC,EAAAD,kBAAA8F,EAAiBhG,eACJO,OACjBwF,EAAe,SAAEI,GACb,IAAAP,EAAA5F,EAAAE,EAAAkG,EAAAjG,EAAAkG,EAAAjE,EAAAW,EAAAnB,EAAA0E,EAAAvB,EAAA,IAAA7E,EAAA,EAAAC,GAAAiC,GAAA,QAAA,UAAA,WAAA/B,OAAAH,EAAAC,EAAAD,WACO,OAAA6E,EAAAoB,EAAAV,qBAAAG,EAAA,WASI,OAPCU,EADQ,aAATvB,EACUoB,EAAKnD,kBACD,SAAT+B,EACKoB,EAAKjD,cACVgD,EAAQK,eAAexB,GAClBmB,EAAQnB,GAER,OACGoB,EAAKK,UAAUF,EAAQV,GACvCO,EAAKR,wBAA2BC,EAAK,aAC7ChE,KAAAwE,EAAA,EAAAC,GAAAtD,EAAAoD,EAAAlG,YAAAI,OAAA+F,EAAAC,EAAAD,kBAAAL,EAAa/F,eACJO,MAKbA,KAACkG,qBACDlG,kBAqBJkG,mBAAqB,WAIjB,IAAAvC,EAAAwC,EAAAC,EAAAC,EAAAC,EAAA3G,EAAAC,EAAA2G,EAAAC,EAAAC,EAAAC,EAAAC,EAAA9E,EAAAW,EAAAoE,EAAAC,EAAAC,EAAAC,EAAAC,EAAA3F,EAAA4F,EAAAC,EAAAnB,EAAAoB,EAAAC,EAAA,IAAAzH,EAAA,EAAAC,GAAAiC,EAAA7B,KAAAI,WAAAN,OAAAH,EAAAC,EAAAD,SAAMuG,qBACN,GAAO,MAAAlG,KAAAmB,GAAP,CAqBAuF,EAAgB,SAAEpB,GACd,IAAAO,EAAAU,EAAA/D,EAAAxB,EAAA+E,EAAAqB,EAAApG,KACA,IAAA+E,KAAAT,+BACI,IAAA8B,KAAAb,uBACI,IAASV,EAAA,EAAArD,OAAA,GAAAA,EAAAqD,GAAArD,EAAAqD,GAAArD,EAAA,GAAAA,IAAAqD,IAAAA,EACL7E,EAAOqG,MAAOC,OAAQvB,GAAUqB,WAC5CpG,GAKJ2F,GAnBAP,EAAgB,SAAEmB,GACd,IAAAC,EAAAC,EAAA5B,EAAAC,EAAA9E,EAAA+E,EAAAqB,EACA,IADApG,KACA6E,EAAA,EAAAC,EAAAyB,EAAAzH,OAAA+F,EAAAC,EAAAD,IACME,WAAA,GAAQqB,EAAAK,EAAA,gBACVzG,EAAO+E,6BACQqB,GAAS,GACxBpG,EAAO+E,GAAQqB,YACnBpG,IAYG,OAAAwB,EAAAxC,KAAAkF,qBAAA,mBAAA1C,MAEP,IAAAuD,KAAAY,gCACoB,OAAAR,EAAA7G,EAAAsB,eAAAmF,KAAhB,QACAoB,EAAYf,EAAA,OAAAQ,EAAAT,EAAAjB,qBAAA,kBAAA0B,oBAEZO,EAAAX,OACA,IAAAY,KAAAb,6BACIA,EAASa,GAAQD,EAAUnH,KAACmB,IAAIiG,GAC5BM,KAAKC,IAAItB,EAAT,OAAAQ,EAAAM,EAAAnH,KAAAmB,IAAAiG,IAAAP,EAAuC,IAC/CV,EAAEhB,qBAAqB,gBACnBuB,EAAcS,IAItBb,EAAMF,EAAA,OAAAU,EAAA9G,KAAAkF,qBAAA,kBAAA4B,MAENzF,SAAA4F,KAAAX,gCACoB,OAAA3C,EAAArE,EAAAsB,eAAAqG,KAAhB,QACAC,EAAad,EAAA,OAAAW,EAAApD,EAAAuB,qBAAA,mBAAA6B,oBAEbG,EAAAT,OACA,IAAAW,KAAAb,6BACIA,EAASa,GAAQF,EAAWlH,KAACmB,IAAIiG,GAC7BM,KAAKC,IAAItB,EAAT,OAAAW,EAAAE,EAAAlH,KAAAmB,IAAAiG,IAAAJ,EAAwC,WAChDrD,EAAEwB,qBAAqB,iBACnBuB,EAAcQ,4BAuB1BjB,UAAY,SAAE2B,EAAgBC,GAC1B,IAAAvB,EAAAK,EAAA9E,EAAAW,EAAA,OAAiB,MAAAxC,KAAAmB,IACbyG,aAA0BtI,GAAc,MAAAsI,EAAAzG,KAC5CwF,EAAA,OAAA9E,EAAA7B,KAAAkF,qBAAA,mBAAArD,KACAyE,EAAA,OAAA9D,EAAAoF,EAAA1C,qBAAA,kBAAA1C,KAEAmE,EAAKU,MAAOO,EAAezG,GAAI0G,IAC/BvB,EAAIe,MAAOrH,KAACmB,GAAI0G,IAChB7H,KAACmF,qBAAqB,iBAAkBwB,GACxCiB,EAAezC,qBAAqB,gBAAiBmB,IACrD,gBAIJwB,eAAiB,SAAEF,EAAgBC,GAC/B,IAAAE,EAAAzB,EAAA0B,EAAArB,EAAA9E,EAAAW,EAAA,KAAiB,MAAAxC,KAAAmB,IACbyG,aAA0BtI,GAAc,MAAAsI,EAAAzG,IAD5C,OAAO,EAMP,IAJAwF,EAAA,OAAA9E,EAAA7B,KAAAkF,qBAAA,mBAAArD,KACAyE,EAAA,OAAA9D,EAAAoF,EAAA1C,qBAAA,kBAAA1C,KAEAwF,EAAWD,EAAU,EACfC,EAAWrB,EAAK7G,SACd6G,EAAKqB,GAAU,KAAQJ,EAAezG,IACtCwF,EAAKqB,GAAU,KAAQH,IAC3BG,IACJ,GAAGA,IAAYrB,EAAK7G,OAAY,OAAO,EACvC,KAAMiI,EAAUzB,EAAIxG,SACZwG,EAAIyB,GAAS,KAAQ/H,KAACmB,IACtBmF,EAAIyB,GAAS,KAAQF,IACzBE,IACJ,OAAGA,IAAWzB,EAAIxG,SAClB6G,EAAK5D,OAAOiF,EAAU,GACtB1B,EAAIvD,OAAOgF,EAAS,GACpB/H,KAACmF,qBAAqB,iBAAkBwB,GACxCiB,EAAezC,qBAAqB,gBAAiBmB,IACrD,gBAaJ2B,kBAAoB,SAAEC,GAClB,IAAAC,EAAAxI,EAAAC,EAAA+G,EAAA9E,EAAAR,EACA,GADAsF,EAAA,OAAA9E,EAAA7B,KAAAkF,qBAAA,mBAAArD,KACO,MAAAqG,EAAiB,OAAOvB,MAC7BtF,KAAA1B,EAAA,EAAAC,EAAA+G,EAAA7G,OAAAH,EAAAC,EAAAD,aAAmC,KAAMuI,UAAzCC,EAAK,0BAIXC,iBAAmB,SAAEF,GACjB,IAAAC,EAAA7B,EAAA3G,EAAAC,EAAAiC,EAAAR,EACA,GADAiF,EAAA,OAAAzE,EAAA7B,KAAAkF,qBAAA,kBAAArD,KACO,MAAAqG,EAAiB,OAAO5B,MAC7BjF,KAAA1B,EAAA,EAAAC,EAAA0G,EAAAxG,OAAAH,EAAAC,EAAAD,aAAkC,KAAMuI,UAAxCC,EAAK,0BAOXE,iBAAmB,SAAET,GACjB,IAAAO,EAAAxI,EAAAC,EAAA+G,EAAA9E,EAAAR,EAAA,KAAmBuG,aAA0BtI,GACzC,MAAAsI,EAAAzG,IADJ,OAAO,SAGLE,KAAA1B,EAAA,EAAAC,GADF+G,EAAA,OAAA9E,EAAA7B,KAAAkF,qBAAA,mBAAArD,MACE/B,OAAAH,EAAAC,EAAAD,aAAmC,KAAMiI,EAAezG,WAAxDgH,EAAK,0BAQXG,WAAa,WACT,IAAAH,EAAAxI,EAAAC,EAAA4G,EAAA3E,EAAAW,EAAAxB,EAAAiG,EACA,IADAjG,KACArB,EAAA,EAAAC,GAAA4C,EAAA,OAAAX,EAAA7B,KAAAkF,qBAAA,kBAAArD,MAAA/B,OAAAH,EAAAC,EAAAD,WACO,OAAAsH,EAAA3H,EAAAsB,eAAAuH,EAAA,OACC,MAAAnH,EAAAwF,EAAA2B,EAAA,IAAEnH,EAAAwF,GAAAxF,EAAAwF,OAAyBa,KAAKJ,UACxCjG,eAmBJuH,eAAiB,SAAE/E,GACf,OAAGA,aAAqBlE,IACjB,MAAAkE,EAAAlB,WACJtC,KAACsC,WAAYkB,EAAMlB,SAClBtC,KAACuC,gBAAkBiB,EAAMjB,gBAEzBvC,KAACuI,eAAe/E,EAAMlB,yBAC9BkG,eAAiB,SAAEhF,UAAWA,EAAM+E,eAAevI,mBAanDyI,wBAA0B,kBACtBC,SAAW1I,KACX2I,QAAU3I,KACV4I,KAAO,WACH,OAAO,MAAA5I,KAAA0I,SAAuB,KAC3B,OAAA1I,KAAA2I,QAAA3I,KAAA2I,QAAAlG,mBACQzC,KAAC2I,SACZ3I,KAAC2I,QAAU3I,KAAC0I,SAAW1I,KAAC0I,SAASpG,SACjCtC,KAAC4I,uBAOTC,kBAAoB,kBAChBC,OAAU9I,MACV4I,KAAO,WACH,IAAAG,EAAA3F,EAAA,GAAoB,IAAjBpD,KAAC8I,MAAMhJ,OAAiB,OAAO,KAElC,GADAiJ,EAAO/I,KAAC8I,MAAMxH,MACX,OAAA8B,EAAA2F,EAAApG,eAAH,CAEqB,IADjB3C,KAAC8I,MAAMzB,KAAKjE,GACW,OAAAA,EAAAA,EAAA1D,WAAA,KAAvBM,KAAC8I,MAAMzB,KAAKjE,UACZpD,KAAC8I,MAAM9I,KAAC8I,MAAMhJ,OAAO,GACpB,OAAGE,KAAC8I,MAAMhJ,OAAS,EACpBE,KAAC8I,MAAM9I,KAAC8I,MAAMhJ,OAAO,GAErB,QAYZU,EAAQ,SAAEwI,EAAUC,GAChB,IAAAL,EAAA,cADgBK,EAAY,kBAAG,IACzB,OAAAL,EAAAI,EAAAJ,SACF,GAAGK,EAAUL,GAAU,OAAOA,GACtCtI,EAAM,SAAE0I,EAAUC,GACd,IAAAL,EAAA5H,EACA,cAFciI,EAAY,kBAAG,IAC7BjI,KACM,OAAA4H,EAAAI,EAAAJ,SACCK,EAAUL,IAAU5H,EAAOqG,KAAKuB,UACvC5H,eAKJkI,gBAAkB,SAAED,oBAAAA,EAAY,kBAAG,IAC/BzI,EAAMR,KAACyI,0BAA2BQ,gBACtCE,eAAiB,SAAEF,oBAAAA,EAAY,kBAAG,IAC9B3I,EAAIN,KAACyI,0BAA2BQ,gBACpCG,aAAe,SAAEH,oBAAAA,EAAY,kBAAG,IAC5BzI,EAAMR,KAAC6I,oBAAqBI,gBAChCI,WAAa,SAAEJ,oBAAAA,EAAY,kBAAG,IAC1B3I,EAAIN,KAAC6I,oBAAqBI,gBA+B9BK,KAAO,kBAAGtJ,KAACkF,qBAAqB,qBAShCqE,aAAe,mBAAWvJ,KAACkF,qBAAqB,cAuBhDzE,EAAwB,SAAE+I,EAAWlF,GACjC,IAAAmF,EAAAC,EAAAC,EAAAhK,EAAAC,EAAAiC,EAAAR,MAAAqI,EAAWF,EAAUtE,qBAAqBZ,GAC1CmF,EAAWD,EAAUnF,qBAAqBC,GACvCoF,aAAwB1E,QAAW0E,MACnCD,aAAwBzE,QAAWyE,MACpCpI,KAAA1B,EAAA,EAAAC,GAAAiC,EAAAtC,MAAAQ,KAAA2J,GAAArG,OAAA9D,MAAAQ,KAAA0J,KAAA3J,OAAAH,EAAAC,EAAAD,IACsB,iCADtBgK,aAONpJ,EAAiB,SAAEiJ,EAAWpC,GAC1B,IAAAvG,EAAAlB,EAAAC,EAAA4D,EAAA3B,EAAAb,EACA,IADAA,KACArB,EAAA,EAAAC,GAAAiC,EAAA2H,EAAApB,iBAAAhB,IAAAtH,OAAAH,EAAAC,EAAAD,WACO,OAAA6D,EAAAlE,EAAAsB,eAAAC,KACCG,EAAOqG,KAAK7D,UACpBxC,GAKJN,EAAc,SAAE6G,GACZ,IAAAoC,EAAAhK,EAAAC,EAAAoB,EACA,IADAA,KACArB,EAAA,EAAAC,EAAA2H,EAAAzH,OAAAH,EAAAC,EAAAD,WACOsB,QAAAlB,KAAYiB,EAAZ2I,GAAA,GAAwB3I,EAAOqG,KAAKsC,UAC3C3I,eAiBJ4I,OAAS,WACL,IAAAjK,EAAAkK,EAAAjK,EAAAiC,EAAAb,EAAAK,MAAAL,EACIzB,MAAAQ,KAAEU,EAAsBT,KAAM,WAA9BqD,OACA9D,MAAAQ,KAAA,2BAAEsB,KAAA1B,EAAA,EAAAC,GAAAiC,EAAAtB,EAAAP,KAAA,UAAAF,OAAAH,EAAAC,EAAAD,aACa2J,eADbO,EAAMP,+BAGVjI,KAAA1B,EAAA,EAAAC,GAAAiC,EAAAnB,EAAAM,IAAAlB,OAAAH,EAAAC,EAAAD,IAAsD,sBAAtDkK,yBAMNC,SAAW,SAAED,UAAW5I,QAAAlB,KAASC,KAAC4J,SAAVC,IAAA,eAyBxBE,QAAU,kBAEFxK,MAAAQ,KAAEU,EAAsBT,KAAM,YAA9BqD,OACA9D,MAAAQ,KAAEQ,EAAeP,KAAM,yBAO/BgK,SAAW,kBAEHzK,MAAAQ,KAAEU,EAAsBT,KAAM,aAA9BqD,OACA9D,MAAAQ,KAAEQ,EAAeP,KAAM,0BAY/BiK,OAAS,SAAEJ,UACP7J,KAACkJ,gBAAgB,SAAE1F,UAAWA,EAAMsG,SAASD,kBAQjDK,MAAQ,SAAE1G,GACN,IAAA2G,EAAAR,EAAAhK,EAAAkG,EAAAgE,EAAAjK,EAAAkG,EAAAsE,EAEA,IADAA,KACAzK,EAAA,EAAAC,GAFAuK,EAAc5K,MAAAQ,KAAAC,KAAC+J,WAAD1G,OAAe9D,MAAAQ,KAAAC,KAACgK,cAE9BlK,OAAAH,EAAAC,EAAAD,IAAA,CACI,cAAW6D,EAAW,OAAO,EACX,iBAARmG,GAAsBS,EAAS/C,KAAKsC,IAC9C,mBAAAA,EAAAJ,aAAGI,EAAKJ,oBAAA,IAAqBa,EAAS/C,KAAKsC,EAAKL,QACpD,IAAAzD,EAAA,EAAAC,EAAAsE,EAAAtK,OAAA+F,EAAAC,EAAAD,IACI,UAAGrC,IAASxD,KAACiK,OAAOJ,GAAW,OAAO,SAC1C,eAKJQ,YAAc,kBAAGrK,KAACqJ,WAAW,SAAAiB,UAAA,SAAE9G,UAAWA,EAAM0G,MAAMI,IAAzB,CAAAtK,UA51BP","file":"structure.js","sourcesContent":["\n# LDE Structures\n\nThe very generic word \"structure\" is used in the LDE to describe a subtree\nof the LDE Document.  For more details on this, see\n[the design overview docs](https://lurchmath.github.io/lde/site/overview/).\n\n    exports.Structure = class Structure\n\nIf you plan to develop a subclass of `Structure`, be sure to follow the\nrequirement listed in the\n[Serialization and Deserialization](#serialization-and-deserialization)\nsection, below.\n\n## Unique IDs for instances\n\nWe want to be able to give instance of this class unique IDs.  To do so, we\nwill track those IDs in a class variable defined here, and provide class\nmethods for assigning and revoking IDs to instances.  IDs will be\nnonnegative integers, and we will track them using an array.\n\n        IDs : [ ]\n        @instanceWithID : ( id ) -> Structure::IDs[id]\n        @nextUnusedID : ->\n            result = Structure::IDs.indexOf null\n            if result >= 0 then result else Structure::IDs.length\n\nThe following two functions, which can be called in an instance to request a\nnew, unique ID, or to relinquish one back into the pool, are optional for\nany given instance.  That is, it is not required that each instance have an\nID.  But this system ensures that if IDs are assigned in this way, then they\nwill be globally unique for all instances.\n\nEnsure that any instance that calls `getID` at some point later calls\n`releaseID`, or the `IDs` array will become enormous, a memory leak.\n\n        getID : ->\n            return if @ID?\n            @ID = Structure.nextUnusedID()\n            Structure::IDs[@ID] = this\n        releaseID : ->\n            if @ID?\n                Structure::IDs[@ID] = null\n                delete @ID\n                while Structure::IDs[Structure::IDs.length-1] is null\n                    Structure::IDs.pop()\n\n## Constructor\n\nThe constructor body just initializes internal fields, but it accepts an\narray of initial children as its argument.  Any non-Structure passed as an\nargument is ignored.  See the next section for more details of child\nstructures.\n\n        constructor : ( children... ) ->\n            @computedAttributes = { }\n            @externalAttributes = { }\n            @parentNode = null\n            @childList = [ ]\n            for child in children\n                @insertChild child, @childList.length\n\n## Serialization and deserialization\n\nWe need to be able to convert structure hierarchies to/from JSON data.  We\ndo so with the routines in this section.  The serialization and\ndeserialization routines are not exactly inverses of one another, because\nthey explicitly ignore the `ID` attribute, if there is one.  Serializing and\nthen deserializing will produce a hierarchy with no IDs, but you can add\nthem with `setup`, defined [below](#external-attributs).  Even so, they will\nalmost certainly be different IDs than the original hierarchy had.  Other\nthan that, the two hierarchies should be equivalent.\n\n### Registering class names\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nAfter all, there will be sublcasses of this class defined, and during\ndeserialization, instances of those subclasses will need to be created, as\nopposed to generic `Structure`s.\n\nTo facilitate this, we track all subclasses in a single global variable,\nhere.  Add one using the registration function provided.\n\n        subclasses : { }\n        @addSubclass : ( name, classObj ) ->\n            Structure::subclasses[name] = classObj\n            name\n\nWhen should you call it?  In your subclass, create a class variable called\n`className` and assign `Structure.addSubclass 'your class name', YourClass`\nto that member.  Follow this example, which we do here for the `Structure`\nbase class:\n\n        className : Structure.addSubclass 'Structure', Structure\n\n## Serialization to JSON\n\nThe serialized version of a class contains some objects from within the\nclass, not copies but the same objects, so that serialization can be fast.\nThus you should not modify the serialized version's members.  If you want an\nindependent copy, run `JSON.parse` on `JSON.stringify` of the serialized\nversion.\n\n        toJSON : ->\n            className : @className\n            computedAttributes : @computedAttributes\n            externalAttributes : @externalAttributes\n            children : ( child.toJSON() for child in @childList )\n\n## Deserialization from JSON\n\nDeserialization is a method in the class, because of course it is called\nwhen you have no instance at hand, and wish to create one.\n\nIt does not re-use the members from the parameter, but explicitly copies\nthem using a combination of `JSON.parse` and `JSON.stringify`, so that a\ndeserialized version of an existing object will share no members with that\nobject.\n\n        @fromJSON : ( json ) ->\n            classObj = Structure::subclasses[json.className]\n            children =\n                ( Structure.fromJSON child for child in json.children )\n            result = new classObj children...\n            result.computedAttributes =\n                JSON.parse JSON.stringify json.computedAttributes\n            result.externalAttributes =\n                JSON.parse JSON.stringify json.externalAttributes\n            result\n\n## Tree structure\n\nStructures form a hierarchy, an n-ary tree.  We thus need functions for\ninserting, removing, and querying parents and children.\n\nFirst, the getters.  When querying the children, we make a copy of the list\nso that clients can feel free to manipulate it without messing up the\nintegrity of the hierarchy.\n\n        parent : -> @parentNode\n        children : -> @childList[..]\n        indexInParent : -> @parentNode?.childList?.indexOf this\n        previousSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index-1]\n        nextSibling : ->\n            if ( index = @indexInParent() )?\n                @parentNode.childList[index+1]\n\nNext, the setters.  There is no setter for the parent, because the parent\npointer of a structure S must be kept consistent with the children list of\nthe parent of S, and so we update both in the setters for children.\n\nWe permit removing children from parents, either with a method in the child\nor in the parent.\n\n        removeFromParent : ->\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @parentNode.childList.splice originalIndex, 1\n                @parentNode = null\n                @wasRemoved? originalParent, originalIndex\n        removeChild : ( atIndex ) -> @childList[atIndex]?.removeFromParent()\n\nWe permit inserting a new child into the parent's child array at any valid\nindex (including the old length of the child array, which appends).  The\nchild to be inserted is first removed from any parent it has when this\nmethod is called.  The default index is 0, so that a call of\n`insertChild(x)` inserts it as the first child.\n\nIf the child to be inserted is an ancestor of this structure, then we\nremove this structure from its parent, to obey the insertion command given\nwhile still maintaining acyclicity in the tree structure.  If the child to\nbe inserted is this node itself, this function does nothing.\n\n        insertChild : ( child, beforeIndex = 0 ) ->\n            return unless child instanceof Structure and \\\n                child isnt this and \\\n                0 <= beforeIndex <= @childList.length\n            walk = this\n            while ( walk = walk.parent() )?\n                if walk is child\n                    @removeFromParent()\n                    break\n            child.removeFromParent()\n            @childList = [\n                @childList[...beforeIndex]...\n                child\n                @childList[beforeIndex...]...\n            ]\n            child.parentNode = this\n            child.wasInserted?()\n\nA convenient combination of the above methods is to replace a child with a\nnew structure, deparenting the old child and putting the replacement at the\nsame index in the same parent.\n\n        replaceWith : ( other ) ->\n            if ( originalParent = @parentNode )?\n                originalIndex = @indexInParent()\n                @removeFromParent()\n                originalParent.insertChild other, originalIndex\n\nAnother possibly convenient utility is to make a copy of the Structure S\n(or equivalently the subtree with root S).\n\n        copy : ->\n            S = new Structure\n            S.computedAttributes =\n                JSON.parse JSON.stringify @computedAttributes\n            S.externalAttributes =\n                JSON.parse JSON.stringify @externalAttributes\n            S.childList = ( C.copy() for C in @childList )\n            S\n\nWe can ask which of two structures comes earlier in their common ancestor,\nunder pre-order tree traversal, lowest-indexed children first.  The ordering\ndefined here is strict (`A.isEarlierThan A` is false).\n\n        isEarlierThan : ( other ) ->\n            if other not instanceof Structure then return undefined\n            if other is this then return no\n\nGet a list of all ancestors of the other structure.  If it is the root,\nthen I am strictly later than it, and we can return that now.\n\n            ancestorsOfOther = [ other ]\n            while ( nextAncestor = ancestorsOfOther[0].parent() )?\n                ancestorsOfOther.unshift nextAncestor\n\nFind my nearest ancestor that appears in that list.\n\n            walk = this\n            relevantAncestor = null\n            while walk? and walk not in ancestorsOfOther\n                relevantAncestor = walk\n                walk = walk.parent()\n\nIf there was none, we are incomparable; return undefined.  If the nearest\nancestor was me, then other is one of my descendants, so I am earlier than\nit.  If the nearest ancestor was the other structure, then the reverse is\ntrue.\n\n            if not walk? then return undefined\n            if walk is this then return yes\n            if walk is other then return no\n\nCompare the child indices in the common ancestor to determine ordering.\n\n            commonAncestorIndex = ancestorsOfOther.indexOf walk\n            otherRelevantAncestor = ancestorsOfOther[commonAncestorIndex+1]\n            myAncestorIndex = relevantAncestor.indexInParent()\n            otherAncestorIndex = otherRelevantAncestor.indexInParent()\n            myAncestorIndex < otherAncestorIndex\n\n## Computed attributes\n\nThe dictionary of computed attributes has getters and setters that work on\nkeys or key-value pairs (respectively).  The intent is for them to store the\nresults of computations done by the LDE.  There is also a corresponding\n\"clear\" function for deleting entries from the computed attributes\ndictionary.\n\nThe client is permitted to use any keys they like here, but the `feedback`\nkey is special; see [the documentation\nhere](https://lurchmath.github.io/lde/site/phase0-structures/#methods-in-the-structure-class)\nfor details.\n\nNo checks are put on what kind of data can be used for the values of this\ndictionary, but they should be JSON data only, to support serialization.\n(Checks are omitted for efficiency.)\n\n        getComputedAttribute : ( key ) -> @computedAttributes[key]\n        setComputedAttribute : ( key, value ) ->\n            if @computedAttributes[key] isnt value\n                @computedAttributes[key] = value\n                @wasChanged?()\n        clearComputedAttributes : ( keys... ) ->\n            if keys.length is 0 then keys = Object.keys @computedAttributes\n            for key in keys\n                if key of @computedAttributes\n                    delete @computedAttributes[key]\n                    @wasChanged?()\n\nThe default implementation of the `compute` member takes any number of keys\nas string arguments, and runs them as member functions, storing the results\nas computed attributes.  Arrays can be used to pass additional arguments.\nSpecifically:\n\n * `S.compute('foo')` means `S.setComputedAttribute('foo',S.foo())`.\n * `S.compute(['foo',1,2,3])` means\n   `S.setComputedAttribute('foo',S.foo(1,2,3))`.\n * `S.compute(arg1,arg2,...)` means `S.compute(arg1)` and then\n   `S.compute(arg2)` and so on.\n\nMore details re in [the documentation\nhere](https://lurchmath.github.io/lde/site/phase0-structures/#methods-in-the-structure-class).\n\n        compute : ( args... ) ->\n            for arg in args\n                if arg not instanceof Array then arg = [ arg ]\n                [ func, params... ] = arg\n                @setComputedAttribute func, @[func] params...\n\n## External attributes\n\nThe dictionary of external attributes has get/set/clear functions just as we\nhave for computed attributes.  The intent is for them to store data provided\nby the client, and the LDE will not alter it.\n\nAs with computed attributes, values should be JSON data only, to support\nserialization, but we do not check for this property, for efficiency.\n\n        getExternalAttribute : ( key ) -> @externalAttributes[key]\n        setExternalAttribute : ( key, value ) ->\n            if @externalAttributes[key] isnt value\n                @externalAttributes[key] = value\n                @wasChanged?()\n        clearExternalAttributes : ( keys... ) ->\n            if keys.length is 0 then keys = Object.keys @externalAttributes\n            for key in keys\n                if key of @externalAttributes\n                    delete @externalAttributes[key]\n                    @wasChanged?()\n\nExternal attributes can also be added with an `attr()` function that returns\nthe instance, thus supporting method chaining.  This is useful when\nconstructing objects of this class, especially for unit testing, using\ncode like `Structure( Structure().attr(...), ... )`.  It takes an object and\ninstalls all of its key-value pairs as external attributes.\n\n        attr : ( object ) ->\n            @setExternalAttribute key, value for own key, value of object\n            this\n\nOn the topic of conveniences for constructing instances, the following\nmethod can be used at the top level of a nested set of constructor calls,\nto traverse the final tree after constructing it, and performs the\nconvenience cleanup routines described within the function itself.\n\nThis is intended to be used when constructing large structures, as in\n`result = Structure( ...lots of children... ).setup()`.\n\n        setup : ->\n\nEvery structure and substructure will be given a unique ID.\n\n            recurGetID = ( node ) ->\n                node.getID()\n                recurGetID child for child in node.children()\n            recurGetID this\n\nEvery structure with an external attribute key \"label for\", \"reason for\", or\n\"premise for\" and value X will be converted into a connection to node X of\ntype \"label\", \"reason\", or \"premise\", respectively.  Node X will be found by\nseeking a node with attribute key \"id\" and value X.\n\nAll attributes with key id are then deleted.\n\nAlternately the same keys could be associated with value \"previous\" or\n\"next\" to indicate connection to a sibling, with no id required.\n\n            targets = { }\n            recurFindTargets = ( node ) ->\n                if ( id = node.getExternalAttribute 'id' )?\n                    targets[id] = node\n                    node.clearExternalAttributes 'id'\n                recurFindTargets child for child in node.children()\n            recurFindTargets this\n            recurConnect = ( node ) ->\n                for attr in [ 'label', 'premise', 'reason' ]\n                    if ( value = node.getExternalAttribute \"#{attr} for\" )?\n                        if value is 'previous'\n                            target = node.previousSibling()\n                        else if value is 'next'\n                            target = node.nextSibling()\n                        else if targets.hasOwnProperty value\n                            target = targets[value]\n                        else\n                            target = null\n                        if target? then node.connectTo target, attr\n                        node.clearExternalAttributes \"#{attr} for\"\n                recurConnect child for child in node.children()\n            recurConnect this\n\nWe then check all connections within this structure for consistency, and\nreturn the structure for use in chaining.\n\n            @fillOutConnections()\n            this\n\n## Connections\n\nStructures may have connections among them, specified using external\nattributes.  The documentation\n[here](https://lurchmath.github.io/lde/site/phase0-structures/#connections)\ncovers the concept in detail.  We provide the following functions to make it\neasier for clients to create, remove, or query connections.\n\n### Making connections consistent\n\nThe first function ensures that all connections in a hierarchy are properly\nrecorded twice, once as outgoing from the source, and once as incoming to\nthe target.  This consistency is assumed by the query functions.  Run this\non the root of your hierarchy if you have any reason to believe that the\nconnections may not be stored consistently.\n\nBecause connections depend on IDs, this routine does nothing if this\nStructure does not already have an ID.\n\n        fillOutConnections : ->\n\nRecur on children, but if this object has no ID, we can't go beyond that.\n\n            child.fillOutConnections() for child in @childList\n            if not @ID? then return\n\nWe define an internal function for converting multisets of target-type pairs\nfrom array representation to an easier-to-work-with object representation,\nand then an inverse of that function.  These make the rest of this function\neaiser to write.\n\nThe \"array\" form is as in the docs linked to above,\n`[ [targID, connType], ... ]`.  The \"object\" form maps target keys to\nobjects whose key-value pairs are type-count pairs, where the count is the\nnumber of times the `[targID,connType]` pair appeared in the array.\nThat is, `{ targID: { type: count, ... }, ... }`.\n\n            arrayToObject = ( array ) ->\n                result = { }\n                for connection in array\n                    [ target, type ] = connection\n                    result[target] ?= { }\n                    result[target][type] ?= 0\n                    result[target][type]++\n                result\n            objectToArray = ( object ) ->\n                result = [ ]\n                for own target, moreData of object\n                    for own type, count of moreData\n                        for i in [1..count]\n                            result.push [ Number( target ), type ]\n                result\n\nNow find all my outgoing connections, and ensure they exist in at least the\nsame quantity on both sides.\n\n            outs = arrayToObject \\\n                ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            for own target, moreData of outs\n                continue unless ( T = Structure.instanceWithID target )?\n                targetIns = arrayToObject \\\n                    ( T.getExternalAttribute 'connectionsIn' ) ? [ ]\n                targetIns[@ID] ?= { }\n                for own type, count of moreData\n                    moreData[type] = targetIns[@ID][type] =\n                        Math.max count, targetIns[@ID][type] ? 0\n                T.setExternalAttribute 'connectionsIn',\n                    objectToArray targetIns\n\nRepeat the same exrecise for my incoming connections.\n\n            ins = arrayToObject \\\n                ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n            for own source, moreData of ins\n                continue unless ( S = Structure.instanceWithID source )?\n                sourceOuts = arrayToObject \\\n                    ( S.getExternalAttribute 'connectionsOut' ) ? [ ]\n                sourceOuts[@ID] ?= { }\n                for own type, count of moreData\n                    moreData[type] = sourceOuts[@ID][type] =\n                        Math.max count, sourceOuts[@ID][type] ? 0\n                S.setExternalAttribute 'connectionsOut',\n                    objectToArray sourceOuts\n\n### Making consistent connections\n\nAnother way to ensure that connections among structures in a hierarchy are\nconsistent is to avoid directly editing the external attribute containing\nthe connections data, and instead use the following two convenience\nfunctions for creating or deleting connections.\n\nNote that the LDE should not be directly editing external attributes anyway,\nbecause they are defined to be read-only from this side.  But these two\nfunctions are useful when constructing structures to use in testing, and in\nparticular for implementing the `attr` and `setup` functions above, which\nare very useful in the unit testing suite.\n\nThe first one creates a new connection of the given type from this structure\nto another.  Because there may be multiple connections of a given type\nbetween the same two structures, calling this repeatedly adds new\nconnections.\n\nThese functions do nothing if either of the two structures is lacking an ID.\nThey return true on success and false on failure.\n\n        connectTo : ( otherStructure, connectionType ) ->\n            return no unless @ID? and \\\n                otherStructure instanceof Structure and otherStructure.ID?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ins = ( otherStructure.getExternalAttribute 'connectionsIn' ) \\\n                ? [ ]\n            outs.push [ otherStructure.ID, connectionType ]\n            ins.push [ @ID, connectionType ]\n            @setExternalAttribute 'connectionsOut', outs\n            otherStructure.setExternalAttribute 'connectionsIn', ins\n            yes\n\nThe delete function does nothing if there is no connection to delete.\n\n        disconnectFrom : ( otherStructure, connectionType ) ->\n            return no unless @ID? and \\\n                otherStructure instanceof Structure and otherStructure.ID?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ins = ( otherStructure.getExternalAttribute 'connectionsIn' ) \\\n                ? [ ]\n            outIndex = inIndex = 0\n            while outIndex < outs.length and \\\n                  ( outs[outIndex][0] isnt otherStructure.ID or \\\n                    outs[outIndex][1] isnt connectionType )\n                outIndex++\n            if outIndex is outs.length then return no\n            while inIndex < ins.length and \\\n                  ( ins[inIndex][0] isnt @ID or \\\n                    ins[inIndex][1] isnt connectionType )\n                inIndex++\n            if inIndex is ins.length then return no\n            outs.splice outIndex, 1\n            ins.splice inIndex, 1\n            @setExternalAttribute 'connectionsOut', outs\n            otherStructure.setExternalAttribute 'connectionsIn', ins\n            yes\n\n### Querying connections\n\nThe following functions are some conveniences for querying what connections\nexist from a given structure object to/from others.\n\nFirst, we can fetch all connections of a given type that exit a given\nstructure object.  It returns a multiset of target structure IDs, in the\nform of an array with possible repeated entries.  If the user omits the\ntype, then all outgoing connections are returned, not as targets only, but\nas target-type pairs, `[[targetID,typeString],...]`.\n\n        allConnectionsOut : ( ofThisType ) ->\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            if not ofThisType? then return outs\n            ( conn[0] for conn in outs when conn[1] is ofThisType )\n\nThen we can do the same thing for incoming connections.\n\n        allConnectionsIn : ( ofThisType ) ->\n            ins = ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n            if not ofThisType? then return ins\n            ( conn[0] for conn in ins when conn[1] is ofThisType )\n\nWe can also request all connections between two given structures, which will\nreturn a multiset of connection types, in the form of an array with possible\nrepeated entries.  Returns null if the argument is not a structure, or is\none without an ID.\n\n        allConnectionsTo : ( otherStructure ) ->\n            return null unless otherStructure instanceof Structure and \\\n                otherStructure.ID?\n            outs = ( @getExternalAttribute 'connectionsOut' ) ? [ ]\n            ( conn[1] for conn in outs when conn[0] is otherStructure.ID )\n\nThe final query treats all incoming connections to a structure as if they\ngive it \"properties.\"  If A connects to B with type T, then when we look up\nthe key T in B's properties, we get an array that will contain A.  For\nmore information, see the documentation\n[here](https://lurchmath.github.io/lde/site/phase0-structures/#connections).\n\n        properties : ->\n            result = { }\n            for conn in ( @getExternalAttribute 'connectionsIn' ) ? [ ]\n                if ( source = Structure.instanceWithID conn[0] )?\n                    ( result[conn[1]] ?= [ ] ).push source\n            result\n\n## Accessibility\n\nA structure A is accessible to a structure B if they have a common ancestor\nand are positioned within that ancestor in such a way that B could cite A as\na premise.\n\nThe officially definition is that a structure is accessible to all of its\nprevious siblings, all the previous siblings of its parent, all the previous\nsiblings of its grandparent, and so on up the ancestor chain.  Note that a\nstructure is not accessible to itself, nor to any of its ancestors.\nConversely, if A is accessible to B, then we say that B is in the scope of\nA.\n\n### Foundational accessibility functions\n\nWe begin with two functions, implementing the accessibility/scope relations.\n\n        isAccessibleTo : ( other ) ->\n            if other not instanceof Structure then return no\n            if not other.parent()? then return no\n            if @parent() is other.parent()\n                @indexInParent() < other.indexInParent()\n            else\n                @isAccessibleTo other.parent()\n        isInTheScopeOf : ( other ) -> other.isAccessibleTo this\n\nFor all the other computations we will want to do with scopes and\naccessibility, we will need iterators over all structures accessible to (or\nin the scope of, respectively) this one.  An iterator for a set S is an\nobject `I` such that repeated calls to `I.next()` yield new elements of S\nuntil S is exhausted, at which point all future calls to `I.next()` return\nnull.\n\nThe first iterator function lists all structures accessible to this one, in\nreverse order in the hierarchy.  That is, all previous siblings are yielded\nfrom right to left, then all previous siblings of the parent, and so on.\n\n        iteratorOverAccessibles : ->\n            ancestor : this\n            sibling : this\n            next : ->\n                if not @ancestor? then return null\n                if ( @sibling = @sibling.previousSibling() )?\n                    return @sibling\n                @sibling = @ancestor = @ancestor.parent()\n                @next()\n\nThe second iterator function lists all structures in the scope of this one,\nin forward order in the hierarchy.  That is, all descendants of the next\nsibling are yielded, then all descendants of the subsequent sibling, and so\non, in the order of a postorder tree traversal.\n\n        iteratorOverScope : ->\n            chain : [ this ]\n            next : ->\n                if @chain.length is 0 then return null\n                last = @chain.pop()\n                if ( walk = last.nextSibling() )?\n                    @chain.push walk\n                    @chain.push walk while ( walk = walk.children()[0] )?\n                    @chain[@chain.length-1]\n                else if @chain.length > 0\n                    @chain[@chain.length-1]\n                else\n                    null\n\n### Accessibility convenience functions\n\nWe then create two functions that can use these iterators for searching or\nenumeration.  Call `first(iterator,predicate)` to get the first element the\niterator yields satisfying the predicate.  Call `all(iterator,prediacte)`\nwith the obvious related meaning.  In each case, the predicate can be\nomitted to get the first element or all elements (no restrictions).  If the\npredicate is never satisfied, `first` returns undefiend, and `all` returns\nan empty array.\n\n        first = ( iterator, predicate = -> yes ) ->\n            while ( next = iterator.next() )?\n                if predicate next then return next\n        all = ( iterator, predicate = -> yes ) ->\n            result = [ ]\n            while ( next = iterator.next() )?\n                if predicate next then result.push next\n            result\n\nWe can then write useful functions whose names give their obvious meanings,\nby combining the tools above.\n\n        firstAccessible : ( predicate = -> yes ) ->\n            first @iteratorOverAccessibles(), predicate\n        allAccessibles : ( predicate = -> yes ) ->\n            all @iteratorOverAccessibles(), predicate\n        firstInScope : ( predicate = -> yes ) ->\n            first @iteratorOverScope(), predicate\n        allInScope : ( predicate = -> yes ) ->\n            all @iteratorOverScope(), predicate\n\n## Attribute Conventions\n\nWe have already established one significant convention in [the Connections\nsection, above](#connections), that is, that the \"connections\" external\nattribute stores a very specific type of data with a very specific meaning.\nWe established that convention partially through documentation and partially\nthrough implementing convenience functions that assume and use the\nconvention.\n\nIn this section, we establish several other conventions, many of which build\nupon the connections convention, and that deal with both external and\ncomputed attributes.  These conventions may be leveraged by any client of\nthis module that constructs structures and expects the LDE to do\ncomputations (primarily validation) on them.\n\nIn some sense, you can see this as the most fluid of the work in this file.\nAll the previous sections in this class are foundational to how structures\nbehave, whereas this one is more arbitrary.  But at the same time, it adds\nmathematical concepts to the `Structure` class for the first time.\n\n### Special external attributes\n\nThere are three types of special external attributes (so far).\n\nAtomic structures are often defined by a single piece of text that is the\nstructure's content.  The first convention is that such text will be stored\nas an external attribute with key \"text,\" and consequently we create a\nconvenience function for accessing this very common piece of data.\n\n        text : -> @getExternalAttribute 'text'\n\nThe \"text\" in some structures is to be interpreted as a citation of another\nstructure by name.  For instance, a structure containing the text \"Theorem\n3.5\" probably refers to an earlier structure with that name.  Thus the\nsecond convention is that structures whose content is to be interpreted as a\nreference to an earlier name have their \"reference\" attribute set to true\n(or any value that becomes true when treated as a boolean).\n\n        isAReference : -> not not @getExternalAttribute 'reference'\n\nNote that the above two functions do not have corresponding setter functions\nbecause they are external attributes, which are read-only from the point of\nview of the LDE.\n\nThe second type of external attribute that requires special functions for\ndealing with it is the attribute storing connections to other structures.\nWe handle that attribute with all the functions in [the Connections section,\nabove](#connections).\n\n### Convenience functions used below\n\nWe define the following convenience functions that will be used to build the\nmore significant tools defined in the following section.  Note that these\nare defined with the equal sign (`=`) rather than the colon (`:`) so they\nare not instance members, but just temporary functions usable only within\nthis class.\n\nThe first looks up external and internal attributes under a given key,\nverifies that both are arrays of strings, and combines them into a single\nresulting array, filtering out all non-strings.\n\n        stringArrayAttributes = ( structure, key ) ->\n            external = structure.getExternalAttribute key\n            computed = structure.getComputedAttribute key\n            if external not instanceof Array then external = [ ]\n            if computed not instanceof Array then computed = [ ]\n            ( item for item in [ external..., computed... ] \\\n                when typeof item is 'string' )\n\nThe second takes a structure and connection type as arguments and returns\nall other structures that have connections of the given type to the given\nstructure.\n\n        allConnectedTo = ( structure, type ) ->\n            result = [ ]\n            for id in structure.allConnectionsIn type\n                if ( other = Structure.instanceWithID id )?\n                    result.push other\n            result\n\nThe final function takes an array and returns the an array with all the same\nentries as the first, but each entry listed exactly once (no duplicates).\n\n        uniqueArray = ( array ) ->\n            result = [ ]\n            for item in array\n                if item not in result then result.push item\n            result\n\n### Collecting labels, reasons, and premises\n\nWe permit a structure to be labeled in any of three ways.\n\n * The external attribute with key \"labels\" may be an array of strings, each\n   of which will then be treated as a label for the structure.\n * The computed attribute with key \"labels\" is treated the same way.\n * Any structure may label another structure by having a connection of type\n   \"label\" from the labeling structure to the labeled structure.\n\nThe `labels()` function gathers all labels assigned by any of these three\nmeans into a single set, returned as an array with no repeated entries, and\nno predefined order.  Any label that is not a string or is the empty string\nis omitted from the results.\n\n        labels : ->\n            result = [\n                ( stringArrayAttributes this, 'labels' )...\n                ( label.text() for label in allConnectedTo this, 'label' \\\n                    when label.text() )...\n            ]\n            ( label for label in uniqueArray result when label isnt '' )\n\nWe then build a trivial extension of the `labels()` function, the\n`hasLabel()` function, which checks to see if this structure has a\nparticular label.\n\n        hasLabel : ( label ) -> label in @labels()\n\nWe permit structures to have reasons attached to them in any of four ways.\n\n * A structure A may be a reason for another structure B if there is a\n   connection from A to B of type reason.  By default, A is then the reason\n   for B, in the sense that A should be a rule justifying B.\n * A variant of the previous case is when A passes the `isAReference()`\n   test, in which case A is not a rule justifying B, but rather the text of\n   A is the name of a rule justifying B.\n * The external attribute with key \"reasons\" may be an array of strings,\n   each of which will then be treated as the name of another structure that\n   is treated as a reason for this one.\n * The computed attribute with key \"reasons\" is treated the same way.\n\nThe following function gathers all reasons assigned by any of these four\nmeans into a single set, returned as an array with no predefined order.  It\nmay contain some strings (which are the names of reasons, and were attached\nusing one of the final two means) and/or some structures (which may be\nreasons or the names of them, and were attached using one of the first two\nmeans).  The caller is responsible for converting the names into structures\n(when possible) using `lookup()`, defined above.  The array may contain\nrepeated entries, if they were attached more than once using one or more of\nthe four means given above.\n\n        reasons : ->\n            [\n                ( stringArrayAttributes this, 'reasons' )...\n                ( allConnectedTo this, 'reason' )...\n            ]\n\nWe permit structures to have premises attached to them in exactly the same\nfour ways as they have reasons attached.  For that reason, we implement the\n`premises` function identically to the `reasons` function.\n\n        premises : ->\n            [\n                ( stringArrayAttributes this, 'premises' )...\n                ( allConnectedTo this, 'premise' )...\n            ]\n\n### Citations and lookups\n\nThe lookup function starts from this structure and walks back through all\nstructures accessible to it, to find the first one having a given label.\nThis can be used when the current structure cites something by name, and we\nwish to find which structure was cited by name.  We call the lookup function\nto find the nearest accessible structure with that name, if there is such a\nstructure.  Undefined is returned if there is no such structure.\n\n        lookup : ( label ) ->\n            @firstAccessible ( other ) -> other.hasLabel label\n\nWe can then use that function to check whether one structure cites another.\nWe say that A cites B iff B is a reason or premise for A.  Thus we get the\nresults of `reasons()` and `premises()` and perform any needed lookups to\nanswer the question, does A cite B?  For efficiency, we do equality\ncomparison of structures first, then lookups second.\n\n        cites : ( other ) ->\n            citations = [ @reasons()..., @premises()... ]\n            toLookUp = [ ]\n            for item in citations\n                if item is other then return yes\n                if typeof item is 'string' then toLookUp.push item\n                if item.isAReference?() then toLookUp.push item.text()\n            for label in toLookUp\n                if other is @lookup label then return yes\n            no\n\nFinally, we can write a function that computes all structures that cite this\none.  It uses the above function to make the work easy.\n\n        whatCitesMe : -> @allInScope ( other ) => other.cites this\n"]}