{"version":3,"sources":["input-structure.litcoffee"],"names":["BasicInputModifier","InputExpression","InputModifier","InputStructure","OutputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","className","addSubclass","markDirty","yesOrNo","ref","dirty","interpret","accessibles","childResults","scope","childArray","i","j","len","len1","node","result","length","insertChild","children","feedback","feedbackData","subject","id","updateData","incomingConnection","results","source","sources","clearAttributesFromModifiers","getConnectionsIn","getConnectionSource","push","sort","a","b","isEarlierThan","updateDataIn","setCameFromModifier","attrKey","setAttribute","getCameFromModifier","getAttribute","attributes","slice","setSingleValue","value","hasOwnProperty","addListItem","item","listSoFar","Array","concat","addSetElement","element","asString","otherElement","setSoFar","JSON","stringify","updateConnections","targetExpression","triple","actions","arguments","target","ref1","type","exports"],"mappings":"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","file":"input-structure.js","sourcesContent":["\n# Input Structures\n\nThe LDE module allows clients to construct input to that module as trees of\n`Structures`, but more specifically, trees of the subclass of `Structure`\ndefined in this module, `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`OutputStructure` instances.  In short, these support interpretation while\n`OutputStructure`s support validation.  You can also think of the difference\nas this:  `InputStructure`s represent the syntax of what the user has\nexpressed to the client, and `OutputStructure`s represent the semantics into\nwhich we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n        { OutputStructure } = require './output-structure'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n            importScripts 'output-structure.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n            importScripts 'release/output-structure.js'\n\n## Define the `InputStructure` class\n\n    class InputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputStructure', InputStructure\n\nMarking an `InputStructure` dirty means marking its entire ancestor chain\ndirty, because if a child's meaning has changed, that may impact the meaning\nof its parent, and so on up the chain.  If it is marked clean, this does not\nnecessarily propagate upwards.\n\n        markDirty : ( yesOrNo = yes ) ->\n            @dirty = yesOrNo\n            if yesOrNo then @parentNode?.markDirty()\n\n### Interpretation\n\nThe main purpose of `InputStructure`s is to be interpretable, converting the\nLDE's Input Tree (analogous to syntax) into its Output Tree (semantics).\nThe functions in this section support that purpose.\n\nThe `interpret()` function defines how each subclass of `InputStructure`\nproduces one or more nodes in the Output Tree.  It returns zero or more\n`OutputStructure` instances, in an array.  We provide the following default\nimplementation that makes `InputStructure` instances behave like generic\nwrappers around their children.\n\nThe parameters have the following meanings:\n * `accessibles` - the list of `OutputStructure` instances in the Output\n   Tree accessible to the structures produced by this function\n * `childResults` - the list of results produced by interpreting the\n   children of this node (already computed), which will be a list of lists,\n   because each child's results are an array of `OutputStructure`s.\n * `scope` - the list of highest-level nodes in the Input Tree whose\n   interpretations will be placed in the scope of the interpretation of this\n   node, in the Output Tree\n\nSubclasses which override this must be sure to satisfy the following\nproperties.\n * Compute the result based *only* on the data in the first two parameters,\n   `accessibles` and `childResults`.  Do not read from other parts of the\n   Input or Output Trees, including the data in `scope`.\n * Mark another `InputStructure` dirty *only* if it is a descendant of one\n   of the structures in the `scope` array (the third parameter).\n\n\n        interpret : ( accessibles, childResults, scope ) ->\n            result = new OutputStructure() # plain vanilla wrapper node\n            for childArray in childResults\n                for node in childArray\n                    result.insertChild node, result.children().length\n            [ result ] # must be an array even if it contains only one node\n\n### Feedback\n\nTo give feedback about a particular `InputStructure` instance, call the\n`feedback` method in that instance, which will delegate the work to the\nclass-level `feedback` method in the `Structure` class, but only after\nadding itself as the subject of the feedback data.  While that method's\ndefault implementation is a stub, it is overwritten by the LDE when\n[the Structure module](structure.litcoffee) is loaded into the LDE.\n\n        feedback : ( feedbackData ) ->\n            feedbackData.subject = @id()\n            Structure.feedback feedbackData\n\n## Define `InputExpression`s as a type of `InputStructure`\n\n`InputStructure`s come in two varieties, each represented by a subclass. The\nfirst is defined in this section:  An `InputExpression` is the type of\n`InputStructure` that the LDE will interpret into meaningful content in its\nOutput Tree.  In the next section, we define `InputModifier`s, which do not\nproduce nodes in the Output Tree, but just modify `InputExpression`\ninstances and thus impact how they produce nodes in the Output Tree.\n\n    class InputExpression extends InputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputExpression', InputExpression\n\n### Expression-specific functionality\n\nDuring interpretation of the Input Tree, each expression will need to import\nfrom the modifiers connected to it any data that they wish to embed into the\nexpression, so that such data can be used to inform the expression's\ninterpretation.  We provide the following function for doing so.\n\nIt is required to process incoming connections in the order that the\nmodifiers appear in the Input Tree.  Thus we find all the modifiers first,\nthen sort them by their order in the tree, then embed the data.  The\n`clearAttributesFromModifiers()` function is documented later.\n\n        updateData : ->\n            @clearAttributesFromModifiers()\n            sources = [ ]\n            for incomingConnection in @getConnectionsIn()\n                source = @getConnectionSource incomingConnection\n                sources.push source if source instanceof InputModifier\n            sources.sort ( a, b ) ->\n                if a is b then 0 else if a.isEarlierThan b then -1 else 1\n            source.updateDataIn @ for source in sources\n\nWhen an `InputModifier` writes to an attribute of this object, we may want\nto mark the attribute as having come from a modifier.  This will help us\nprovide some convenience features to modifiers as they write to attributes.\nWe thus provide the following two functions that use internal attributes\n(ones beginning with underscore) to store metadata about an attribute.\n\n        setCameFromModifier : ( attrKey ) ->\n            @setAttribute \"_from modifier #{attrKey}\", yes\n        getCameFromModifier : ( attrKey ) ->\n            @getAttribute \"_from modifier #{attrKey}\"\n\nBefore the modification phase, it can be useful to delete everything that\nwas set by a modifier, so that modifiers can accumulate list or set data in\ntheir target without worrying about compounding what they added in the last\nrun of the modification phase.  Thus the following function guarantees that\nthe expression is in a pristine state, as far as modifier data is concerned.\n\n        clearAttributesFromModifiers : ->\n            for own key of @attributes\n                if key[...15] is '_from modifier '\n                    delete @attributes[key]\n                    delete @attributes[key[15...]]\n\n### Convenience functions for `InputModifier`s\n\nAn `InputModifier` may want to write a single value into its target\nexpression, but not overwrite any value already stored there.  To that end,\nwe have the following function.  It does exactly that, and also marks the\nwritten value as having come from a modifier.  Thus this function is\nintended to be called only by `InputModifier`s.  It returns true if it set\nthe value, and false if it did not because one was already there.  Because\nattributes written by modifiers are cleared at the start of every run of\n`updateData()`, the first modifier to attempt to write a single value will\nsucceed, and all others will fail.\n\n        setSingleValue : ( key, value ) ->\n            return no if @attributes.hasOwnProperty key\n            @setAttribute key, value\n            @setCameFromModifier key\n            yes\n\nAn `InputModifier` may want to append a single value to an array stored in\nits target expression, but not change any of the earlier values already\nstored in the array.  To that end, we have the following function.  It does\nexactly that, and also marks the array as having come from a modifier.  Thus\nthis function is intended to be called only by `InputModifier`s.  Because\nattributes written by modifiers are cleared at the start of every run of\n`updateData()`, the result at the end of a run of `updateData()` will be the\nlist of values appended by all connected modifiers that write to the array,\nin the order the modifiers appear in the document.\n\n        addListItem : ( key, item ) ->\n            listSoFar = @getAttribute key\n            if listSoFar not instanceof Array then listSoFar = [ ]\n            @setAttribute key, listSoFar.concat [ item ]\n            @setCameFromModifier key\n\nThis function is just like the previous, except it builds a set rather than\na list, and thus the order in which things are added is unimportant (and, of\ncourse, duplicates are not added twice).\n\n        addSetElement : ( key, element ) ->\n            asString = JSON.stringify element\n            setSoFar = @getAttribute key\n            @setCameFromModifier key\n            if setSoFar not instanceof Array then setSoFar = [ ]\n            for otherElement in setSoFar # is it already there?\n                return if asString is JSON.stringify otherElement\n            @setAttribute key, setSoFar.concat [ element ]\n\n## Define `InputModifier`s as a type of `InputStructure`\n\nAs documented in the previous section, `InputModifier`s are the subclass of\n`InputStructure` that do not produce interpretations in the LDE's Output\nTree, but instead modify the interpretations of `InputExpression`s, which\ndo.\n\n    class InputModifier extends InputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputModifier', InputModifier\n\nOne unique characteristic of modifiers is that they cannot contain other\nnodes as children.  Thus we alter the constructor so that when it calls the\nparent class's constructor, it does not pass on any arguments, and we\nredefine the `insertChild()` routine to do nothing.\n\n        constructor : -> super()\n        insertChild : ->\n\n### Modifier-specific functionality\n\nThe LDE guarantees that, before it interprets the Input Tree into the Output\nTree, it will run `updateConnections()` in every `InputModifier`.  This\ngives the modifier an opportunity to ensure that it is connected (using the\nordinary connections features built into all `Structure`s) to the correct\nset of `InputExpressions`, precisely those that it modifies.  Those\n`InputExpression`s will, during interpretation, then call the\n`updateDataIn()` functions in the modifiers attached to them, giving each\nsuch modifier a chance to impact the expression before it is interpreted.\n\nHere, we provide default implementations of both `updateConnections()` and\n`updateDataIn()`, which do nothing.  Subclasses of `InputModifier` can\nreimplement them to take actions appropriate to that subclass.\n\n        updateConnections : ->\n        updateDataIn : ( targetExpression ) ->\n\n## Define `BasicInputModifier`s as a type of `InputModifier`\n\nThis class implements the simplest (and probably most common) type of\n`InputModifier`, one that makes a series of calls to `setSingleValue()`,\n`addListItem()`, and/or `addSetElement()` in its target(s).  Thus its\nconstructor takes a set of key-value-type triples and stores them for later\nembedding in any target.  The \"type\" of the triple will be which kind of\nfunction should be used to insert it (single value, list item, set element),\nas the string name of that function (`\"setSingleValue\"`, `\"addListItem\"`,\nand `\"addSetElement\"`).\n\n    class BasicInputModifier extends InputModifier\n\nThe constructor that stores the set of triples, discarding any that don't\nmatch the format given above.\n\n        constructor : ->\n            super()\n            @actions = ( triple for triple in arguments \\\n                when triple.length is 3 and triple[2] in \\\n                [ 'setSingleValue', 'addListItem', 'addSetElement' ] )\n\nThe `updateDataIn()` method that just runs the functions described by the\ntriples.\n\n        updateDataIn : ( target ) ->\n            target[type] key, value for [ key, value, type ] in @actions\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'BasicInputModifier',\n            BasicInputModifier\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports?\n        exports.InputStructure = InputStructure\n        exports.InputExpression = InputExpression\n        exports.InputModifier = InputModifier\n        exports.BasicInputModifier = BasicInputModifier\n"]}