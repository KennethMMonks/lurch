{"version":3,"sources":["input-structure.litcoffee"],"names":["InputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","className","addSubclass","markDirty","yesOrNo","ref","dirty","feedback","feedbackData","subject","id","exports"],"mappings":"AAiBI,IAAAA,eAAAC,UAAAC,OAAA,SAAAC,EAAAC,GAAA,SAAAC,IAAAC,KAAAC,YAAAJ,EAAA,IAAA,IAAAK,KAAAJ,EAAAK,QAAAC,KAAAN,EAAAI,KAAAL,EAAAK,GAAAJ,EAAAI,IAAA,OAAAH,EAAAM,UAAAP,EAAAO,UAAAR,EAAAQ,UAAA,IAAAN,EAAAF,EAAAS,UAAAR,EAAAO,UAAAR,6BAAG,oBAAAU,SAAA,OAAAA,QACGZ,UAAcY,QAAQ,eAARZ,UACZ,oBAAAa,mBAAA,OAAAA,kBACJC,cAAc,gBACV,OAAA,oBAAAC,MAAA,OAAAA,KAAAA,KAAAD,mBAAA,IACJA,cAAc,wBAIZf,eAAA,SAAAiB,qFAAuBhB,uBAMzBiB,UAAYjB,UAAUkB,YAAY,iBAAkBnB,eAOpDoB,UAAY,SAAEC,GACV,IAAAC,EACA,aAFUD,GAAU,GACpBf,KAACiB,MAAQF,EACNA,qCAA0BD,iBAAb,eAWpBI,SAAW,SAAEC,UACTA,EAAaC,QAAUpB,KAACqB,KACxB1B,UAAUuB,SAASC,MA5BrB,GAgCH,oBAAAG,SAAA,OAAAA,UAAcA,QAAQ5B,eAAiBA","file":"input-structure.js","sourcesContent":["\n# Input Structures\n\nThe LDE module allows clients to construct input to that module as trees of\n`Structures`, but more specifically, trees of the subclass of `Structure`\ndefined in this module, `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`OutputStructure` instances.  In short, these support interpretation while\n`OutputStructure`s support validation.\n\n## Import modules\n\nImport the `InputStructure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\n    if require?\n        { Structure } = require './structure'\n    else if WorkerGlobalScope?\n        importScripts 'structure.js'\n    else if self?.importScripts?\n        importScripts 'release/structure.js'\n\n## Define the `InputStructure` class\n\n    class InputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputStructure', InputStructure\n\nMarking an `InputStructure` dirty means marking its entire ancestor chain\ndirty, because if a child's meaning has changed, that may impact the meaning\nof its parent, and so on up the chain.  If it is marked clean, this does not\nnecessarily propagate upwards.\n\n        markDirty : ( yesOrNo = yes ) ->\n            @dirty = yesOrNo\n            if yesOrNo then @parentNode?.markDirty()\n\n## Feedback\n\nTo give feedback about a particular `InputStructure` instance, call the\n`feedback` method in that instance, which will delegate the work to the\nclass-level `feedback` method in the `Structure` class, but only after\nadding itself as the subject of the feedback data.  While that method's\ndefault implementation is a stub, it is overwritten by the LDE when\n[the Structure module](structure.litcoffee) is loaded into the LDE.\n\n        feedback : ( feedbackData ) ->\n            feedbackData.subject = @id()\n            Structure.feedback feedbackData\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports? then exports.InputStructure = InputStructure\n\n## Other `InputStructure` Subclasses\n\nNone yet.  More to come.\n"]}