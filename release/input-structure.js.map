{"version":3,"sources":["input-structure.litcoffee"],"names":["InputExpression","InputModifier","InputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","className","addSubclass","markDirty","yesOrNo","ref","dirty","feedback","feedbackData","subject","id","insertChild","updateConnections","updateDataIn","targetExpression","exports"],"mappings":"AAwBI,IAAAA,gBAAAC,cAAAC,eAAAC,UAAAC,OAAA,SAAAC,EAAAC,GAAA,SAAAC,IAAAC,KAAAC,YAAAJ,EAAA,IAAA,IAAAK,KAAAJ,EAAAK,QAAAC,KAAAN,EAAAI,KAAAL,EAAAK,GAAAJ,EAAAI,IAAA,OAAAH,EAAAM,UAAAP,EAAAO,UAAAR,EAAAQ,UAAA,IAAAN,EAAAF,EAAAS,UAAAR,EAAAO,UAAAR,6BAAG,oBAAAU,SAAA,OAAAA,QACGZ,UAAcY,QAAQ,eAARZ,UACZ,oBAAAa,mBAAA,OAAAA,kBACG,MAAAA,kBAAAb,WACHc,cAAc,gBACd,OAAA,oBAAAC,MAAA,OAAAA,KAAAA,KAAAD,mBAAA,IACG,MAAAC,KAAAf,WACHc,cAAc,wBAIhBf,eAAA,SAAAiB,qFAAuBhB,uBAMzBiB,UAAYjB,UAAUkB,YAAY,iBAAkBnB,eAOpDoB,UAAY,SAAEC,GACV,IAAAC,EACA,aAFUD,GAAU,GACpBf,KAACiB,MAAQF,EACNA,qCAA0BD,iBAAb,eAWpBI,SAAW,SAAEC,UACTA,EAAaC,QAAUpB,KAACqB,KACxB1B,UAAUuB,SAASC,MA5BrB,GAuCA3B,gBAAA,SAAAmB,qFAAwBjB,4BAM1BkB,UAAYjB,UAAUkB,YAAY,kBAAmBrB,KANnD,GAeAC,cAAA,SAAAkB,GAaY,SAAAlB,IAAGA,EAAAa,UAAAL,YAAAG,KAAAJ,sBAbON,4BAMxBkB,UAAYjB,UAAUkB,YAAY,gBAAiBpB,eAQnD6B,YAAc,yBAiBdC,kBAAoB,yBACpBC,aAAe,SAAEC,OAhCf,GAoCH,oBAAAC,SAAA,OAAAA,UACCA,QAAQhC,eAAiBA,eACzBgC,QAAQlC,gBAAkBA,gBAC1BkC,QAAQjC,cAAgBA","file":"input-structure.js","sourcesContent":["\n# Input Structures\n\nThe LDE module allows clients to construct input to that module as trees of\n`Structures`, but more specifically, trees of the subclass of `Structure`\ndefined in this module, `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`OutputStructure` instances.  In short, these support interpretation while\n`OutputStructure`s support validation.  You can also think of the difference\nas this:  `InputStructure`s represent the syntax of what the user has\nexpressed to the client, and `OutputStructure`s represent the semantics into\nwhich we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n\n## Define the `InputStructure` class\n\n    class InputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputStructure', InputStructure\n\nMarking an `InputStructure` dirty means marking its entire ancestor chain\ndirty, because if a child's meaning has changed, that may impact the meaning\nof its parent, and so on up the chain.  If it is marked clean, this does not\nnecessarily propagate upwards.\n\n        markDirty : ( yesOrNo = yes ) ->\n            @dirty = yesOrNo\n            if yesOrNo then @parentNode?.markDirty()\n\n### Feedback\n\nTo give feedback about a particular `InputStructure` instance, call the\n`feedback` method in that instance, which will delegate the work to the\nclass-level `feedback` method in the `Structure` class, but only after\nadding itself as the subject of the feedback data.  While that method's\ndefault implementation is a stub, it is overwritten by the LDE when\n[the Structure module](structure.litcoffee) is loaded into the LDE.\n\n        feedback : ( feedbackData ) ->\n            feedbackData.subject = @id()\n            Structure.feedback feedbackData\n\n## Define `InputExpression`s as a type of `InputStructure`\n\n`InputStructure`s come in two varieties, each represented by a subclass. The\nfirst is defined in this section:  An `InputExpression` is the type of\n`InputStructure` that the LDE will interpret into meaningful content in its\nOutput Tree.  In the next section, we define `InputModifier`s, which do not\nproduce nodes in the Output Tree, but just modify `InputExpression`\ninstances and thus impact how they produce nodes in the Output Tree.\n\n    class InputExpression extends InputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputExpression', InputExpression\n\n## Define `InputModifier`s as a type of `InputStructure`\n\nAs documented in the previous section, `InputModifier`s are the subclass of\n`InputStructure` that do not produce interpretations in the LDE's Output\nTree, but instead modify the interpretations of `InputExpression`s, which\ndo.\n\n    class InputModifier extends InputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'InputModifier', InputModifier\n\nOne unique characteristic of modifiers is that they cannot contain other\nnodes as children.  Thus we alter the constructor so that when it calls the\nparent class's constructor, it does not pass on any arguments, and we\nredefine the `insertChild()` routine to do nothing.\n\n        constructor : -> super()\n        insertChild : ->\n\n### Modifier-specific functionality\n\nThe LDE guarantees that, before it interprets the Input Tree into the Output\nTree, it will run `updateConnections()` in every `InputModifier`.  This\ngives the modifier an opportunity to ensure that it is connected (using the\nordinary connections features built into all `Structure`s) to the correct\nset of `InputExpressions`, precisely those that it modifies.  Those\n`InputExpression`s will, during interpretation, then call the\n`updateDataIn()` functions in the modifiers attached to them, giving each\nsuch modifier a chance to impact the expression before it is interpreted.\n\nHere, we provide default implementations of both `updateConnections()` and\n`updateDataIn()`, which do nothing.  Subclasses of `InputModifier` can\nreimplement them to take actions appropriate to that subclass.\n\n        updateConnections : ->\n        updateDataIn : ( targetExpression ) ->\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports?\n        exports.InputStructure = InputStructure\n        exports.InputExpression = InputExpression\n        exports.InputModifier = InputModifier\n"]}