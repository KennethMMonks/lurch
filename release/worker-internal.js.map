{"version":3,"sources":["worker-internal.litcoffee"],"names":["hasProp","hasOwnProperty","self","addEventListener","event","error","fail","finish","func","justDoThis","request","succeed","data","info","key","response","value","id","postMessage","success","error1","message","type","result","eval","code","importScripts","filename","name","Function","body","globalData"],"mappings":"AAeI,IAAAA,WAAAC,eAAAC,KAAKC,iBAAiB,UAAW,SAAEC,OAC/B,IAAAC,MAAAC,KAAAC,OAAAC,KAAAC,WAAAC,QAAAC,QAkDA,GAlDAD,QAAUN,MAAMQ,KAahBL,OAAS,SAAEM,GACP,IAAAC,EAAAC,EAAAC,YADOH,MACPE,GAAWE,GAAKP,QAAQO,IACxB,IAAAH,KAAAD,6BAAAE,EAASD,GAAOE,UAChBd,KAAKgB,YAAYH,IACrBJ,QAAU,SAAEE,oBAAAA,MACRA,EAAKM,SAAU,EACfZ,OAAOM,IACXP,KAAO,SAAED,EAAOQ,oBAAAA,MACZA,EAAKR,MAAQA,EACbE,OAAOM,IAOXJ,WAAa,SAAED,GACX,IAAAH,EAAA,WACIM,QAAQH,KADZ,MAAAY,UAEMf,EAAAe,EACFd,KAAKD,EAAMgB,WAQA,QAAhBX,QAAQY,MACPb,WAAW,kBAAGc,OAASC,KAAKd,QAAQe,SAQrB,aAAhBf,QAAQY,KACP,IACId,KAAOgB,KAAKd,QAAO,UACnBF,KAAK,SAAEe,EAAQlB,GACX,OAAGA,EAAWC,KAAKD,GAAWM,SAAQY,OAASA,MAHvD,MAAAH,GAIMf,MAAAe,EACFd,KAAKD,MAAMgB,SAgCnB,GAzBmB,mBAAhBX,QAAQY,MACPb,WAAW,kBAAGiB,cAAchB,QAAQiB,eAUrB,qBAAhBjB,QAAQY,MACPb,WAAW,kBACPP,KAAKQ,QAAQkB,MACT,IAAIC,SAASnB,QAAO,UAAYA,QAAQoB,WASjC,iBAAhBpB,QAAQY,MACPb,WAAW,kBAAGP,KAAK6B,WAAWrB,QAAQkB,MAAQlB,QAAQE,UACvC,mBAAhBF,QAAQY,YACPb,WAAW,yBAAUP,KAAK6B,WAAWrB,QAAQkB,aAIrD1B,KAAK6B,cACL7B,KAAKgB,aAAYI,KAAO","file":"worker-internal.js","sourcesContent":["\n# Background Workers (Internal Functions)\n\nThis file defines the functions that support the functionality we need in\nthe background workers the [LDE](lde.litcoffee) will use.\n * This file contains the code that will be loaded into the worker's\n   background thread.  Thus here we define all the things that the workers\n   can actually do.\n * [A separate file](worker.litcoffee) is intended to be imported by anyone\n   who wishes to create instance of the `Worker` class; it interfaces with\n   this one across the thread boundary, through message passing.\n\nWe install a global event listener that watches for several different types\nof events that might come in, and responds to each separately.\n\n    self.addEventListener 'message', ( event ) ->\n        request = event.data\n\nWe also install some convenience functions for sending responses back to our\nclient in a uniform way.  The `succeed` function sends a success message and\nthe `fail` function sends a failure message.  Optional additional parameters\ncan be passed as an object and all their members will be copied into the\nmessage sent back to the client.\n\nBy default, the message sent to the client contains only the same `id` as\nthe event to which we're responding, so that the client can match up\nrequests and responses correctly.  Some additional data is typically\nrequired, depending on the request made.\n\n        finish = ( info = { } ) ->\n            response = id : request.id\n            response[key] = value for own key, value of info\n            self.postMessage response\n        succeed = ( info = { } ) ->\n            info.success = yes\n            finish info\n        fail = ( error, info = { } ) ->\n            info.error = error\n            finish info\n\nEven simpler, you can just say what function should compute the object to\npass to `succeed` (undefined being acceptable, as the signature for\n`succeed` indcates) but `fail` will be called if an error is thrown, with\nthat error's message.\n\n        justDoThis = ( func ) ->\n            try\n                succeed func()\n            catch error\n                fail error.message\n\n## Support running arbitrary code\n\nHey, it's a sandbox, right?  Run whatever you want.  We don't care.\n\nFor synchronous code, it is simpler:\n\n        if request.type is 'run'\n            justDoThis -> result : eval request.code\n\nFor asynchronous code, we expect `request.function` to be an asynchronous\nfunction that takes a single callback as its parameter.  That callback will\nhas the standard result-and-error pair of arguments, only one of which\nshould be non-null.  The function should respect this and call the callback\nin one of those two ways upon completion or encountering an error.\n\n        if request.type is 'runAsync'\n            try\n                func = eval request.function\n                func ( result, error ) ->\n                    if error then fail error else succeed result : result\n            catch error\n                fail error.message\n\n## Support installing scripts\n\nIf we receive a message asking us to install a script, we obey it, then call\na callback saying that we did so.\n\n        if request.type is 'install script'\n            justDoThis -> importScripts request.filename ; { }\n\n## Support installing functions\n\nIf we receive a message asking us to install a function, we obey it, then\ncall a callback saying that we did so.  We use here the `Function`\nconstructor, knowing that the client has passed us a string containing the\nargument list and body, ready for handing directly to the `Function`\nconstructor.\n\n        if request.type is 'install function'\n            justDoThis ->\n                self[request.name] =\n                    new Function request.arguments, request.body\n                { }\n\n## Support installing data\n\nIf we receive a message asking us to install or uninstall data, we obey it,\nthen call a callback.  Data goes in the global variables `globalData`, which\nwe initialize at the end of this file.  You can also uninstall data.\n\n        if request.type is 'install data'\n            justDoThis -> self.globalData[request.name] = request.data ; { }\n        if request.type is 'uninstall data'\n            justDoThis -> delete self.globalData[request.name] ; { }\n\nInitialize the global data store used by the \"install data\" handler:\n\n    self.globalData = { }\n    self.postMessage type : 'loaded'\n"]}