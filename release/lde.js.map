{"version":3,"sources":["lde.litcoffee"],"names":["LDEDocument","Structure","expectedArgumentCount","externalIDToStructure","functions","isInTheDocument","lookupID","releaseAllIDs","stopTrackingExternalIDs","trackExternalIDs","slice","require","WorkerGlobalScope","importScripts","self","getID","getDocument","structure","parent","hierarchy","child","i","len","ref","results","releaseID","children","length","recursive","id","getExternalAttribute","instanceWithID","insert","json","parentID","insertionIndex","newInstance","fromJSON","setup","insertChild","subtreeID","subtree","removeFromParent","replace","replaceWith","setAttribute","key","value","setExternalAttribute","delete","addEventListener","event","args","command","data","call","postMessage","toJSON","apply","exports"],"mappings":"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","file":"lde.js","sourcesContent":["\n# Lurch Deductive Engine (LDE) Main File\n\nThis file imports all the other modules in this repository and exposes them\nthrough its `exports` member, so that clients can import just this one file\nand have access to all the functionality from all the source files in this\nrepository.\n\nImport the structure class and export it to clients as well.  The following\nlines detect whether this is being used in Node.js or a WebWorker, or a\nWebWorker-like background thread within Node.js, and do the right thing in\nany case.\n\n    if require?\n        { Structure } = require './structure'\n    else if WorkerGlobalScope?\n        importScripts 'structure.js'\n    else if self?.importScripts?\n        importScripts 'release/structure.js'\n\n## The LDE Document\n\nThe LDE Document is a global instance of the `Structure` class, representing\nthe meaningful content of the user's document.\n\n    LDEDocument = new Structure\n    LDEDocument.getID()\n\nClients should treat the global LDE Document as read-only, *except* through\nthe API provided in [the following section](#the-main-api).  But we provide\nthe following function for two reasons.\n\n 1. It is usable to *read* the LDE Document.  Although the client could also\n    use it to manipulate that document, doing so violates the preconditions\n    of this module, and thus discards any behavior guarantees it provides.\n 2. As an important special case of the previous, it is usable in the unit\n    testing suite to verify that the API below is manipulating the document\n    according to its specifications.\n\nThe following function returns the root of the LDE Document structure.\n\n    functions = { }\n    functions.getDocument = -> LDEDocument\n\n## Utilities\n\nWe create a function for use privately in this module, for verifying that a\nparticular structure is a descendant of the LDE Document.\n\n    isInTheDocument = ( structure ) ->\n        while structure instanceof Structure\n            if structure is LDEDocument then return yes\n            structure = structure.parent()\n        no\n\nWe also create a function for recursively releasing IDs throughout an entire\nstructure hierarchy.\n\n    releaseAllIDs = ( hierarchy ) ->\n        hierarchy.releaseID()\n        releaseAllIDs child for child in hierarchy.children()\n\nAnd another two functions for adding or removing a hierarchy of structures\nfrom having the IDs contained in their external attributes tracked by this\nmodule.\n\n    externalIDToStructure = { }\n    trackExternalIDs = ( hierarchy, recursive = yes ) ->\n        if ( id = hierarchy.getExternalAttribute 'ID' )?\n            externalIDToStructure[id] = hierarchy\n        if recursive\n            trackExternalIDs child for child in hierarchy.children\n    stopTrackingExternalIDs = ( hierarchy, recursive = yes ) ->\n        if ( id = hierarchy.getExternalAttribute 'ID' )?\n            delete externalIDToStructure[id]\n        if recursive\n            stopTrackingExternalIDs child for child in hierarchy.children\n\nFinally a lookup function for IDs that will test whether the ID is a\nnonnegative natural number (as used by the Structure module) or a string\n(as may be used externally by any client).  The former is done through a\nlookup provided by the `Structure` class itself, and the latter using the\nobject defined above.  Also, the special string `\"root\"` always yields the\ndocument root.\n\n    lookupID = ( id ) ->\n        if id is 'root'\n            functions.getDocument()\n        else if typeof id is 'number'\n            Structure.instanceWithID id\n        else\n            externalIDToStructure[id]\n\n## The Main API\n\nThis module presents to clients a four-function API defined in this section.\nEach of these functions manipulates the global LDE Document.\n\nThe following insertion function deserializes the given structure from JSON,\nfinds the descendant of the LDE Document that has the given ID, and inserts\nthe deserialized version as one of its children, at the given index. If\nanything goes wrong in that process then it does nothing.  All newly\ninserted structures are given new, unique IDs (with their descendants) if\nthey did not yet have them.\n\nThe ID may be the ID of a Structure, as defined in that class (a nonnegative\nnatural number) or it may be an externally used ID, which must be a string,\nand will be considered to indicate the unique structure with external\nattribute having key \"ID\" and the given string as its value.\n\n    functions.insert = ( json, parentID, insertionIndex ) ->\n        if ( parent = lookupID parentID )? and \\\n           ( 0 <= insertionIndex <= parent.children().length ) and \\\n           ( isInTheDocument parent ) and \\\n           ( newInstance = Structure.fromJSON( json ).setup() )?\n            parent.insertChild newInstance, insertionIndex\n            trackExternalIDs newInstance\n\nThe following function finds the descendant of the global LDE Document that\nhas the given ID and, assuming such a structure exists, removes it from its\nparent and releases all IDs within it.\n\n    functions.delete = ( subtreeID ) ->\n        if ( subtree = lookupID subtreeID )? and \\\n           ( isInTheDocument subtree ) and subtree isnt LDEDocument\n            subtree.removeFromParent()\n            releaseAllIDs subtree\n            stopTrackingExternalIDs subtree\n\nThe following function finds the descendant of the global LDE Document that\nhas the given ID and, assuming such a structure exists, deserializes the\nsecond argument as a Structure object and uses it to replace the original\nstructure in the LDE Document. The deserialized version will be assigned\nnew, unique IDs at every node in its tree before insertion into the\nDocument.  The structure that was removed to do the replacement will have\nall the IDs within it released.\n\n    functions.replace = ( subtreeID, json ) ->\n        if ( subtree = lookupID subtreeID )? and \\\n           ( isInTheDocument subtree ) and subtree isnt LDEDocument and \\\n           ( newInstance = Structure.fromJSON( json ).setup() )?\n            subtree.replaceWith newInstance\n            releaseAllIDs subtree\n            trackExternalIDs newInstance\n            stopTrackingExternalIDs subtree\n\nThe following function finds the descendant of the global LDE Document that\nhas the given ID and, assuming such a structure exists, calls its member\nfunction for setting an external attribute with the given key and value.  As\nper the requirements of the `Structure.setExternalAttribute` function, be\nsure to provide only values that are amenable to `JSON.stringify`.\n\n    functions.setAttribute = ( subtreeID, key, value ) ->\n        if ( subtree = lookupID subtreeID )? and \\\n           isInTheDocument subtree\n            if key is 'ID' then stopTrackingExternalIDs subtree, no\n            subtree.setExternalAttribute key, value\n            if key is 'ID' then trackExternalIDs subtree, no\n\n## Event Listeners\n\nIf the LDE detects that it is being run in a background thread, it will set\nup listeners for messages from the parent thread.  These listeners handle\nmessages of five types:\n\n * `insert`, with three arguments, which calls the `insert` function defined\n   above and sends no messages back\n * `delete`, with one argument, which calls `delete` and sends no messages\n * `replace`, with two arguments, which calls `replace` and sends no\n   messages\n * `setAttribute`, with three arguments, which calls `setAttribute` and\n   sends no messages\n * `getDocument`, with zero arguments, which sends back a message containing\n   the JSON serialized form of the document, as fetched using the\n   `getDocument` function defined above\n\n\n    if WorkerGlobalScope? or self?.importScripts?\n\nHere are the numbers of arguments we accept for each message we accept.\n\n        expectedArgumentCount =\n            insert : 3\n            delete : 1\n            replace : 2\n            setAttribute : 3\n            getDocument : 0\n\nMessages received expect data arrays of the form `[ command, args... ]`.\n\n        self.addEventListener 'message', ( event ) ->\n            [ command, args... ] = event.data\n\nAnything with the right number of arguments is passed on to the\ncorresponding function.  That function may or may not do anything, depending\non whether the data is in the correct form.\n\n            if expectedArgumentCount[command] is args.length\n                if command is 'getDocument'\n                    self.postMessage functions.getDocument().toJSON()\n                else\n                    functions[command] args...\n\nNow export anything that needs exporting.\n\n    if exports?\n        exports.Structure = Structure\n        exports.insert = functions.insert\n        exports.delete = functions.delete\n        exports.replace = functions.replace\n        exports.setAttribute = functions.setAttribute\n        exports.getDocument = functions.getDocument\n"]}