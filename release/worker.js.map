{"version":3,"sources":["worker.litcoffee"],"names":["InnerScriptPath","LDEWorker","Worker","require","callback","this","callbacks","loadedCallbacks","setup","saveCallback","nextFreeId","hasOwnProperty","runAndClearCallback","data","id","worker","whenReady","addEventListener","_this","event","i","len","ref","type","length","isReady","push","dispatch","message","postMessage","run","codeOrFunction","code","runAsync","function","installScript","filename","installFunction","name","func","args","body","substring","indexOf","lastIndexOf","arguments","installData","jsonData","uninstallData","reboot","terminate","exports"],"mappings":"AAyBI,IAAAA,gBAAAC,UAAAC,OAAG,oBAAAC,SAAA,OAAAA,cAAiB,IAAAD,QAAA,OAAAA,OAIhBF,gBAAkB,sBAHhBE,OAAWC,QAAQ,qBAARD,OACbF,gBAAkB,8BAUhBC,UAAA,WA4CY,SAAAA,EAAEG,GACZC,KAACC,aACDD,KAACE,mBACDF,KAACG,MAAMJ,sBAxCXK,aAAe,SAAEL,GACb,IAAAM,EACA,IADAA,EAAa,EACPL,KAACC,UAAUK,eAAeD,IAAgBA,WAChDL,KAACC,UAAUI,GAAcN,EACzBM,eACJE,oBAAsB,SAAEC,GACpB,IAAAT,SAAAA,EAAWC,KAACC,UAAUO,EAAKC,WACpBT,KAACC,UAAUO,EAAKC,WAChBD,EAAKC,wBACZV,EAAUS,QAAA,eAMdL,MAAQ,SAAEJ,UACNC,KAACU,OAAS,IAAIb,OAAOF,iBACrBK,KAACW,UAAUZ,GAQXC,KAACU,OAAOE,iBAAiB,UAAW,SAAAC,UAAA,SAAEC,GAClC,IAAAC,EAAAC,EAAAC,EAAA,GAAsB,WAAnBH,EAAMN,KAAKU,KAAd,CACI,IAAAH,EAAA,EAAAC,GAAAC,EAAAJ,EAAAX,iBAAAiB,OAAAJ,EAAAC,EAAAD,aAASF,UACTA,EAACX,0BAEDW,EAACN,oBAAoBO,EAAMN,OALC,CAAAR,oBAoBxCoB,QAAU,kBAA8B,IAA3BpB,KAACE,gBAAgBiB,oBAC9BR,UAAY,SAAEZ,GACV,OAAGC,KAACoB,+BACArB,EAAUC,WAAA,EAEPD,EAAcC,KAACE,gBAAgBmB,KAAKtB,QAAvC,eAKRuB,SAAW,SAAEC,EAASxB,UAClBwB,EAAQd,GAAKT,KAACI,aAAaL,GAC3BC,KAACU,OAAOc,YAAYD,gBAcxBE,IAAM,SAAEC,EAAgB3B,SACQ,mBAAlB2B,IACNA,EAAiB,IAAIA,EAAe,OACxC1B,KAACsB,UAASJ,KAAO,MAAOS,KAAOD,GAAgB3B,gBAUnD6B,SAAW,SAAEF,EAAgB3B,SACG,mBAAlB2B,IACNA,EAAiB,IAAIA,EAAe,KACxC1B,KAACsB,UAASJ,KAAO,WAAYW,SAAWH,GAAgB3B,gBAU5D+B,cAAgB,SAAEC,EAAUhC,UACxBC,KAACsB,UACGJ,KAAO,iBACPa,SAAWA,GACbhC,gBAgBNiC,gBAAkB,SAAEC,EAAMC,EAAMnC,GAC5B,IAAAoC,EAAAC,SAAAF,EAAO,GAAGA,EACVC,EAAOD,EAAKG,UAAUH,EAAKI,QAAS,KAAQ,EACtBJ,EAAKI,QAAS,MACpCF,EAAOF,EAAKG,UAAUH,EAAKI,QAAS,KAAQ,EACtBJ,EAAKK,YAAa,MACxCvC,KAACsB,UACGJ,KAAO,mBACPe,KAAOA,EACPO,UAAYL,EACZC,KAAOA,GACTrC,gBAmBN0C,YAAc,SAAER,EAAMS,EAAU3C,UAC5BC,KAACsB,UACGJ,KAAO,eACPe,KAAOA,EACPzB,KAAOkC,GACT3C,gBAIN4C,cAAgB,SAAEV,EAAMlC,UACpBC,KAACsB,UAASJ,KAAO,iBAAkBe,KAAOA,GAAMlC,gBAUpD6C,OAAS,SAAE7C,GACP,IAAAkB,kCAAS4B,YACT7C,KAACG,MAAMJ,MAhLT,GAoLH,oBAAA+C,SAAA,OAAAA,UAAcA,QAAQlD,UAAYA","file":"worker.js","sourcesContent":["\n# Background Workers (Class Definition)\n\nThis file defines a class that encapsulates the functionality we need in the\nbackground workers the [LDE](lde.litcoffee) will use.\n * This file is intended to be imported by anyone who wishes to create\n   instance of the `Worker` class.\n * [A separate file](worker-internal.litcoffee) contains the code that will\n   be loaded into the worker's background thread to give it the\n   functionality with which this class interfaces.\n\n## Import modules\n\nImport the `Worker` class if it isn't already defined.  In the browser, it\nshould already be defined.  But in Node.js, we need to import the\n`webworker-threads` package to define it.\n\nAlso, if we're in Node.js, then we assume (for now) that we are being run\nas part of the unit tests of the LDE, from the root of the project\nrepository.  We therefore set a different path to the inner script the\nworkers need to load than we would set in the browser.\n\nLater, we will want to support Node.js-based uses of this module other than\nin the unit testing suite, and this will need to be made more flexible.\n\n    if require? and not Worker?\n        { Worker } = require 'webworker-threads'\n        InnerScriptPath = 'release/worker-internal.js'\n    else\n        InnerScriptPath = 'worker-internal.js'\n\n## Define the `LDEWorker` Class\n\nWe define a class that clients of this module can create and treat as the\nencapsulation of a background thread.  We call it `LDEWorker` because of\ncourse `Worker` is already taken in the browser namespace.\n\n    class LDEWorker\n\nWe need a simple method for associating callbacks with tasks we send to the\nworker, so we have the following functions that assign unique IDs to\ncallbacks when asked, retrieve such callbacks by their ID, and delete them\nwhen we're done with them.\n\n        saveCallback : ( callback ) ->\n            nextFreeId = 0\n            while @callbacks.hasOwnProperty nextFreeId then nextFreeId++\n            @callbacks[nextFreeId] = callback\n            nextFreeId\n        runAndClearCallback : ( data ) ->\n            callback = @callbacks[data.id]\n            delete @callbacks[data.id]\n            delete data.id\n            callback? data\n\nWe leverage the above two routines in the event handler for the internal\n`Worker` object, installed by the following routine.  The callback will\nreceive this worker as its one parameter.\n\n        setup : ( callback ) ->\n            @worker = new Worker InnerScriptPath\n            @whenReady callback\n\nThis event handler is for all messages coming out of the worker.  We\nguarantee, in the worker's code, that every response message that comes back\nwill contain the same ID that was given in the request for which it is the\nresponse.  This allows us to look up and call the correct callback, then\nuninstall that callback because the task is complete.\n\n            @worker.addEventListener 'message', ( event ) =>\n                if event.data.type is 'loaded'\n                    callback @ for callback in @loadedCallbacks\n                    @loadedCallbacks = [ ]\n                else\n                    @runAndClearCallback event.data\n\nThe parameter to the constructor is optional, and if provided, will be\ncalled when the worker has finished loading its internal scripts and is\nready to receive commands.  We leverage the `setup` function defined above\nto do setup of the internal `Worker` object.\n\n        constructor : ( callback ) ->\n            @callbacks = { }\n            @loadedCallbacks = [ ]\n            @setup callback\n\nClients can tell whether the worker is ready to receive messages with the\nfollowing function.\n\n        isReady : -> @loadedCallbacks.length is 0\n        whenReady : ( callback ) ->\n            if @isReady()\n                callback? @\n            else\n                if callback then @loadedCallbacks.push callback\n\nThe following function abstracts the idea of sending a message to the worker\nand associating a callback with it.\n\n        dispatch : ( message, callback ) ->\n            message.id = @saveCallback callback\n            @worker.postMessage message\n\n### Running code in a worker\n\nThe chief purpose of background threads is to run code and then notify you\nwhen it's done, and what the result was.  We provide the following API for\ndoing so.  It is essentially a simple `eval` call in the worker, with all\nthe appropriate caveats that come with that.\n\nThe first argument can be a string of code or a JavaScript function.  If it\nis the latter, realize that it will be converted to a string and transferred\ninto the worker before being run, so global variables in it will be\nevaluated in the worker's context.\n\n        run : ( codeOrFunction, callback ) ->\n            if typeof codeOrFunction is 'function'\n                codeOrFunction = \"(#{codeOrFunction})()\"\n            @dispatch type : 'run', code : codeOrFunction, callback\n\nBut if you wish to run an asynchronous function, use the following instead.\nProvide either a function that takes as parameter a callback with the\nstandard result-and-error signature (which it calls upon completing its work\nor encountering an error, making only one of the parameters non-null) or a\nstring of code that defines such a function.  As with the previous, your\ncallback will be called with a message of the same format when the work is\ncomplete.\n\n        runAsync : ( codeOrFunction, callback ) ->\n            if typeof codeOrFunction is 'function'\n                codeOrFunction = \"(#{codeOrFunction})\"\n            @dispatch type : 'runAsync', function : codeOrFunction, callback\n\n### Support installing scripts\n\n`Worker` instances support installing scripts in the worker.  Simply call\nthe following method and the appropriate message is passed to the worker.\nIt knows how to respond by calling its built-in `importScripts` function.\nThe optional callback is called when the action completes, with an object\ncontaining a few fields describing the action taken.\n\n        installScript : ( filename, callback ) ->\n            @dispatch\n                type : 'install script'\n                filename : filename\n            , callback\n\n### Support installing functions\n\nIf you have your own function in the main thread, and want it installed in a\nworker, you can call this function to put it there.  But remember that it is\ngoing to be copied over based on its syntax, not as a closure.  Any global\nvariables mentioned in the function will have meaning in the worker's\ncontext, not the main thread's.\n\nThe first parameter is the global variable name to use for the function, in\nthe worker's context.  The second parameter should be a function, which will\nbe dissected into its argument list and body on this side, those transmitted\nto the worker, and the function contructor used on that side to reassemble\nit into a function.  This is faster and safer than `eval`.\n\n        installFunction : ( name, func, callback ) ->\n            func = \"#{func}\"\n            args = func.substring func.indexOf( '(' ) + 1,\n                                  func.indexOf( ')' )\n            body = func.substring func.indexOf( '{' ) + 1,\n                                  func.lastIndexOf( '}' )\n            @dispatch\n                type : 'install function'\n                name : name,\n                arguments : args\n                body : body\n            , callback\n\n### Support installing data\n\nNaturally, users of workers will want not only to install functions in the\nworkers, but also sometimes pass nontrivial amounts of data to those\nfunctions.  Rather than pass it as literals inside code passed to the `run`\nfunction, it is better if we have a utility for copying chunks of JSON data\ninto a global variable in the worker.  This is especially useful if the\nworker is to operate on the same data repeatedly, or to modify the data in\nphases.\n\nWe thus provide the following function.  The data you provide must be JSON,\nhence the parameter name.  It will be stored in the global variable\n`globalData` in the worker, under the key you provide.  Essentially, a\n`globalData[yourKey] = yourJSONData` statement will be executed in the\nworker.  You can thus make calls later that look up this stored data using\n`globalData[yourKey]` in the code.\n\n        installData : ( name, jsonData, callback ) ->\n            @dispatch\n                type : 'install data'\n                name : name,\n                data : jsonData\n            , callback\n\nYou can also clear out such stored data using this:\n\n        uninstallData : ( name, callback ) ->\n            @dispatch type : 'uninstall data', name : name, callback\n\n### Support rebooting workers\n\nIf you want to start with a fresh worker (perhaps because you don't want it\nto have any longer some of the scripts you loaded or because it's gone on\ntoo long computing something and you need to terminate it), use this\nfunction.  It terminates the internal Worker object and replaces it with a\nfresh one, calling the callback when this process is complete.\n\n        reboot : ( callback ) ->\n            @worker?.terminate()\n            @setup callback\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports? then exports.LDEWorker = LDEWorker\n"]}