{"version":3,"sources":["output-structure.litcoffee"],"names":["InputStructure","OutputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","IS","len","ref","apply","arguments","markDirty","subclasses","instancesBeingInterpreted","length","origin","className","addSubclass","yesOrNo","dirty","addConnectionOrigin","source","target","data","_origin","id","feedback","feedbackData","hasLabel","label","lookUpIn","accessibles","candidate","i","len1","slice","reverse","lookUp","firstAccessible","lookUpAll","allAccessibles","lookUpAllCitations","cited","connection","j","k","l","labels","len2","len3","len4","ref1","ref2","result","type","premises","connections","reasons","getConnectionsOut","getConnectionData","getConnectionTarget","push","getAttribute","Array","justChanged","base","instanceJustChanged","exports"],"mappings":"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","file":"output-structure.js","sourcesContent":["\n# Output Structures\n\nThe LDE module constructs, for its internal use, a hierarchy of\n`OutputStructure` instances called the Output Tree.  The word \"output\" is\nused because it is the output of an interpretation process defined\nthroughout the subclasses of `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`InputStructure` instances.  In short, these support validation while\n`InputStructure`s support interpretation.  You can also think of the\ndifference as this:  `InputStructure`s represent the syntax of what the user\nhas expressed to the client, and `OutputStructure`s represent the semantics\ninto which we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n        { InputStructure } = require './input-structure'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n            importScripts 'input-structure.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n            importScripts 'release/input-structure.js'\n\n## Define the `OutputStructure` class\n\n    class OutputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputStructure', OutputStructure\n\nMarking an `OutputStructure` dirty, unlike with `InputStructure`s, does not\npropagate up the ancestor chain.  Thus we define the following function\nanalogous to the one in the `InputStructure` class, but without the\nrecursive propagation.\n\n        markDirty : ( yesOrNo = yes ) -> @dirty = yesOrNo\n\nA newly constructed instance should be considered dirty (because it probably\njust changed and thus may need to be validated).  It should also record the\n`InputStructure` instance that gave rise to it, if indeed this construction\nhappend as part of interpretation.\n\n        constructor : ->\n            super arguments...\n            @markDirty()\n            IS = Structure::subclasses.InputStructure\n            if len = IS::instancesBeingInterpreted?.length\n                @origin = IS::instancesBeingInterpreted[len-1]\n\nSimilar to tracking origins for `OutputStructure` nodes, if a connection is\nformed between `OutputStructure` instances, we will want to track its origin\nin the sense of which `InputStructure` was being interpreted when the\nconnection was formed.\n\n        addConnectionOrigin : ( source, target, data ) ->\n            IS = Structure::subclasses.InputStructure\n            if ( target instanceof OutputStructure ) and \\\n               ( len = IS::instancesBeingInterpreted?.length )\n                data._origin = IS::instancesBeingInterpreted[len-1].id()\n\n## Feedback\n\nTo give feedback about a particular `OutputStructure` instance, find the\n`InputStructure` instance that created this `OutputStructure` and if there\nis such a thing, call the `feedback` method in it.  (That will delegate the\nwork further, but that is not our concern here.)\n\n        feedback : ( feedbackData ) -> @origin?.feedback feedbackData\n\n## Labels\n\n`OutputStructure`s can be labeled.  This is implemented by a function that\ntakes a string as input and returns true or false, whether the structure has\nthat label.  This permits a lot of freedom in how we match labels to\nstructures, including case sensitivity, punctuation sensitivity, multiple\nlabels, and so on.  By default, however, everything is unlabeled, so the\nbase implementation is as follows.\n\n        hasLabel : ( label ) -> no\n\nWe can look back through a list of all the `OutputStructure`s accessible to\na given one, seeking the first one that admits to having a given label, by\nuse of the `hasLabel()` function on each accessible structure.  We implement\nthat generically with the following class method, then make a shortcut for\nuse by instances below.  Here we assume that the accessibles array is given\nin the order in which the nodes appear in the tree\n(`Structure.isEarlierThan()`).\n\n        @lookUpIn : ( label, accessibles ) ->\n            for candidate in accessibles[...].reverse()\n                return candidate if candidate.hasLabel label\n            undefined\n\nWhen an instance asks to look up the nearest accessible thing with a given\nlabel, what it means is among those things accessible to that instance.\n\n        lookUp : ( label ) ->\n            @firstAccessible ( candidate ) -> candidate.hasLabel label\n\nWhen an instance asks to look up all accessible things with a given label,\nthey are still returned in the order in which they are encountered when\ntraversing the list of accessibles.\n\n        lookUpAll : ( label ) ->\n            @allAccessibles ( candidate ) -> candidate.hasLabel label\n\n## Citations\n\nObeying the conventions set down by interpretation, as defined in\n[the InputStructure class](input-structure.litcoffee#citations), we provide\nthe following function to look up all structures cited by this one.  The\nnotion of \"looking them up\" here means finding the targets that are cited by\nthe data stored in this object and creating a dictionary mapping the means\nof citation to the structures cited.\n\nWe respect the following citation conventions set down by the\n`InputStructure` class linked to in the previous paragraph:\n * The \"premise citations\" and \"reason citations\" attributes will each map\n   to a list of strings, each of which attempts to cite something by label.\n * Connections out of this node whose JSON data contains the key-value pair\n   (\"type\",\"premise citation\") or (\"type\",\"reason citation\") are each\n   interpreted as a citation.\n\nThis routine does not actually call `lookUp()`, defined above, because to do\nso repeatedly would be inefficient, traversing the accessibles list\npotentially many times.  Rather, we traverse it just once, asking about\nmultiple label matches at each stop.\n\nThe form of the result will be a JSON structure with this format:\n```javascript\n{\n    premises : { // citations of premises go in here\n        connections : [ // citations by connection go in here\n            {\n                cited : \"id of target structure\",\n                id : \"id of connection, so you can get its data later\"\n            }\n            // zero or more such objects in this array\n        ],\n        labels : [ // citations by label go in here\n            {\n                cited : \"id of cited structure\",\n                label : \"text of label by which it was cited\"\n            }\n            // zero or more such objects in this array\n        ]\n    },\n    reasons : {\n        // same structure as premises object above\n    }\n}\n```\n\n        lookUpAllCitations : ->\n\nInitialize the data structure we will return, empty at first.\n\n            result =\n                premises :\n                    connections : [ ]\n                    labels : [ ]\n                reasons :\n                    connections : [ ]\n                    labels : [ ]\n\nFill both connections arrays by examining all connections out of this\nstructure for their types.\n\n            for connection in @getConnectionsOut()\n                data = @getConnectionData connection\n                for type in [ 'premise', 'reason' ]\n                    if data.type is \"#{type} citation\" and\n                       ( target = @getConnectionTarget connection )?\n                        result[\"#{type}s\"].connections.push\n                            cited : target.id()\n                            id : connection\n\nFill both labels arrays by examining the relevant attributes of this\nstructure.\n\n            for type in [ 'premise', 'reason' ]\n                if ( labels = @getAttribute \"#{type} citations\" ) and \\\n                   labels instanceof Array\n                    for label in labels\n                        if ( cited = @lookUp label )?\n                            result[\"#{type}s\"].labels.push\n                                cited : cited.id()\n                                label : label\n\nReturn the result.\n\n            result\n\n## Handling change events\n\nWhen interpretation has completed, the `justChanged()` function will be\ncalled in every structure in the Output Tree has been updated during that\ninterpretation phase.  We provide the following default implementation for\n`justChanged()` that will defer the work to the class method\n`instanceJustChanged` if and only if that class method exists.  It doesn't\nyet exist, so this is ineffective unless some later code installs just such\na class method.\n\nThe reason for this is that the actual implementation we want to provide\ndepends upon some global data structures in the LDE to which this module\ndoes not have access.  When the LDE loads this module, it can fill in the\nmissing class method with the appropriate implementation, which accesses its\nown internals.\n\n        justChanged : -> OutputStructure::instanceJustChanged? @\n\n## Exports\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports? then exports.OutputStructure = OutputStructure\n"]}