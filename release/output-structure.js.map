{"version":3,"sources":["output-structure.litcoffee"],"names":["InputStructure","OM","OutputExpression","OutputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","IS","len","ref","apply","arguments","markDirty","subclasses","instancesBeingInterpreted","length","origin","className","addSubclass","yesOrNo","dirty","addConnectionOrigin","source","target","data","_origin","id","feedback","feedbackData","hasLabel","label","lookUpIn","accessibles","candidate","j","len1","slice","reverse","lookUp","firstAccessible","lookUpAll","allAccessibles","lookUpAllCitations","cited","connection","k","l","labels","len2","len3","len4","m","ref1","ref2","result","type","premises","connections","reasons","getConnectionsOut","getConnectionData","getConnectionTarget","push","getAttribute","Array","justChanged","base","instanceJustChanged","children","rest","varIndices","indexOf","split","atomicData","boundVariables","toOpenMath","body","childResults","head","i","notVarIndices","vars","results","func","args","bin","concat","fromOpenMath","node","value","name","cd","uri","exports"],"mappings":"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","file":"output-structure.js","sourcesContent":["\n# Output Structures\n\nThe LDE module constructs, for its internal use, a hierarchy of\n`OutputStructure` instances called the Output Tree.  The word \"output\" is\nused because it is the output of an interpretation process defined\nthroughout the subclasses of `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`InputStructure` instances.  In short, these support validation while\n`InputStructure`s support interpretation.  You can also think of the\ndifference as this:  `InputStructure`s represent the syntax of what the user\nhas expressed to the client, and `OutputStructure`s represent the semantics\ninto which we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n        { InputStructure } = require './input-structure'\n        { OM } = require 'openmath-js'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n            importScripts 'input-structure.js'\n            importScripts 'openmath.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n            importScripts 'release/input-structure.js'\n            importScripts 'node_modules/openmath-js/openmath.js'\n\n## Define the `OutputStructure` class\n\n    class OutputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputStructure', OutputStructure\n\nMarking an `OutputStructure` dirty, unlike with `InputStructure`s, does not\npropagate up the ancestor chain.  Thus we define the following function\nanalogous to the one in the `InputStructure` class, but without the\nrecursive propagation.\n\n        markDirty : ( yesOrNo = yes ) -> @dirty = yesOrNo\n\nA newly constructed instance should be considered dirty (because it probably\njust changed and thus may need to be validated).  It should also record the\n`InputStructure` instance that gave rise to it, if indeed this construction\nhappend as part of interpretation.\n\n        constructor : ->\n            super arguments...\n            @markDirty()\n            IS = Structure::subclasses.InputStructure\n            if len = IS::instancesBeingInterpreted?.length\n                @origin = IS::instancesBeingInterpreted[len-1]\n\nSimilar to tracking origins for `OutputStructure` nodes, if a connection is\nformed between `OutputStructure` instances, we will want to track its origin\nin the sense of which `InputStructure` was being interpreted when the\nconnection was formed.\n\n        addConnectionOrigin : ( source, target, data ) ->\n            IS = Structure::subclasses.InputStructure\n            if ( target instanceof OutputStructure ) and \\\n               ( len = IS::instancesBeingInterpreted?.length )\n                data._origin = IS::instancesBeingInterpreted[len-1].id()\n\n## Feedback\n\nTo give feedback about a particular `OutputStructure` instance, find the\n`InputStructure` instance that created this `OutputStructure` and if there\nis such a thing, call the `feedback` method in it.  (That will delegate the\nwork further, but that is not our concern here.)\n\n        feedback : ( feedbackData ) -> @origin?.feedback feedbackData\n\n## Labels\n\n`OutputStructure`s can be labeled.  This is implemented by a function that\ntakes a string as input and returns true or false, whether the structure has\nthat label.  This permits a lot of freedom in how we match labels to\nstructures, including case sensitivity, punctuation sensitivity, multiple\nlabels, and so on.  By default, however, everything is unlabeled, so the\nbase implementation is as follows.\n\n        hasLabel : ( label ) -> no\n\nWe can look back through a list of all the `OutputStructure`s accessible to\na given one, seeking the first one that admits to having a given label, by\nuse of the `hasLabel()` function on each accessible structure.  We implement\nthat generically with the following class method, then make a shortcut for\nuse by instances below.  Here we assume that the accessibles array is given\nin the order in which the nodes appear in the tree\n(`Structure.isEarlierThan()`).\n\n        @lookUpIn : ( label, accessibles ) ->\n            for candidate in accessibles[...].reverse()\n                return candidate if candidate.hasLabel label\n            undefined\n\nWhen an instance asks to look up the nearest accessible thing with a given\nlabel, what it means is among those things accessible to that instance.\n\n        lookUp : ( label ) ->\n            @firstAccessible ( candidate ) -> candidate.hasLabel label\n\nWhen an instance asks to look up all accessible things with a given label,\nthey are still returned in the order in which they are encountered when\ntraversing the list of accessibles.\n\n        lookUpAll : ( label ) ->\n            @allAccessibles ( candidate ) -> candidate.hasLabel label\n\n## Citations\n\nObeying the conventions set down by interpretation, as defined in\n[the InputStructure class](input-structure.litcoffee#citations), we provide\nthe following function to look up all structures cited by this one.  The\nnotion of \"looking them up\" here means finding the targets that are cited by\nthe data stored in this object and creating a dictionary mapping the means\nof citation to the structures cited.\n\nWe respect the following citation conventions set down by the\n`InputStructure` class linked to in the previous paragraph:\n * The \"premise citations\" and \"reason citations\" attributes will each map\n   to a list of strings, each of which attempts to cite something by label.\n * Connections out of this node whose JSON data contains the key-value pair\n   (\"type\",\"premise citation\") or (\"type\",\"reason citation\") are each\n   interpreted as a citation.\n\nThis routine does not actually call `lookUp()`, defined above, because to do\nso repeatedly would be inefficient, traversing the accessibles list\npotentially many times.  Rather, we traverse it just once, asking about\nmultiple label matches at each stop.\n\nThe form of the result will be a JSON structure with this format:\n```javascript\n{\n    premises : { // citations of premises go in here\n        connections : [ // citations by connection go in here\n            {\n                cited : \"id of target structure\",\n                id : \"id of connection, so you can get its data later\"\n            }\n            // zero or more such objects in this array\n        ],\n        labels : [ // citations by label go in here\n            {\n                cited : \"id of cited structure\",\n                label : \"text of label by which it was cited\"\n            }\n            // zero or more such objects in this array\n        ]\n    },\n    reasons : {\n        // same structure as premises object above\n    }\n}\n```\n\n        lookUpAllCitations : ->\n\nInitialize the data structure we will return, empty at first.\n\n            result =\n                premises :\n                    connections : [ ]\n                    labels : [ ]\n                reasons :\n                    connections : [ ]\n                    labels : [ ]\n\nFill both connections arrays by examining all connections out of this\nstructure for their types.\n\n            for connection in @getConnectionsOut()\n                data = @getConnectionData connection\n                for type in [ 'premise', 'reason' ]\n                    if data?.type is \"#{type} citation\" and\n                       ( target = @getConnectionTarget connection )?\n                        result[\"#{type}s\"].connections.push\n                            cited : target.id()\n                            id : connection\n\nFill both labels arrays by examining the relevant attributes of this\nstructure.\n\n            for type in [ 'premise', 'reason' ]\n                if ( labels = @getAttribute \"#{type} citations\" ) and \\\n                   labels instanceof Array\n                    for label in labels\n                        if ( cited = @lookUp label )?\n                            result[\"#{type}s\"].labels.push\n                                cited : cited.id()\n                                label : label\n\nReturn the result.\n\n            result\n\n## Handling change events\n\nWhen interpretation has completed, the `justChanged()` function will be\ncalled in every structure in the Output Tree has been updated during that\ninterpretation phase.  We provide the following default implementation for\n`justChanged()` that will defer the work to the class method\n`instanceJustChanged` if and only if that class method exists.  It doesn't\nyet exist, so this is ineffective unless some later code installs just such\na class method.\n\nThe reason for this is that the actual implementation we want to provide\ndepends upon some global data structures in the LDE to which this module\ndoes not have access.  When the LDE loads this module, it can fill in the\nmissing class method with the appropriate implementation, which accesses its\nown internals.\n\n        justChanged : -> OutputStructure::instanceJustChanged? @\n\n## Define `OutputExpression` as a type of `OutputStructure`\n\nAn `OutputExpression` is the most common type of mathematics we think of\nwhen doing mathematics on a computer.  It may be a mathematical noun, such\nas 3x, or a mathematical statement, such as \"not every number is even.\"\nThese are what typically appear inside dollar signs in LaTeX documents, and\nform the majority of the content of any proof in a formal system.\n\nIn the LDE, we use OpenMath data types to store expressions.  In particular,\nwe rely on a JavaScript implementation of part of the OpenMath Standard,\n[published here](https://github.com/lurchmath/openmath-js).  Each expression\nis a tree made up of instances of the following class, each of which\ncorresponds to a node in an OpenMath tree, and there are conversion\nfunctions between the two data structures.\n\n    class OutputExpression extends OutputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputExpression',\n            OutputExpression\n\nThe constructor takes an arbitrary number of parameters.  The first is\nalways the OpenMath type that this object represents (e.g., string, integer,\nfunction application, etc.).  That type should be expressed in the\nthree-letter form used in the OpenMath module's code (e.g., \"int\", \"flo\",\n\"str\", etc., as a JavaScript string).\n\nThe remaining parameters depend on the first.\n\n * If the first parameter gives this object an OpenMath atomic type, then\n   the next should contain the atomic content (e.g., string data if this is\n   a string).  In one case (OpenMath symbol) this atomic content is spread\n   over two or three parameters: name, CD, and optional URI.\n * If the first parameter gives this object an OpenMath binding type, then\n   the second parameter should be an array of the indices of bound\n   variables, and then the third and further parameters are its children,\n   which must be `OutputExpression` instances, and will be passed to the\n   superclass's constructor.\n * In all other cases, the second and further parameters are the children,\n   and are passed on as in the previous case.\n\nIf an invalid type is passed as first parameter, we construct an OpenMath\nerror object instead, with no children and no attributes.  Any other\nconfiguration of invalid parametrs (e.g., bad binding indices) will be\naccepted, but may not convert to an OpenMath object in `toOpenMath()`.\n\nCurrently there is not any supported way to decorate an `OutputExpression`\ninstance with OpenMath attributes, though that could be added later if the\nneed arises.\n\n        constructor : ( type, rest... ) ->\n            if type in 'int flo str byt sym var'.split ' '\n                super()\n                @type = type\n                @atomicData = rest\n            else if type is 'bin'\n                [ varIndices, children... ] = rest\n                super children...\n                @type = type\n                @boundVariables = varIndices\n            else if type in 'app att err'.split ' '\n                super rest...\n                @type = type\n            else\n                super()\n                @type = 'err'\n\nWe wish to be able to extract from any `OutputExpression` instance the\nOpenMath object that it represents.  We do so with the following conversion\nfunction.  If conversion to an OpenMath object fails from an error in the\nOpenMath package, that error is not caught; clients should take care to\nform their `OutputExpression` instances correctly or use `try`/`catch`.\n\nAs stated above, attributes are not yet supported, though such support\ncould be added later.\n\n        toOpenMath : ->\n            childResults = ( child.toOpenMath() for child in @children )\n            switch @type\n                when 'int', 'flo', 'str', 'byt', 'sym', 'var'\n                    new OM[@type] @atomicData...\n                when 'app', 'att', 'err'\n                    new OM[@type] childResults...\n                when 'bin'\n                    vars = ( childResults[i] for i in @boundVariables )\n                    notVarIndices =\n                        ( i for i in [0...childResults.length] \\\n                            when i not in @boundVariables )\n                    head = childResults[notVarIndices[0]]\n                    body = childResults[notVarIndices[1]]\n                    new OM.bin head, vars..., body\n                else\n                    throw \"Not a valid OpenMath type: #{@type}\"\n\nWe also want the inverse conversion function, from `OMNode` instances (from\nthe OpenMath package) to instances of this type.  We provide that function\nas a class method here, and one should call it on an instance of the\n`OMNode` class; it will yield an instance of this class in every case,\nbecause `OMNode` instances cannot be incorrectly formed.\n\nAs stated above, attributes are not yet supported, though such support\ncould be added later.\n\n        @fromOpenMath : ( node ) ->\n            childResults = ( OutputExpression.fromOpenMath child \\\n                for child in node.children )\n            switch node.type\n                when 'i' then new OutputExpression 'int', node.value\n                when 'f' then new OutputExpression 'flo', node.value\n                when 'st' then new OutputExpression 'str', node.value\n                when 'ba' then new OutputExpression 'byt', node.value\n                when 'sy' then new OutputExpression 'sym', node.name,\n                    node.cd, node.uri\n                when 'v' then new OutputExpression 'var', node.name\n                when 'a' then new OutputExpression 'app', childResults...\n                when 'bi' then new OutputExpression 'bin',\n                    [1...childResults.length-1], childResults\n                when 'e' then new OutputExpression 'err', childResults...\n                else throw \"This should never happen - how did an\n                    OMNode instance get type #{node.type}?\"\n\nFor convenience, we install in the `OMNode` class a method for converting\ninstances to `OutputExpression` types by simply deferring the work to the\nabove function.\n\n    # OM::toOutputExpression = -> OutputExpression.fromOpenMath @\n\n## Exports\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports? then exports.OutputStructure = OutputStructure\n"]}