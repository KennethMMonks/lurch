{"version":3,"sources":["output-structure.litcoffee"],"names":["FOM","InputStructure","OM","OutputExpression","OutputRule","OutputStructure","Structure","TemplateRule","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","metavariableSymbol","self","superClass","IS","len","ref","apply","arguments","markDirty","subclasses","instancesBeingInterpreted","length","origin","enableFeedback","className","addSubclass","yesOrNo","dirty","addConnectionOrigin","source","target","data","_origin","id","feedback","feedbackData","sendingFeedback","feedbackStore","push","enable","emitAll","j","len1","hasLabel","label","lookUpIn","accessibles","candidate","slice","reverse","lookUp","firstAccessible","lookUpAll","allAccessibles","lookUpAllCitations","cited","connection","l","labels","len2","len3","len4","len5","m","n","o","ref1","ref2","ref3","result","type","premises","connections","reasons","getConnectionsOut","getConnectionData","getConnectionTarget","getAttribute","Array","justChanged","base","instanceJustChanged","rest","setAttribute","toOpenMath","withAttributes","body","childResults","head","i","indices","newKey","notVarIndices","value","vars","func","args","results1","children","indexOf","bin","concat","attributes","encodeAsIdentifier","sym","str","JSON","stringify","fromOpenMath","node","decodedKey","v","name","cd","uri","variables","symbol","tree","a","decodeIdentifier","decode","parse","error1","toOutputExpression","validateStep","step","worker","callback","validity","message","basicValidate","processNext","lastCitationLookup","_this","keptFeedback","reason","rule","components","shift","instanceWithID","missingID","lastFeedback","nonRule","buildRuleForm","citation","getRuleForm","instance","numRuleForms","premise","ruleConclusions","rulePremises","ruleType","stepToInstall","x","prems","concl","p","app","copy","index","descendantsSatisfying","d","setMetavariable","encode","setupWorker","ruleToInstall","validator","run","response","error","details","success","ie","k","nextStep","toInstall","feedbackObj","installData","stringMatches","installFunction","stringListMatches","isMetavariable","path","installScript","patterns","string","soFar","pattern","results","t","text","hasOwnProperty","strings","next","treeBasedPatternMatching","contents","expression","myMatch","globalData","nextMatch","Constraint","stringBasedPatternMatching","exports","OMNode"],"mappings":"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","file":"output-structure.js","sourcesContent":["\n# Output Structures\n\nThe LDE module constructs, for its internal use, a hierarchy of\n`OutputStructure` instances called the Output Tree.  The word \"output\" is\nused because it is the output of an interpretation process defined\nthroughout the subclasses of `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`InputStructure` instances.  In short, these support validation while\n`InputStructure`s support interpretation.  You can also think of the\ndifference as this:  `InputStructure`s represent the syntax of what the user\nhas expressed to the client, and `OutputStructure`s represent the semantics\ninto which we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n        { InputStructure } = require './input-structure'\n        { OM } = require 'openmath-js'\n        FOM = require 'first-order-matching'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n            importScripts 'input-structure.js'\n        if not WorkerGlobalScope.OM?\n            importScripts 'openmath.js'\n        if not WorkerGlobalScope.metavariableSymbol?\n            importScripts 'first-order-matching.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n            importScripts 'release/input-structure.js'\n        if not self.OM?\n            importScripts 'node_modules/openmath-js/openmath.js'\n        if not self.metavariableSymbol?\n            importScripts 'node_modules/first-order-matching/first-order-matching.js'\n\n## Define the `OutputStructure` class\n\n    class OutputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputStructure', OutputStructure\n\nMarking an `OutputStructure` dirty, unlike with `InputStructure`s, does not\npropagate up the ancestor chain.  Thus we define the following function\nanalogous to the one in the `InputStructure` class, but without the\nrecursive propagation.\n\n        markDirty : ( yesOrNo = yes ) -> @dirty = yesOrNo\n\nA newly constructed instance should be considered dirty (because it probably\njust changed and thus may need to be validated).  It should also record the\n`InputStructure` instance that gave rise to it, if indeed this construction\nhappend as part of interpretation.\n\n        constructor : ->\n            super arguments...\n            @markDirty()\n            IS = Structure::subclasses.InputStructure\n            if len = IS::instancesBeingInterpreted?.length\n                @origin = IS::instancesBeingInterpreted[len-1]\n            @enableFeedback yes, no\n\nSimilar to tracking origins for `OutputStructure` nodes, if a connection is\nformed between `OutputStructure` instances, we will want to track its origin\nin the sense of which `InputStructure` was being interpreted when the\nconnection was formed.\n\n        addConnectionOrigin : ( source, target, data ) ->\n            IS = Structure::subclasses.InputStructure\n            if ( target instanceof OutputStructure ) and \\\n               ( len = IS::instancesBeingInterpreted?.length )\n                data._origin = IS::instancesBeingInterpreted[len-1].id()\n\n## Feedback\n\nFeedback on this structure can be given by calling a single function,\n`feedback`, and passing an object with a feedback `type` field and optional\nother fields.  By default, that method finds the `InputStructure` instance\nthat created this `OutputStructure` and if there is such a thing, calls the\n`feedback` method in it.  (That will delegate the work further, but that is\nnot our concern here.)\n\nBut it is sometimes the case that we do not wish generated feedback to be\nimmediately emitted to the client.  For instance, if several different\nmethods to validate this `Structure` are being attempted in sequence, we\nmight wish to inspect all the generated feedback before deciding which\nsubset of it to emit to the client.\n\nThus we provide a function for enabling or disabling the storing of\nfeedback.  When enabled, no feedback is emitted, but it is all stored in a\n`feedbackQueue`.  At any point, that queue can be cleared, optionally\nemitting all of its contents first, using the methods below.\n\n        feedback : ( feedbackData ) ->\n            if @sendingFeedback\n                @origin?.feedback feedbackData\n            else\n                @feedbackStore.push feedbackData\n        enableFeedback : ( enable = yes, emitAll = no ) ->\n            if ( @sendingFeedback = enable ) and emitAll\n                @feedback feedbackData for feedbackData in @feedbackStore\n            @feedbackStore = [ ]\n\n## Labels\n\n`OutputStructure`s can be labeled.  This is implemented by a function that\ntakes a string as input and returns true or false, whether the structure has\nthat label.  This permits a lot of freedom in how we match labels to\nstructures, including case sensitivity, punctuation sensitivity, multiple\nlabels, and so on.  By default, however, everything is unlabeled, so the\nbase implementation is as follows.\n\n        hasLabel : ( label ) -> no\n\nWe can look back through a list of all the `OutputStructure`s accessible to\na given one, seeking the first one that admits to having a given label, by\nuse of the `hasLabel()` function on each accessible structure.  We implement\nthat generically with the following class method, then make a shortcut for\nuse by instances below.  Here we assume that the accessibles array is given\nin the order in which the nodes appear in the tree\n(`Structure.isEarlierThan()`).\n\n        @lookUpIn : ( label, accessibles ) ->\n            for candidate in accessibles[...].reverse()\n                return candidate if candidate.hasLabel label\n            undefined\n\nWhen an instance asks to look up the nearest accessible thing with a given\nlabel, what it means is among those things accessible to that instance.\n\n        lookUp : ( label ) ->\n            @firstAccessible ( candidate ) -> candidate.hasLabel label\n\nWhen an instance asks to look up all accessible things with a given label,\nthey are still returned in the order in which they are encountered when\ntraversing the list of accessibles.\n\n        lookUpAll : ( label ) ->\n            @allAccessibles ( candidate ) -> candidate.hasLabel label\n\n## Citations\n\nObeying the conventions set down by interpretation, as defined in\n[the InputStructure class](input-structure.litcoffee#citations), we provide\nthe following function to look up all structures cited by this one.  The\nnotion of \"looking them up\" here means finding the targets that are cited by\nthe data stored in this object and creating a dictionary mapping the means\nof citation to the structures cited.\n\nWe respect the following citation conventions set down by the\n`InputStructure` class linked to in the previous paragraph:\n * The \"premise citations\" and \"reason citations\" attributes will each map\n   to a list of strings, each of which attempts to cite something by label.\n * Connections out of this node whose JSON data contains the key-value pair\n   (\"type\",\"premise citation\") or (\"type\",\"reason citation\") are each\n   interpreted as a citation.\n\nThe form of the result will be a JSON structure with this format:\n```javascript\n{\n    premises : { // citations of premises go in here\n        connections : [ // citations by connection go in here\n            {\n                cited : \"id of target structure\",\n                id : \"id of connection, so you can get its data later\"\n            }\n            // zero or more such objects in this array\n        ],\n        labels : [ // citations by label go in here\n            {\n                cited : \"id of cited structure\",\n                label : \"text of label by which it was cited\"\n            }\n            // zero or more such objects in this array\n        ]\n    },\n    reasons : {\n        // same structure as premises object above\n    }\n}\n```\n\n        lookUpAllCitations : ->\n\nInitialize the data structure we will return, empty at first.\n\n            result =\n                premises :\n                    connections : [ ]\n                    labels : [ ]\n                reasons :\n                    connections : [ ]\n                    labels : [ ]\n\nFill both connections arrays by examining all connections out of this\nstructure for their types.\n\n            for connection in @getConnectionsOut()\n                data = @getConnectionData connection\n                for type in [ 'premise', 'reason' ]\n                    if data?.type is \"#{type} citation\" and\n                       ( target = @getConnectionTarget connection )?\n                        result[\"#{type}s\"].connections.push\n                            cited : target.id()\n                            id : connection\n\nFill both labels arrays by examining the relevant attributes of this\nstructure.\n\n            for type in [ 'premise', 'reason' ]\n                if ( labels = @getAttribute \"#{type} citations\" ) and \\\n                   labels instanceof Array\n                    for label in labels\n                        for cited in @lookUpAll( label ).reverse()\n                            result[\"#{type}s\"].labels.push\n                                cited : cited.id()\n                                label : label\n\nReturn the result.\n\n            result\n\n## Handling change events\n\nWhen interpretation has completed, the `justChanged()` function will be\ncalled in every structure in the Output Tree has been updated during that\ninterpretation phase.  We provide the following default implementation for\n`justChanged()` that will defer the work to the class method\n`instanceJustChanged` if and only if that class method exists.  It doesn't\nyet exist, so this is ineffective unless some later code installs just such\na class method.\n\nThe reason for this is that the actual implementation we want to provide\ndepends upon some global data structures in the LDE to which this module\ndoes not have access.  When the LDE loads this module, it can fill in the\nmissing class method with the appropriate implementation, which accesses its\nown internals.\n\n        justChanged : -> OutputStructure::instanceJustChanged? @\n\n## Define `OutputExpression` as a type of `OutputStructure`\n\nAn `OutputExpression` is the most common type of mathematics we think of\nwhen doing mathematics on a computer.  It may be a mathematical noun, such\nas 3x, or a mathematical statement, such as \"not every number is even.\"\nThese are what typically appear inside dollar signs in LaTeX documents, and\nform the majority of the content of any proof in a formal system.\n\nIn the LDE, we use OpenMath data types to store expressions.  In particular,\nwe rely on a JavaScript implementation of part of the OpenMath Standard,\n[published here](https://github.com/lurchmath/openmath-js).  Each expression\nis a tree made up of instances of the following class, each of which\ncorresponds to a node in an OpenMath tree, and there are conversion\nfunctions between the two data structures.\n\n    class OutputExpression extends OutputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputExpression',\n            OutputExpression\n\nThe constructor takes an arbitrary number of parameters.  The first is\nalways the OpenMath type that this object represents (e.g., string, integer,\nfunction application, etc.).  That type should be expressed in the\nthree-letter form used in the OpenMath module's code (e.g., \"int\", \"flo\",\n\"str\", etc., as a JavaScript string).\n\nThe remaining parameters depend on the first.\n\n * If the first parameter gives this object an OpenMath atomic type, then\n   the next should contain the atomic content (e.g., string data if this is\n   a string).  In one case (OpenMath symbol) this atomic content is spread\n   over two or three parameters: name, CD, and optional URI.\n * If the first parameter gives this object an OpenMath binding type, then\n   the second parameter should be an array of the indices of bound\n   variables, and then the third and further parameters are its children,\n   which must be `OutputExpression` instances, and will be passed to the\n   superclass's constructor.\n * In all other cases, the second and further parameters are the children,\n   and are passed on as in the previous case.\n\nIf an invalid type is passed as first parameter, we construct an OpenMath\nerror object instead, with no children and no attributes.  Any other\nconfiguration of invalid parametrs (e.g., bad binding indices) will be\naccepted, but may not convert to an OpenMath object in `toOpenMath()`.\nNote that an error object constructed that way will not correctly convert\nto an OpenMath object, because it has not head symbol.\n\n        constructor : ( type, rest... ) ->\n            switch type\n                when 'int', 'flo', 'str', 'byt', 'var'\n                    super()\n                    @setAttribute 'OM type', type\n                    @setAttribute 'OM atomic value', rest[0]\n                when 'sym'\n                    super()\n                    @setAttribute 'OM type', type\n                    @setAttribute 'OM atomic value', rest\n                when 'bin'\n                    super rest[1..]...\n                    @setAttribute 'OM type', type\n                    @setAttribute 'OM bound indices', rest[0]\n                when 'app', 'err'\n                    super rest...\n                    @setAttribute 'OM type', type\n                else\n                    super()\n                    @setAttribute 'OM type', 'err'\n\nWe wish to be able to extract from any `OutputExpression` instance the\nOpenMath object that it represents.  We do so with the following conversion\nfunction.  If conversion to an OpenMath object fails from an error in the\nOpenMath package, that error is not caught; clients should take care to\nform their `OutputExpression` instances correctly or use `try`/`catch`.\n\nAttributes whose keys do not begin with an underscore, and are not \"id\" will\nbe added to the resulting OpenMath object.  Because all OpenMath attributes\nmust have values that are OpenMath objects, we convert the `Structure`\nattribute to JSON and embed it in an OpenMath string.  By default,\nattributes are not included; you can include them with the parameter.\n\n        toOpenMath : ( withAttributes = no ) ->\n            result = switch type = @getAttribute 'OM type'\n                when 'int', 'flo', 'str', 'byt', 'var'\n                    new OM[type] @getAttribute 'OM atomic value'\n                when 'sym'\n                    new OM[type] @getAttribute( 'OM atomic value' )...\n                when 'app', 'err'\n                    childResults = ( child.toOpenMath withAttributes \\\n                        for child in @children() )\n                    new OM[type] childResults...\n                when 'bin'\n                    indices = @getAttribute 'OM bound indices'\n                    vars = for i in indices\n                        OM.var @children()[i].getAttribute 'OM atomic value'\n                    notVarIndices = ( i for i in [0...@children().length] \\\n                        when i not in indices )\n                    head = @children()[notVarIndices[0]].toOpenMath \\\n                        withAttributes\n                    body = @children()[notVarIndices[1]].toOpenMath \\\n                        withAttributes\n                    new OM.bin head, vars..., body\n                else\n                    throw \"Not a valid OpenMath type: #{type}\"\n            if withAttributes\n                for own key, value of @attributes\n                    if key not in [ 'id', 'OM type', 'OM atomic value', \\\n                            'OM bound indices' ] and key[0] isnt '_'\n                        newKey = OM.encodeAsIdentifier key\n                        result.setAttribute OM.sym( newKey, 'Lurch' ),\n                            OM.str JSON.stringify [ value ]\n            result\n\nWe also want the inverse conversion function, from `OMNode` instances (from\nthe OpenMath package) to instances of this type.  We provide that function\nas a class method here, and one should call it on an instance of the\n`OMNode` class; it will yield an instance of this class in every case,\nbecause `OMNode` instances cannot be incorrectly formed.\n\nIt inverts the attribute encoding described above the previous function.\n\n        @fromOpenMath : ( node, withAttributes = no ) ->\n            childResults = ( OutputExpression.fromOpenMath( child,\n                withAttributes ) for child in node.children )\n            result = switch node.type\n                when 'i' then new OutputExpression 'int', node.value\n                when 'f' then new OutputExpression 'flo', node.value\n                when 'st' then new OutputExpression 'str', node.value\n                when 'ba' then new OutputExpression 'byt', node.value\n                when 'sy' then new OutputExpression 'sym', node.name,\n                    node.cd, node.uri\n                when 'v' then new OutputExpression 'var', node.name\n                when 'a' then new OutputExpression 'app', childResults...\n                when 'bi'\n                    vars = ( new OutputExpression 'var', v.name \\\n                        for v in node.variables )\n                    head = OutputExpression.fromOpenMath node.symbol,\n                        withAttributes\n                    body = OutputExpression.fromOpenMath node.body,\n                        withAttributes\n                    new OutputExpression 'bin', [1...childResults.length],\n                        head, vars..., body\n                when 'e' then new OutputExpression 'err',\n                    OutputExpression.fromOpenMath( node.symbol,\n                        withAttributes ), childResults...\n                else throw \"This should never happen - how did an\n                    OMNode instance get type #{node.type}?\"\n            if withAttributes\n                for own key, value of node.tree.a\n                    try\n                        decodedKey = OM.decodeIdentifier \\\n                            OM.decode( key ).name\n                        result.setAttribute decodedKey,\n                            JSON.parse( value.v )[0]\n            result\n\nFor convenience, we install in the `OMNode` class a method for converting\ninstances to `OutputExpression` types by simply deferring the work to the\nabove function.\n\n    OM::toOutputExpression = ( withAttributes ) ->\n        OutputExpression.fromOpenMath @, withAttributes\n\n## Define `OutputRule` as a type of `OutputStructure`\n\nAn `OutputRule` is a member of the Output Tree that has a function\n`validateStep()` that can be called on a step of work to validate it.  As\ndocumented\n[elsewhere](https://lurchmath.github.io/lde/site/api-phases/#validation),\na step `S` is normally validated by calling `S.validate(worker,callback)`,\nbut in the case when the step cites a rule, that function will typically\nwant to delegate the work to the rule itself, so that we can support rules\nwith arbitrary decision procedures within an object-oriented framework.\n\n    class OutputRule extends OutputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputRule', OutputRule\n\nThe `validateStep()` function takes three parameters: the step to validate\nand the `worker` and `callback` functions that were given to its `validate`\nroutine.  The `worker` can be used to do any lengthy tasks in the\nbackground and the `callback` should naturally be called to indicate when\nthe task is complete (passing no arguments).\n\nThe default implementation just produces feedback saying that no real\nvalidation was done, and then calls the callback.  Naturally, subclasses\nthat do real work will want to override this default.\n\n        validateStep : ( step, worker, callback ) ->\n            step.feedback\n                type : 'validation result'\n                validity : 'indeterminate'\n                message : 'No real validation was performed.'\n            callback()\n\nWe also provide a class member that can be copied out of this class and into\n`OutputExpression` instances as their validate routine.  This routine just\ndelegates validation to the cited rule.  If there is any non-`OutputRule`\ninstance cited as a reason, the step is judged invalid.  If there is more\nthan one `OutputRule` step cited as a reason, then this routine checks each\nin turn to see if any will validate the step.  If not, then the resulting\nnegative feedback includes a `phases` field containing all the feedback\nobjects generated by all the cited rules.\n\n        @basicValidate : ( worker, callback ) ->\n\nDisable feedback emission, because we will want to inspect the feedback\ngenerated instead of just immediately sending it out.  Compute the list of\ncited reasons.\n\nNote that throughout this routine, the `this` object is assumed to be a step\nof work, because this function is designed to be installed in such objects\nas their `validate` routine.\n\n            @enableFeedback no\n            reasons = @lastCitationLookup.reasons\n            reasons = reasons.connections.concat reasons.labels\n\nWe process each cited reason asynchronously, using a function that calls\nitself recursively in callbacks.\n\n            do processNext = =>\n\nThe base csae is when we've finished processing all reasons.  This may be\nbecause there weren't any, in which case we do nothing, or because all of\nthem said the step was invalid, in which case we combine them into a single\nfeedback message, which we emit.\n\n                if reasons.length is 0\n                    keptFeedback = @feedbackStore\n                    @enableFeedback yes, no\n                    if keptFeedback.length > 1\n                        @feedback\n                            type : 'validation result'\n                            validity : 'invalid'\n                            components : keptFeedback\n                    else if keptFeedback.length is 1\n                        @feedback keptFeedback[0]\n                    return callback()\n\nThere remain reasons to process, so get the next one.  If we can't seem to\nfind it by its ID, then some internal error has happened, because that's not\nsupposed to ever happen.  Report it just in case and stop validation\nentirely in that case.\n\n                reason = reasons.shift()\n                if not ( rule = Structure.instanceWithID reason.cited )?\n                    @enableFeedback yes, no\n                    @feedback\n                        type : 'validation result'\n                        validity : 'invalid'\n                        message : \"Internal error:\n                            No Structure with ID #{reason.cited}\"\n                        missingID : reason.cited\n                    return callback()\n\nIf they cited a non-rule, stop right now and tell them that's invalid and we\nwon't proceed to even try to validate this step.\n\n                if rule not instanceof OutputRule\n                    @enableFeedback yes, no\n                    @feedback\n                        type : 'validation result'\n                        validity : 'invalid'\n                        message : 'You cited a non-rule as a reason.'\n                        nonRule : reason.cited\n                    return callback()\n\nRun the validation procedure for the cited rule, and when it completes,\ninspect the feedback it produced.  If it's positive, send it right now and\nbe done.  If it's anything else, keep looking, via a recursive call.\n\n                rule.validateStep @, worker, =>\n                    lastFeedback = @feedbackStore[@feedbackStore.length - 1]\n                    if lastFeedback?.validity is 'valid'\n                        @enableFeedback yes, no\n                        @feedback lastFeedback\n                        callback()\n                    else\n                        processNext()\n\n## Define `TemplateRule` as a type of `OutputRule`\n\nA `TemplateRule` is an `OutputRule` that validates steps based on a template\nof zero or more premises and one or more conclusion.  They can be\ntree-based (meaning that they perform pattern matching based on expression\ntrees) or string-based (meaning that they perform pattern matching based on\nstrings) and they can be uni-directional (if premises then conclusion) or\nbi-directional (premises if and only if conclusions).\n\n    class TemplateRule extends OutputRule\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'TemplateRule', TemplateRule\n\n### Main `TemplateRule` functions\n\nThe `validateStep()` function of the this class assumes the class was\nconstructed syntactically correctly, that is, with only children that are of\nthe class `OutputExpression` and with some subset of them having the\nattribute \"premise\" set to true (the rest of them being conclusions).\n\nIt assumes tree-based matching, but can be configured to use string-based\nmatching if the attribute \"matching type\" is set to \"string\".  It assumes a\none-way (if-then) rule, but can be configured to perform two-way (if and\nonly if) checking if the attribute \"iff\" is set to true.\n\n        validateStep : ( step, worker, callback ) ->\n\nCompute the list of premises and conclusions in OpenMath form.  Then compute\nhow many forms this rule has (one for each conclusion in one-way form, plus\none for each premise if we're allowed to use it in two-way form as well).\nWrite a function that can produce any of those forms, but don't compute them\nall up front, because we don't yet know if we need them.  We can call that\nfunction later to create them just in time.\n\n            rulePremises = ( child.toOpenMath yes for child in @children() \\\n                when child.getAttribute 'premise' )\n            ruleConclusions = ( child.toOpenMath yes \\\n                for child in @children() \\\n                when not child.getAttribute 'premise' )\n            numRuleForms = ruleConclusions.length\n            if @getAttribute 'iff' then numRuleForms += rulePremises.length\n            buildRuleForm = ( prems, concl ) ->\n                OM.app(\n                    OM.sym( 'Rule', 'Lurch' ),\n                    ( p.copy() for p in prems )...,\n                    concl.copy()\n                )\n            getRuleForm = ( index ) ->\n                if index < ruleConclusions.length\n                    prems = rulePremises\n                    concl = ruleConclusions[index]\n                else\n                    prems = ruleConclusions\n                    concl = rulePremises[index-ruleConclusions.length]\n                result = buildRuleForm prems, concl\n                vars = result.descendantsSatisfying ( d ) -> d.type is 'v'\n                FOM.setMetavariable v for v in vars\n                result\n\nUnite the step and its cited premises into the same structure, so that we\nmight compare them.\n\n            if step not instanceof OutputExpression\n                step.feedback\n                    type : 'validation result'\n                    validity : 'invalid'\n                    message : 'Conclusion is not an expression'\n            premises = [ ]\n            for type in [ 'connections', 'labels' ]\n                for citation in step.lastCitationLookup.premises[type]\n                    premise = Structure.instanceWithID citation.cited\n                    if premise not instanceof OutputExpression\n                        step.feedback\n                            type : 'validation result'\n                            validity : 'invalid'\n                            message : 'Cited premise is not an expression'\n                            id : citation.cited\n                        return callback()\n                    premises.push premise.toOpenMath yes\n            instance = buildRuleForm premises, step.toOpenMath yes\n\nFrom here on out, we need to know whether we're doing string-based pattern\nmatching or tree-based pattern matching, so we compute that here.\n\n            ruleType = if @getAttribute( 'matching type' ) is 'string' \\\n                then 'string' else 'tree'\n\nSee if any of the forms of this rule matches the instance as claimed.  We do\nthis asynchronously in background threads, but begin by installing the\nnecessary script and step data into the worker we've been given.\n\n            stepToInstall = if ruleType is 'tree' then instance.encode() \\\n                else ( x.value for x in instance.children[1..] )\n            @setupWorker worker, { step : stepToInstall }, callback, =>\n                index = 0\n                do processNext = =>\n\nFirst, if we've tried all the forms, then they've all failed, so we report\nthat the rule does not justify the step.\n\n                    if index is numRuleForms\n                        step.feedback\n                            type : 'validation result'\n                            validity : 'invalid'\n                            message : 'Cited rule does not justify the\n                                step'\n                        return callback()\n\nOtherwise, we have another form to try, so let's queue it up for checking in\nthe background worker.\n\n                    validator =\n                        TemplateRule[\"#{ruleType}BasedPatternMatching\"]\n                    ruleToInstall = if ruleType is 'tree'\n                        getRuleForm( index ).encode()\n                    else\n                        for child in getRuleForm( index ).children[1..]\n                            child.toOutputExpression( yes )\n                                 .getAttribute 'string pattern'\n                    @setupWorker worker, { rule : ruleToInstall },\n                    callback, ->\n                        worker.run validator, ( response ) ->\n                            if response.error?\n                                step.feedback\n                                    type : 'validation result'\n                                    validity : 'invalid'\n                                    message : 'Internal error in pattern\n                                        matching'\n                                    details : response.error\n                                return callback()\n\nHere we've gotten past all the error checks, so we either have a match,\nwhich means the step is valid, or we have a non-match, which means we should\nmove on to try the next form of the rule, with a recursive call to\n`processNext()`.\n\n                            if response.result?\n                                step.feedback\n                                    type : 'validation result'\n                                    validity : 'valid'\n                                return callback()\n                            index++\n                            processNext()\n\n### Utility functions for `TemplateRule`s\n\nThe following utility function is used by `validateStep()` to set up a\nworker for use in matching.  It ensures that the Matching Package has been\nloaded (exactly once) in that worker, and ensures that all the given global\ndata has been installed as well.  If an error occurs at any point, it calls\nthe error callback after first sending negative validation feedback about an\ninternal error.  If no error occurs, it calls the success callback.\n\n        setupWorker : ( worker, data, error, success ) ->\n\nDefine a helper function for expressing internal errors, to simplify code\nbelow.\n\n            ie = ( message, details ) =>\n                feedbackObj =\n                    type : 'validation result'\n                    validity : 'invalid'\n                    message : \"Internal error setting up validation worker:\n                        could not #{message}\"\n                if details? then feedbackObj.details = details\n                @feedback feedbackObj\n                return error()\n\nCreate the list of keys in `data` that we need to install in the worker.\n\n            toInstall = ( k for own k, v of data )\n\nCreate an asynchronous recursive function to install all those keys.\n\n            do nextStep = =>\n                if toInstall.length > 0\n                    key = toInstall.shift()\n                    worker.installData key, data[key], ( response ) =>\n                        if response.error? then return ie \"install #{key}\"\n                        nextStep()\n\nWhen they're all installed, the last step is to install the matching\npackage if and only if it's needed, then call the `success` callback.\n\n                else if @getAttribute( 'matching type' ) is 'string'\n                    worker.run ( -> typeof stringMatches ), ( response ) =>\n                        if response.error?\n                            return ie 'check string matching installation',\n                                response.error\n                        if response.result is 'undefined'\n                            worker.installFunction 'stringMatches',\n                            TemplateRule.stringMatches, ( response ) =>\n                                if response.error?\n                                    return ie 'install string matcher',\n                                        response.error\n                                worker.installFunction 'stringListMatches',\n                                TemplateRule.stringListMatches,\n                                ( response ) =>\n                                    if response.error?\n                                        return ie 'install string list\n                                            matcher', response.error\n                                    success()\n                        else\n                            success()\n                else\n                    worker.run ( -> typeof isMetavariable ), ( response ) =>\n                        if response.error?\n                            return ie 'check package status',\n                                response.error\n                        if response.result is 'undefined'\n                            path = 'first-order-matching.js'\n                            if require? then path = \"release/#{path}\"\n                            worker.installScript path, ( response ) =>\n                                if response.error?\n                                    return ie 'install matching package',\n                                        response.error\n                                success()\n                        else\n                            success()\n\nWe also need a function that will do string-based pattern matching so that\nthe LDE can support\n[string-rewriting systems](https://en.wikipedia.org/wiki/Semi-Thue_system)\nsuch as [Hofstadter's MU puzzle](https://en.wikipedia.org/wiki/MU_puzzle)\nrather than just the standard interpretation of syntax as representing\ntrees of meaning.  The following function is that pattern-matcher.  We\ndefine it as a class method so that it can be easily installed in workers.\n\nIt expects the first parameter to be a list of objects, each of which has\neither `type : \"string\"` or `type : \"metavariable\"` and has the contents of\nthe string (or the name of the metavariable) as its `text` field.  The\nsecond parameter should be the string against which to attempt to find\nmatches, and the third parameter should be omitted; it is for internal use.\n\nThis is an inefficient implementation that could be improved later if\nneeded.\n\n        @stringMatches = ( patterns, string, soFar ) ->\n\nMust initialize default parameter values inside, so that this function can\nbe converted to a list of arguments and a body correctly when being sent to\na worker for use in a `Function` constructor.\n\n            soFar ?= { }\n\nBase case: If we've consumed all patterns, then there exists a solution iff\nwe've also consumed the entire string.\n\n            if patterns.length is 0\n                return if string.length is 0\n                    [ JSON.parse JSON.stringify soFar ] # deep copy\n                else\n                    [ ]\n\nInductive step: Pop one pattern off and consider it next.  If it is a string\nliteral, then it must match the beginning of the string exactly.\n\n            pattern = patterns[0]\n            t = pattern.text\n            if pattern.type is 'string'\n                return if string[...t.length] is t\n                    stringMatches patterns[1..], string[t.length..], soFar\n                else\n                    [ ]\n\nSince it is not a string literal, it must be a metavariable.  If we've seen\nit already, then its meaning is treated like a string literal.\n\n            if soFar.hasOwnProperty t\n                return if string[...soFar[t].length] is soFar[t]\n                    stringMatches patterns[1..], string[soFar[t].length..],\n                        soFar\n                else\n                    [ ]\n\nOtherwise it is a metavariable we must consider how to instantiate.  Here is\nwhere the inefficient part of this implementation comes in:  We just\nconsider each of the possibilities it could be, from the first character of\nthe string alone up through the entire rest of the string, and check each\none by instantiating it that way and then recurring.  Unite all solutions\ninto one big array and return them.\n\n            results = [ ]\n            for i in [1..string.length]\n                soFar[t] = string[...i]\n                results = results.concat stringMatches patterns[1..],\n                    string[i..], soFar\n            delete soFar[t] # clean the object up before we un-recur\n            results\n\nWe also define a function that applies the string matching function to two\nlists, one of patterns and one of strings, which typically represent a rule\nand a purported use of the rule.  It returns the set of matches that work\nfor the entire list of (pattern,string) pairs that can be formed from\ncorresponding elements of those lists.\n\nSee documentation in `stringMatches()`, above, for why we initialize `soFar`\ninside the function body.\n\n        @stringListMatches = ( patterns, strings, soFar ) ->\n            soFar ?= { }\n            if patterns.length is 0\n                return if strings.length is 0 then [ soFar ] else [ ]\n            if strings.length is 0 then return [ ]\n            results = [ ]\n            for next in stringMatches patterns[0], strings[0], soFar\n                for result in stringListMatches patterns[1..], \\\n                                                strings[1..], next\n                    results.push result\n            results\n\nThe following utility function will be installed in workers, and extracts\nrule and step data from the `globalData` object, calls the matching package\non it, and returns the results.\n\n        @treeBasedPatternMatching = ->\n            rule = OM.decode globalData.rule\n            step = OM.decode globalData.step\n            myMatch = nextMatch new Constraint rule, step\n            if contents = myMatch?[0]?.contents\n                for { pattern, expression } in contents\n                    pattern : pattern.encode()\n                    expression : expression.encode()\n            else\n                null\n\nThe following utility function is just like the previous, but does\nstring-based pattern matching instead.\n\n        @stringBasedPatternMatching = ->\n            myMatch = stringListMatches globalData.rule, globalData.step\n            if myMatch.length then myMatch[0] else null\n\n## Exports\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports?\n        exports.OutputStructure = OutputStructure\n        exports.OutputExpression = OutputExpression\n        exports.OutputRule = OutputRule\n        exports.TemplateRule = TemplateRule\n        exports.OM = exports.OMNode = OM\n"]}