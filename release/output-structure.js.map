{"version":3,"sources":["output-structure.litcoffee"],"names":["InputStructure","OM","OutputExpression","OutputRule","OutputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","IS","len","ref","apply","arguments","markDirty","subclasses","instancesBeingInterpreted","length","origin","enableFeedback","className","addSubclass","yesOrNo","dirty","addConnectionOrigin","source","target","data","_origin","id","feedback","feedbackData","sendingFeedback","feedbackStore","push","enable","emitAll","j","len1","hasLabel","label","lookUpIn","accessibles","candidate","slice","reverse","lookUp","firstAccessible","lookUpAll","allAccessibles","lookUpAllCitations","cited","connection","k","l","labels","len2","len3","len4","len5","m","n","ref1","ref2","ref3","result","type","premises","connections","reasons","getConnectionsOut","getConnectionData","getConnectionTarget","getAttribute","Array","justChanged","base","instanceJustChanged","rest","setAttribute","toOpenMath","body","childResults","head","i","indices","notVarIndices","vars","func","args","results","children","indexOf","bin","concat","fromOpenMath","node","v","value","name","cd","uri","variables","symbol","toOutputExpression","validateStep","step","worker","callback","validity","message","basicValidate","processNext","lastCitationLookup","_this","keptFeedback","reason","rule","components","shift","instanceWithID","missingID","lastFeedback","nonRule","exports","OMNode"],"mappings":"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","file":"output-structure.js","sourcesContent":["\n# Output Structures\n\nThe LDE module constructs, for its internal use, a hierarchy of\n`OutputStructure` instances called the Output Tree.  The word \"output\" is\nused because it is the output of an interpretation process defined\nthroughout the subclasses of `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`InputStructure` instances.  In short, these support validation while\n`InputStructure`s support interpretation.  You can also think of the\ndifference as this:  `InputStructure`s represent the syntax of what the user\nhas expressed to the client, and `OutputStructure`s represent the semantics\ninto which we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n        { InputStructure } = require './input-structure'\n        { OM } = require 'openmath-js'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n            importScripts 'input-structure.js'\n        if not WorkerGlobalScope.OM?\n            importScripts 'openmath.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n            importScripts 'release/input-structure.js'\n        if not self.OM?\n            importScripts 'node_modules/openmath-js/openmath.js'\n\n## Define the `OutputStructure` class\n\n    class OutputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputStructure', OutputStructure\n\nMarking an `OutputStructure` dirty, unlike with `InputStructure`s, does not\npropagate up the ancestor chain.  Thus we define the following function\nanalogous to the one in the `InputStructure` class, but without the\nrecursive propagation.\n\n        markDirty : ( yesOrNo = yes ) -> @dirty = yesOrNo\n\nA newly constructed instance should be considered dirty (because it probably\njust changed and thus may need to be validated).  It should also record the\n`InputStructure` instance that gave rise to it, if indeed this construction\nhappend as part of interpretation.\n\n        constructor : ->\n            super arguments...\n            @markDirty()\n            IS = Structure::subclasses.InputStructure\n            if len = IS::instancesBeingInterpreted?.length\n                @origin = IS::instancesBeingInterpreted[len-1]\n            @enableFeedback yes, no\n\nSimilar to tracking origins for `OutputStructure` nodes, if a connection is\nformed between `OutputStructure` instances, we will want to track its origin\nin the sense of which `InputStructure` was being interpreted when the\nconnection was formed.\n\n        addConnectionOrigin : ( source, target, data ) ->\n            IS = Structure::subclasses.InputStructure\n            if ( target instanceof OutputStructure ) and \\\n               ( len = IS::instancesBeingInterpreted?.length )\n                data._origin = IS::instancesBeingInterpreted[len-1].id()\n\n## Feedback\n\nFeedback on this structure can be given by calling a single function,\n`feedback`, and passing an object with a feedback `type` field and optional\nother fields.  By default, that method finds the `InputStructure` instance\nthat created this `OutputStructure` and if there is such a thing, calls the\n`feedback` method in it.  (That will delegate the work further, but that is\nnot our concern here.)\n\nBut it is sometimes the case that we do not wish generated feedback to be\nimmediately emitted to the client.  For instance, if several different\nmethods to validate this `Structure` are being attempted in sequence, we\nmight wish to inspect all the generated feedback before deciding which\nsubset of it to emit to the client.\n\nThus we provide a function for enabling or disabling the storing of\nfeedback.  When enabled, no feedback is emitted, but it is all stored in a\n`feedbackQueue`.  At any point, that queue can be cleared, optionally\nemitting all of its contents first, using the methods below.\n\n        feedback : ( feedbackData ) ->\n            if @sendingFeedback\n                @origin?.feedback feedbackData\n            else\n                @feedbackStore.push feedbackData\n        enableFeedback : ( enable = yes, emitAll = no ) ->\n            if ( @sendingFeedback = enable ) and emitAll\n                @feedback feedbackData for feedbackData in @feedbackStore\n            @feedbackStore = [ ]\n\n## Labels\n\n`OutputStructure`s can be labeled.  This is implemented by a function that\ntakes a string as input and returns true or false, whether the structure has\nthat label.  This permits a lot of freedom in how we match labels to\nstructures, including case sensitivity, punctuation sensitivity, multiple\nlabels, and so on.  By default, however, everything is unlabeled, so the\nbase implementation is as follows.\n\n        hasLabel : ( label ) -> no\n\nWe can look back through a list of all the `OutputStructure`s accessible to\na given one, seeking the first one that admits to having a given label, by\nuse of the `hasLabel()` function on each accessible structure.  We implement\nthat generically with the following class method, then make a shortcut for\nuse by instances below.  Here we assume that the accessibles array is given\nin the order in which the nodes appear in the tree\n(`Structure.isEarlierThan()`).\n\n        @lookUpIn : ( label, accessibles ) ->\n            for candidate in accessibles[...].reverse()\n                return candidate if candidate.hasLabel label\n            undefined\n\nWhen an instance asks to look up the nearest accessible thing with a given\nlabel, what it means is among those things accessible to that instance.\n\n        lookUp : ( label ) ->\n            @firstAccessible ( candidate ) -> candidate.hasLabel label\n\nWhen an instance asks to look up all accessible things with a given label,\nthey are still returned in the order in which they are encountered when\ntraversing the list of accessibles.\n\n        lookUpAll : ( label ) ->\n            @allAccessibles ( candidate ) -> candidate.hasLabel label\n\n## Citations\n\nObeying the conventions set down by interpretation, as defined in\n[the InputStructure class](input-structure.litcoffee#citations), we provide\nthe following function to look up all structures cited by this one.  The\nnotion of \"looking them up\" here means finding the targets that are cited by\nthe data stored in this object and creating a dictionary mapping the means\nof citation to the structures cited.\n\nWe respect the following citation conventions set down by the\n`InputStructure` class linked to in the previous paragraph:\n * The \"premise citations\" and \"reason citations\" attributes will each map\n   to a list of strings, each of which attempts to cite something by label.\n * Connections out of this node whose JSON data contains the key-value pair\n   (\"type\",\"premise citation\") or (\"type\",\"reason citation\") are each\n   interpreted as a citation.\n\nThe form of the result will be a JSON structure with this format:\n```javascript\n{\n    premises : { // citations of premises go in here\n        connections : [ // citations by connection go in here\n            {\n                cited : \"id of target structure\",\n                id : \"id of connection, so you can get its data later\"\n            }\n            // zero or more such objects in this array\n        ],\n        labels : [ // citations by label go in here\n            {\n                cited : \"id of cited structure\",\n                label : \"text of label by which it was cited\"\n            }\n            // zero or more such objects in this array\n        ]\n    },\n    reasons : {\n        // same structure as premises object above\n    }\n}\n```\n\n        lookUpAllCitations : ->\n\nInitialize the data structure we will return, empty at first.\n\n            result =\n                premises :\n                    connections : [ ]\n                    labels : [ ]\n                reasons :\n                    connections : [ ]\n                    labels : [ ]\n\nFill both connections arrays by examining all connections out of this\nstructure for their types.\n\n            for connection in @getConnectionsOut()\n                data = @getConnectionData connection\n                for type in [ 'premise', 'reason' ]\n                    if data?.type is \"#{type} citation\" and\n                       ( target = @getConnectionTarget connection )?\n                        result[\"#{type}s\"].connections.push\n                            cited : target.id()\n                            id : connection\n\nFill both labels arrays by examining the relevant attributes of this\nstructure.\n\n            for type in [ 'premise', 'reason' ]\n                if ( labels = @getAttribute \"#{type} citations\" ) and \\\n                   labels instanceof Array\n                    for label in labels\n                        for cited in @lookUpAll( label ).reverse()\n                            result[\"#{type}s\"].labels.push\n                                cited : cited.id()\n                                label : label\n\nReturn the result.\n\n            result\n\n## Handling change events\n\nWhen interpretation has completed, the `justChanged()` function will be\ncalled in every structure in the Output Tree has been updated during that\ninterpretation phase.  We provide the following default implementation for\n`justChanged()` that will defer the work to the class method\n`instanceJustChanged` if and only if that class method exists.  It doesn't\nyet exist, so this is ineffective unless some later code installs just such\na class method.\n\nThe reason for this is that the actual implementation we want to provide\ndepends upon some global data structures in the LDE to which this module\ndoes not have access.  When the LDE loads this module, it can fill in the\nmissing class method with the appropriate implementation, which accesses its\nown internals.\n\n        justChanged : -> OutputStructure::instanceJustChanged? @\n\n## Define `OutputExpression` as a type of `OutputStructure`\n\nAn `OutputExpression` is the most common type of mathematics we think of\nwhen doing mathematics on a computer.  It may be a mathematical noun, such\nas 3x, or a mathematical statement, such as \"not every number is even.\"\nThese are what typically appear inside dollar signs in LaTeX documents, and\nform the majority of the content of any proof in a formal system.\n\nIn the LDE, we use OpenMath data types to store expressions.  In particular,\nwe rely on a JavaScript implementation of part of the OpenMath Standard,\n[published here](https://github.com/lurchmath/openmath-js).  Each expression\nis a tree made up of instances of the following class, each of which\ncorresponds to a node in an OpenMath tree, and there are conversion\nfunctions between the two data structures.\n\n    class OutputExpression extends OutputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputExpression',\n            OutputExpression\n\nThe constructor takes an arbitrary number of parameters.  The first is\nalways the OpenMath type that this object represents (e.g., string, integer,\nfunction application, etc.).  That type should be expressed in the\nthree-letter form used in the OpenMath module's code (e.g., \"int\", \"flo\",\n\"str\", etc., as a JavaScript string).\n\nThe remaining parameters depend on the first.\n\n * If the first parameter gives this object an OpenMath atomic type, then\n   the next should contain the atomic content (e.g., string data if this is\n   a string).  In one case (OpenMath symbol) this atomic content is spread\n   over two or three parameters: name, CD, and optional URI.\n * If the first parameter gives this object an OpenMath binding type, then\n   the second parameter should be an array of the indices of bound\n   variables, and then the third and further parameters are its children,\n   which must be `OutputExpression` instances, and will be passed to the\n   superclass's constructor.\n * In all other cases, the second and further parameters are the children,\n   and are passed on as in the previous case.\n\nIf an invalid type is passed as first parameter, we construct an OpenMath\nerror object instead, with no children and no attributes.  Any other\nconfiguration of invalid parametrs (e.g., bad binding indices) will be\naccepted, but may not convert to an OpenMath object in `toOpenMath()`.\nNote that an error object constructed that way will not correctly convert\nto an OpenMath object, because it has not head symbol.\n\nCurrently there is not any supported way to decorate an `OutputExpression`\ninstance with OpenMath attributes, though that could be added later if the\nneed arises.\n\n        constructor : ( type, rest... ) ->\n            switch type\n                when 'int', 'flo', 'str', 'byt', 'var'\n                    super()\n                    @setAttribute 'OM type', type\n                    @setAttribute 'OM atomic value', rest[0]\n                when 'sym'\n                    super()\n                    @setAttribute 'OM type', type\n                    @setAttribute 'OM atomic value', rest\n                when 'bin'\n                    super rest[1..]...\n                    @setAttribute 'OM type', type\n                    @setAttribute 'OM bound indices', rest[0]\n                when 'app', 'err'\n                    super rest...\n                    @setAttribute 'OM type', type\n                else\n                    super()\n                    @setAttribute 'OM type', 'err'\n\nWe wish to be able to extract from any `OutputExpression` instance the\nOpenMath object that it represents.  We do so with the following conversion\nfunction.  If conversion to an OpenMath object fails from an error in the\nOpenMath package, that error is not caught; clients should take care to\nform their `OutputExpression` instances correctly or use `try`/`catch`.\n\nAs stated above, attributes are not yet supported, though such support\ncould be added later.\n\n        toOpenMath : ->\n            switch type = @getAttribute 'OM type'\n                when 'int', 'flo', 'str', 'byt', 'var'\n                    new OM[type] @getAttribute 'OM atomic value'\n                when 'sym'\n                    new OM[type] @getAttribute( 'OM atomic value' )...\n                when 'app', 'err'\n                    childResults =\n                        ( child.toOpenMath() for child in @children() )\n                    new OM[type] childResults...\n                when 'bin'\n                    indices = @getAttribute 'OM bound indices'\n                    vars = for i in indices\n                        OM.var @children()[i].getAttribute 'OM atomic value'\n                    notVarIndices = ( i for i in [0...@children().length] \\\n                        when i not in indices )\n                    head = @children()[notVarIndices[0]].toOpenMath()\n                    body = @children()[notVarIndices[1]].toOpenMath()\n                    new OM.bin head, vars..., body\n                else\n                    throw \"Not a valid OpenMath type: #{type}\"\n\nWe also want the inverse conversion function, from `OMNode` instances (from\nthe OpenMath package) to instances of this type.  We provide that function\nas a class method here, and one should call it on an instance of the\n`OMNode` class; it will yield an instance of this class in every case,\nbecause `OMNode` instances cannot be incorrectly formed.\n\nAs stated above, attributes are not yet supported, though such support\ncould be added later.\n\n        @fromOpenMath : ( node ) ->\n            childResults = ( OutputExpression.fromOpenMath child \\\n                for child in node.children )\n            switch node.type\n                when 'i' then new OutputExpression 'int', node.value\n                when 'f' then new OutputExpression 'flo', node.value\n                when 'st' then new OutputExpression 'str', node.value\n                when 'ba' then new OutputExpression 'byt', node.value\n                when 'sy' then new OutputExpression 'sym', node.name,\n                    node.cd, node.uri\n                when 'v' then new OutputExpression 'var', node.name\n                when 'a' then new OutputExpression 'app', childResults...\n                when 'bi'\n                    vars = ( new OutputExpression 'var', v.name \\\n                        for v in node.variables )\n                    head = OutputExpression.fromOpenMath node.symbol\n                    body = OutputExpression.fromOpenMath node.body\n                    new OutputExpression 'bin', [1...childResults.length],\n                        head, vars..., body\n                when 'e' then new OutputExpression 'err',\n                    OutputExpression.fromOpenMath( node.symbol ),\n                    childResults...\n                else throw \"This should never happen - how did an\n                    OMNode instance get type #{node.type}?\"\n\nFor convenience, we install in the `OMNode` class a method for converting\ninstances to `OutputExpression` types by simply deferring the work to the\nabove function.\n\n    OM::toOutputExpression = -> OutputExpression.fromOpenMath @\n\n## Define `OutputRule` as a type of `OutputStructure`\n\nAn `OutputRule` is a member of the Output Tree that has a function\n`validateStep()` that can be called on a step of work to validate it.  As\ndocumented\n[elsewhere](https://lurchmath.github.io/lde/site/api-phases/#validation),\na step `S` is normally validated by calling `S.validate(worker,callback)`,\nbut in the case when the step cites a rule, that function will typically\nwant to delegate the work to the rule itself, so that we can support rules\nwith arbitrary decision procedures within an object-oriented framework.\n\n    class OutputRule extends OutputStructure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputRule', OutputRule\n\nThe `validateStep()` function takes three parameters: the step to validate\nand the `worker` and `callback` functions that were given to its `validate`\nroutine.  The `worker` can be used to do any lengthy tasks in the\nbackground and the `callback` should naturally be called to indicate when\nthe task is complete (passing no arguments).\n\nThe default implementation just produces feedback saying that no real\nvalidation was done, and then calls the callback.  Naturally, subclasses\nthat do real work will want to override this default.\n\n        validateStep : ( step, worker, callback ) ->\n            step.feedback\n                type : 'validation result'\n                validity : 'indeterminate'\n                message : 'No real validation was performed.'\n            callback()\n\nWe also provide a class member that can be copied out of this class and into\n`OutputExpression` instances as their validate routine.  This routine just\ndelegates validation to the cited rule.  If there is any non-`OutputRule`\ninstance cited as a reason, the step is judged invalid.  If there is more\nthan one `OutputRule` step cited as a reason, then this routine checks each\nin turn to see if any will validate the step.  If not, then the resulting\nnegative feedback includes a `phases` field containing all the feedback\nobjects generated by all the cited rules.\n\n        @basicValidate : ( worker, callback ) ->\n\nDisable feedback emission, because we will want to inspect the feedback\ngenerated instead of just immediately sending it out.  Compute the list of\ncited reasons.\n\nNote that throughout this routine, the `this` object is assumed to be a step\nof work, because this function is designed to be installed in such objects\nas their `validate` routine.\n\n            @enableFeedback no\n            reasons = @lastCitationLookup.reasons\n            reasons = reasons.connections.concat reasons.labels\n\nWe process each cited reason asynchronously, using a function that calls\nitself recursively in callbacks.\n\n            do processNext = =>\n\nThe base csae is when we've finished processing all reasons.  This may be\nbecause there weren't any, in which case we do nothing, or because all of\nthem said the step was invalid, in which case we combine them into a single\nfeedback message, which we emit.\n\n                if reasons.length is 0\n                    keptFeedback = @feedbackStore\n                    @enableFeedback yes, no\n                    if keptFeedback.length > 0\n                        @feedback\n                            type : 'validation result'\n                            validity : 'invalid'\n                            components : keptFeedback\n                    return callback()\n\nThere remain reasons to process, so get the next one.  If we can't seem to\nfind it by its ID, then some internal error has happened, because that's not\nsupposed to ever happen.  Report it just in case and stop validation\nentirely in that case.\n\n                reason = reasons.shift()\n                if not ( rule = Structure.instanceWithID reason.cited )?\n                    @enableFeedback yes, no\n                    @feedback\n                        type : 'validation result'\n                        validity : 'invalid'\n                        message : \"Internal error:\n                            No Structure with ID #{reason.cited}\"\n                        missingID : reason.cited\n                    return callback()\n\nIf they cited a non-rule, stop right now and tell them that's invalid and we\nwon't proceed to even try to validate this step.\n\n                if rule not instanceof OutputRule\n                    @enableFeedback yes, no\n                    @feedback\n                        type : 'validation result'\n                        validity : 'invalid'\n                        message : 'You cited a non-rule as a reason.'\n                        nonRule : reason.cited\n                    return callback()\n\nRun the validation procedure for the cited rule, and when it completes,\ninspect the feedback it produced.  If it's positive, send it right now and\nbe done.  If it's anything else, keep looking, via a recursive call.\n\n                rule.validateStep @, worker, =>\n                    lastFeedback = @feedbackStore[@feedbackStore.length - 1]\n                    if lastFeedback?.validity is 'valid'\n                        @enableFeedback yes, no\n                        @feedback lastFeedback\n                        callback()\n                    else\n                        processNext()\n\n## Exports\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports?\n        exports.OutputStructure = OutputStructure\n        exports.OutputExpression = OutputExpression\n        exports.OM = exports.OMNode = OM\n"]}