{"version":3,"sources":["output-structure.litcoffee"],"names":["InputStructure","OutputStructure","Structure","extend","child","parent","ctor","this","constructor","key","hasProp","call","prototype","__super__","require","WorkerGlobalScope","importScripts","self","superClass","IS","len","ref","apply","arguments","markDirty","subclasses","instancesBeingInterpreted","length","origin","className","addSubclass","yesOrNo","dirty","addConnectionOrigin","source","target","data","_origin","id","feedback","feedbackData","exports"],"mappings":"AAyBI,IAAAA,eAAAC,gBAAAC,UAAAC,OAAA,SAAAC,EAAAC,GAAA,SAAAC,IAAAC,KAAAC,YAAAJ,EAAA,IAAA,IAAAK,KAAAJ,EAAAK,QAAAC,KAAAN,EAAAI,KAAAL,EAAAK,GAAAJ,EAAAI,IAAA,OAAAH,EAAAM,UAAAP,EAAAO,UAAAR,EAAAQ,UAAA,IAAAN,EAAAF,EAAAS,UAAAR,EAAAO,UAAAR,6BAAG,oBAAAU,SAAA,OAAAA,SACGZ,UAAcY,QAAQ,eAARZ,UACdF,eAAmBc,QAAQ,qBAARd,gBACjB,oBAAAe,mBAAA,OAAAA,kBACG,MAAAA,kBAAAb,YACHc,cAAc,gBACdA,cAAc,uBACd,OAAA,oBAAAC,MAAA,OAAAA,KAAAA,KAAAD,mBAAA,IACG,MAAAC,KAAAf,YACHc,cAAc,wBACdA,cAAc,+BAIhBf,gBAAA,SAAAiB,GAoBY,SAAAjB,IACV,IAAAkB,EAAAC,EAAAC,EAAApB,EAAAY,UAAAL,YAAAc,MAAAf,KAAMgB,WACNhB,KAACiB,aAEEJ,EAAA,OAAAC,GADHF,EAAKjB,UAASU,UAAEa,WAAWzB,gBACxBY,UAAAc,2BAAAL,EAAqCM,YAAA,KACpCpB,KAACqB,OAAST,EAAEP,UAAEc,0BAA0BN,EAAI,oBAzB1BlB,uBAM1B2B,UAAY3B,UAAU4B,YAAY,kBAAmB7B,eAOrDuB,UAAY,SAAEO,oBAAAA,GAAU,GAASxB,KAACyB,MAAQD,eAmB1CE,oBAAsB,SAAEC,EAAQC,EAAQC,GACpC,IAAAjB,EAAAC,EAAAC,EACA,GADAF,EAAKjB,UAASU,UAAEa,WAAWzB,eACtBmC,aAAkBlC,IAClBmB,EAAA,OAAAC,EAAAF,EAAAP,UAAAc,2BAAAL,EAAqCM,YAAA,UACtCS,EAAKC,QAAUlB,EAAEP,UAAEc,0BAA0BN,EAAI,GAAGkB,kBAS5DC,SAAW,SAAEC,GAAkB,IAAAnB,iCAASkB,SAASC,QAAlB,KA7C7B,GAiDH,oBAAAC,SAAA,OAAAA,UAAcA,QAAQxC,gBAAkBA","file":"output-structure.js","sourcesContent":["\n# Output Structures\n\nThe LDE module constructs, for its internal use, a hierarchy of\n`OutputStructure` instances called the Output Tree.  The word \"output\" is\nused because it is the output of an interpretation process defined\nthroughout the subclasses of `InputStructure`.\n\nThese have entirely different functionality than their cousins\n`InputStructure` instances.  In short, these support validation while\n`InputStructure`s support interpretation.  You can also think of the\ndifference as this:  `InputStructure`s represent the syntax of what the user\nhas expressed to the client, and `OutputStructure`s represent the semantics\ninto which we interpret that syntax.\n\n## Import modules\n\nImport the `Structure` class.  The following lines detect whether this\nis being used in Node.js or a WebWorker, or a WebWorker-like background\nthread within Node.js, and do the right thing in any case.\n\nIn the Worker cases, it is important not to call `importScripts` on the same\nmodule more than once from different files, or all manner of confusing logic\nerrors manifest at runtime, hence the checks below.\n\n    if require?\n        { Structure } = require './structure'\n        { InputStructure } = require './input-structure'\n    else if WorkerGlobalScope?\n        if not WorkerGlobalScope.Structure?\n            importScripts 'structure.js'\n            importScripts 'input-structure.js'\n    else if self?.importScripts?\n        if not self.Structure?\n            importScripts 'release/structure.js'\n            importScripts 'release/input-structure.js'\n\n## Define the `OutputStructure` class\n\n    class OutputStructure extends Structure\n\nIn order for a hierarchy of structures to be able to be serialized and\ndeserialized, we need to track the class of each structure in the hierarchy.\nWe do so for this class with the following line of code.\n\n        className : Structure.addSubclass 'OutputStructure', OutputStructure\n\nMarking an `OutputStructure` dirty, unlike with `InputStructure`s, does not\npropagate up the ancestor chain.  Thus we define the following function\nanalogous to the one in the `InputStructure` class, but without the\nrecursive propagation.\n\n        markDirty : ( yesOrNo = yes ) -> @dirty = yesOrNo\n\nA newly constructed instance should be considered dirty (because it probably\njust changed and thus may need to be validated).  It should also record the\n`InputStructure` instance that gave rise to it, if indeed this construction\nhappend as part of interpretation.\n\n        constructor : ->\n            super arguments...\n            @markDirty()\n            IS = Structure::subclasses.InputStructure\n            if len = IS::instancesBeingInterpreted?.length\n                @origin = IS::instancesBeingInterpreted[len-1]\n\nSimilar to tracking origins for `OutputStructure` nodes, if a connection is\nformed between `OutputStructure` instances, we will want to track its origin\nin the sense of which `InputStructure` was being interpreted when the\nconnection was formed.\n\n        addConnectionOrigin : ( source, target, data ) ->\n            IS = Structure::subclasses.InputStructure\n            if ( target instanceof OutputStructure ) and \\\n               ( len = IS::instancesBeingInterpreted?.length )\n                data._origin = IS::instancesBeingInterpreted[len-1].id()\n\n## Feedback\n\nTo give feedback about a particular `OutputStructure` instance, find the\n`InputStructure` instance that created this `OutputStructure` and if there\nis such a thing, call the `feedback` method in it.  (That will delegate the\nwork further, but that is not our concern here.)\n\n        feedback : ( feedbackData ) -> @origin?.feedback feedbackData\n\nNow if this is being used in a Node.js context, export the class we defined.\n\n    if exports? then exports.OutputStructure = OutputStructure\n\n## Other `OutputStructure` Subclasses\n\nNone yet.  More to come.\n"]}