<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Phase 5, Interpretation - Lurch Deductive Engine Documentation</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">Lurch Deductive Engine Documentation</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Home</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Design Plans <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../design-overview/">Overview</a>
</li>
                            
<li >
    <a href="../phase1-structures/">Phase 1, Structures</a>
</li>
                            
<li >
    <a href="../phase2-input-tree/">Phase 2, The Input Tree</a>
</li>
                            
<li >
    <a href="../phase3-output-tree/">Phase 3, The Output Tree</a>
</li>
                            
<li >
    <a href="../phase4-modification/">Phase 4, Modification</a>
</li>
                            
<li class="active">
    <a href="./">Phase 5, Interpretation</a>
</li>
                            
<li >
    <a href="../phase6-labels/">Phase 6, Labels</a>
</li>
                            
<li >
    <a href="../phase7-validation/">Phase 7, Validation</a>
</li>
                            
<li >
    <a href="../phase8-expressions-and-rules/">Phase 8, Expressions and Rules</a>
</li>
                            
<li >
    <a href="../enhancements/">Enhancements for Later</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">API Documentation <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../api-overview/">Overview</a>
</li>
                            
<li >
    <a href="../api-lde/">The LDE</a>
</li>
                            
<li >
    <a href="../api-structures/">Structures</a>
</li>
                            
<li >
    <a href="../api-input-structures/">Input Structures</a>
</li>
                            
<li >
    <a href="../api-output-structures/">Output Structures</a>
</li>
                            
<li >
    <a href="../api-phases/">Phases of processing</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../phase4-modification/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../phase6-labels/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#lde-design-phase-5-interpretation">LDE Design Phase 5: Interpretation</a></li>
            <li><a href="#content">Content</a></li>
            <li><a href="#goal">Goal</a></li>
            <li><a href="#status">Status</a></li>
            <li><a href="#building-interpretation-routines">Building interpretation routines</a></li>
            <li><a href="#building-recursive-interpretation">Building recursive interpretation</a></li>
            <li><a href="#tracking-origins">Tracking origins</a></li>
            <li><a href="#the-interpretation-phase">The Interpretation Phase</a></li>
            <li><a href="#adding-security">Adding security</a></li>
            <li><a href="#dependency-support">Dependency support</a></li>
            <li><a href="#api-documentation">API Documentation</a></li>
            <li><a href="#efficiency-improvements">Efficiency improvements</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p>We have designed the work on the Lurch Deductive Engine (LDE) to progress in
phases.  The idea is that each phase ends with a completed whole that can be
tested in that state, and that provides more features than the previous
state did.  By the time the final phase is complete, the LDE will be a
robust and useful product.</p>
<h1 id="lde-design-phase-5-interpretation">LDE Design Phase 5: Interpretation</h1>
<h2 id="content">Content</h2>
<p>In this phase, we implement the Interpretation Phase of the LDE.</p>
<h2 id="goal">Goal</h2>
<p>The LDE will be able to interpret the Input Tree, creating an Output Tree
from it.</p>
<h2 id="status">Status</h2>
<p>This has not been implemented.  See the tasks below.</p>
<h2 id="building-interpretation-routines">Building interpretation routines</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled checked/> Create an <code>interpret</code> routine in the <code>InputStructure</code> class that
   takes three arguments, <code>accessibles</code> (a list of <code>OutputStructure</code>s
   accessible to the <code>InputStructure</code> in question), <code>childResults</code> (a list
   of lists of <code>OutputStructure</code> instances that were generated by recursive
   interpretation calls), and <code>scope</code> (a list of the top-level structures
   that are in the scope of the one in which <code>interpret</code> was invoked).  The
   implementation in this base class should be to create a generic
   <code>OutputStructure</code> instance and flatten all the <code>childResults</code> arrays
   into it as children, in order.  Pseudocode:</li>
</ul>
<pre><code>let result = new OutputStructure() // plain vanilla wrapper node
for each childArray in childResults:
    for each node in childArray:
        result.appendChild( node ) // put everything in it
return [ result ] // return an array of exactly one tree
</code></pre>

<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled checked/> Add documentation in that file describing the changes just made.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Extend the unit tests for the <code>InputStructure</code> module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Add documentation in that test file describing the changes just made.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Once the unit tests pass, build everything and commit.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Add documentation stating the limitations on how subclasses are
   permitted to override the <code>interpret</code> routine from the <code>InputStructure</code>
   class.  Specifically, the following rules must be obeyed:<ul>
<li>The routine should depend upon only the data passed to it in its
  first two parameters.</li>
<li>If <code>X.interpret()</code> calls <code>Y.markDirty()</code>, then <code>Y</code> must be in scope
  (that is, one of the elements of the <code>scope</code> array or one of their
  descendants).</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Rebuild the docs and commit.</li>
</ul>
<h2 id="building-recursive-interpretation">Building recursive interpretation</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled checked/> Create a <code>recursiveInterpret</code> routine in the <code>InputStructure</code> class
   that takes two arguments, <code>accessibles</code> (with the same meaning as in the
   <code>interpret</code> routine) and <code>scope</code> (which should be the list of top-level
   structures in the scope of the object in which the function is being
   invoked).  Both arguments should default to an empty array.
   Pseudocode:</li>
</ul>
<pre><code>// remember the size of accessibles for later:
let L = the current length of the accessibles array.
// we will be recursively computing child result arrays,
// and will want to keep a list of them, so initialize that list to empty:
let allChildResults = [ ]
// we need to pass those children their scopes as well, so start with:
let childScope = a shallow copy of the list of children
// now the loop for the recursive work:
for each child C of X do the following:
    // update the child scope list by popping off its first element:
    childScope.shift()
    // do the recursion.
    // note that for the first child, the same list of accessibles for the
    // parent applies to that child:
    let childResult = C.recursiveInterpret( accessibles, childScope )
    // but for later children, more things are accessible.  specifically,
    // anything just created by interpreting C should be accessible to
    // C.nextSibling(), so:
    let accessibles = the concatenation of accessibles
        with childResult (thus extending accessibles)
    // and of course remember the result of the recursive call we just made:
    append childResult as a new entry to the end of allChildResults
        // (which is an array of arrays)
// now that we're done recurring,
// we want to restore the accessibles array to its old state:
let accessibles = just the first L entries of accessibles
    // (restoring it to what it was at the start of this routine)
// this is because we will now ask this node X to interpret itself in
// light of (a) what's accessible to it and (b) all the recursive
// results of interpreting its children.
// So we need the right accessibles array to do this:
result = X.interpret( accessibles, allChildResults, scope )
mark X as no longer dirty
then return result as the result of this function
</code></pre>

<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled checked/> Add documentation in that file describing the changes just made.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Extend the unit tests for the <code>InputStructure</code> module to include some
   calls to this routine, passing it various example parameters and
   verifying that it does its job as specified.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Write more unit tests that create and register some dummy subclasses
   of <code>InputStructure</code> that have example custom <code>interpret</code> routines.
   Verify that those routines get called and do exactly what's expected in
   the creation of their portion of the Output Tree.  Ensure you test a
   variety of different kinds of <code>interpret</code> routines, including ones that
   copy or create attributes, delete children, don't include the default
   wrapper, etc.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation in that test file describing the changes just made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="tracking-origins">Tracking origins</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Create a class variable in the <code>InputStructure</code> class called
   <code>instancesBeingInterpreted</code> that is initialized to the empty array.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend the <code>recursiveInterpret</code> routine so that, before each call to
   <code>X.interpret()</code>, it pushes <code>X</code> onto <code>instanceBeingInterpreted</code>, then pops
   after <code>X.interpret()</code> is complete.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend the constructor for <code>OutputStructure</code> nodes so that, if the
   global <code>InputStructure</code> class is defined, and its
   <code>instanceBeingInterpreted</code> array is non-empty, then its last entry is
   stored within the newly constructed <code>OutputStructure</code> in a field called
   <code>origin</code>.  Otherwise, <code>origin</code> should be undefined (or null, whatever).</li>
<li class="task-list-item"><input type="checkbox" disabled/> Override the <code>OutputStructure</code>'s routine for creating connections so
   that, in addition to forming the connection, it also adds to its JSON
   data an <code>_origin</code> key whose value is the unique id in the Input Tree of
   the last entry on the <code>instanceBeingInterpreted</code> array, if one exists.
   (If not, leave the <code>_origin</code> field undefined.)</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend the unit tests for the LDE module to verify that Output Trees
   now have, in each of their nodes, the correct origin node from the Input
   Tree that gave rise to that <code>OutputStructure</code>.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add unit tests verifying that the <code>feedback()</code> function in
   <code>OutputStructure</code> instances correctly delegates the work to that
   instance's <code>origin</code>.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="the-interpretation-phase">The Interpretation Phase</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Implement a <code>runInterpretation()</code> method in the LDE module.  It
   should just call <code>recursiveInterpret()</code> in the root of the Input Tree,
   store the result in the global Output Tree object, and then call a
   callback.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend that implementation so that it also sends a feedback message
   when it replaces the Output Tree, indicating that the Input and Output
   Trees have been updated and are ready for exporting, should the client
   wish to query them.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend the unit tests of the LDE to test this new function.  This
   should just involve taking some of the existing tests of
   <code>recursiveInterpret()</code> and redoing them to use this new name.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend <code>runModification()</code> so that it no longer calls its own
   callback when complete, but instead calls <code>runInterpretation()</code> and
   passes the callback along to that function.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend the unit tests to test this feature.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="adding-security">Adding security</h2>
<p>One of the policies by which interpretation functions must abide is that an
<code>InputStructure</code> can call <code>markDirty()</code> only in another <code>InputStructure</code>
that is on the <code>scope</code> list, or whose ancestor is on the <code>scope</code> list.  We
introduce policing for that policy here, to prevent infinite loops in
interpretation.  We rely on the fact that one <code>InputStructure</code> is in the
<code>scope</code> variable of another (which is not the same as scope in the Input
Tree) iff it is interpreted after the other.</p>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Have the <code>runInterpretation()</code> method initialize a global variable to
   an empty array; it will contain the list of instances whose
   interpretations have begun.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Each step in the <code>recursiveInterpret()</code> process should begin by
   adding the <code>InputStructure</code> being interepreted to that global array and
   writing a flag into the <code>InputStructure</code> object itself as well.</li>
<li class="task-list-item"><input type="checkbox" disabled/> When <code>runInterpretation()</code> calls its callback or quits and restarts
   the modification phase, erase the flags in all <code>InputStructure</code> instances
   in that array, then set the array to empty again.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Extend <code>markDirty()</code> in the <code>InputStructure</code> class so that if the
   instance has the flag set that indicates that its interpretation has
   begun, we do not obey the request, but instead send a feedback message
   about an internal error and also write the error message to the console.</li>
</ul>
<p>Another of the policies interpretation must obey is that it should not yield
an Output Tree in which any one of the <code>OutputStructure</code> nodes has a
connection to a node outside the Output Tree.  We enforce that policy as
follows.</p>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Add to the end of the <code>runInterpretation()</code> function a full traversal
   of the newly created Output Tree.  At every subtree, if that node has any
   connections, examine the other side of the connection, and walk up its
   ancestor chain to verify that it is in the Output Tree.  If not, sever
   the connection.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add unit tests of this feature by creating a few different situations
   in which such an invalid Output Tree might arise, and verifying that the
   invalid connections (and no others) are removed in each case.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="dependency-support">Dependency support</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Create a subclass of <code>InputExpression</code>, in the <code>InputStructure</code>
   module, called <code>Dependency</code>.  It takes an array of <code>OutputStructure</code>
   instances at construction time, and stores them.  It provides a getter
   for that same array, which can be overridden in subclasses to filter the
   array in cases where it would be helpful to do so.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Make its <code>interpret()</code> routine simply call the getter, not even
   bothering to make copies of the results; return the original array it was
   given at construction time.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation explaining what it is and does.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Ensure that the <code>Dependency</code> subclass registers itself with the
   serialization code, as
   <a href="https://github.com/lurchmath/lde/blob/master/src/structure.litcoffee#registering-class-names">the documentation here</a>
   describes.  (That is, use a line like
   <code>className : Structure.addSubclass 'Dependency', Dependency</code> in the
   <code>Dependency</code> class code.)</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create a new unit test file for <code>Dependency</code> instances that not only
   ensures that the symbol <code>Dependency</code> is defined at the global scope and
   that its instances are also instances of the <code>InputStructure</code> class, but
   also that the <code>interpret()</code> routine behaves as intended, including in the
   context of recursive interpretation of the entire Input Tree.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation for that unit test file, following the pattern
   established in the documentation of other unit test files in this
   repository.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="api-documentation">API Documentation</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Extend the processing phases page of the API Documentation to include
   all the work done in this phase, including interpretation.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Rebuild docs and commit.</li>
</ul>
<h2 id="efficiency-improvements">Efficiency improvements</h2>
<p>This section lists all the potential efficiency improvements related to all
the code written during this phase of development.  Because they are only
efficiency improvements (and thus not required to make the code work
correctly), they can be deferred until later in the project.  It is not
sensible to invest development time on an efficiency improvement if we do
not even yet know whether its lack will be perceived.  If we notice any
performance bottlenecks that any of these improvements could fix, we can
return to these ideas later and follow the steps below to implement them.</p>
<h3 id="caching-interpretation-results">Caching interpretation results</h3>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Extend the <code>InputStructure</code> class with a field called
   <code>lastInterpretation</code>, which is initialized to undefined in the
   constructor.  This field does not need to be part of any serialization
   or deserialization of instances.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create an <code>getLastInterpretation()</code> method that returns the value of
   that member variable.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create a <code>saveInterpretation(I)</code> method in the <code>InputStructure</code> class
   that stores the array <code>I</code> (of zero or more Output Structures) in the
   <code>lastInterpretation</code> field.  If no parameter is passed, clear the cached
   value.</li>
<li class="task-list-item"><input type="checkbox" disabled/> At the end of the <code>recursiveInterpret()</code> routine, just before
   returning the result, call <code>saveInterpretation()</code> on it.</li>
<li class="task-list-item"><input type="checkbox" disabled/> At the start of the <code>recursiveInterpret()</code> routine, if the structure
   is not marked dirty and there is a <code>lastInterpretation</code> defined, just
   return that immediately.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update all documentation in that file to reflect the changes just
   made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add to the unit tests for <code>InputStructure</code>s a few simple tests for
   these new routines.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation in that file describing the changes just made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h3 id="miscellaneous">Miscellaneous</h3>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Create a <code>setChildrenList(newChildren)</code> function in the <code>Structure</code>
   base class.  It should change as little as possible (maybe nothing) to
   make the structure's children array equal to the given one.  This lets
   <code>interpret()</code> routines reuse old Output Structures from cache, just
   adjusting their children lists, rather than constructing new ones, even
   if their children list changed.  Many <code>interpret()</code> routines may
   therefore be simply <code>lastInterpretation.setChildrenList(childResults)</code>
   followed by returning the last interpretation again.  This will often
   just verify that the children list is already correct, change nothing,
   and move on.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add to the unit tests for this new routine.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation in the <code>Structure</code> module describing the new
   routine.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h3 id="recursive-interpretation">Recursive interpretation</h3>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Create a subclass of <code>OutputStructure</code>, in the <code>OutputStructure</code>
   module, called <code>InterpretationDirective</code>.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation explaining what it is and will do (though that
   documentation can grow with time).</li>
<li class="task-list-item"><input type="checkbox" disabled/> Ensure that the <code>InterpretationDirective</code> subclass registers itself
   with the serialization code, as
   <a href="https://github.com/lurchmath/lde/blob/master/src/structure.litcoffee#registering-class-names">the documentation here</a>
   describes.  (That is, use a line like
   <code>className : Structure.addSubclass 'InterpretationDirective', InterpretationDirective</code> in
   the <code>InterpretationDirective</code> class code.)</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create a new unit test file for <code>InterpretationDirective</code>s that is
   extremely basic, just testing to be sure that the symbol
   <code>InterpretationDirective</code> is defined at the global scope and creates
   things that are instances of the <code>InterpretationDirective</code> class.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation for that unit test file, following the pattern
   established in the documentation of other unit test files in this
   repository.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create a subclass <code>FilterableArray</code> of <code>Array</code> that, at construction
   time, is given a predicate.  It stores, internally, a filtered version of
   itself, which is initialized to the empty array.  It guarantees to keep
   this filtered version correct iff it is manipulated only through calls to
   its <code>push()</code> and <code>pop()</code> routines, which we override below.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Override <code>FilterableArray::push()</code> to do an ordinary <code>Array::push()</code>
   and then also a push on the internal filtered version iff the predicate
   holds of the new item.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Override <code>FilterableArray::pop()</code> to do an ordinary <code>Array::pop()</code>
   and then also a pop on the internal filtered version iff the object
   popped was also on the end of that array.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add a new method <code>FilterableArray::filtered()</code> that returns the
   filtered version.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update the default version of <code>recursiveInterpret()</code> to create the
   <code>accessibles</code> array as an instance of <code>FilterableArray</code>, with the
   predicate being whether the Structure is an instance of the
   <code>InterpretationDirective</code> class.  Ensure that adding items to the array
   and removing them from it are done with calls to <code>push()</code> and <code>pop()</code>.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Document this so that later implementations of <code>interpret()</code> can be
   faster by leveraging <code>accessibles.filtered()</code> rather than the entire
   <code>accessibles</code> array.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Ensure all the unit tests still pass.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add new unit tests for the <code>FilterableArray</code> class independently of
   the rest of the LDE.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add some new unit tests that verify that <code>accessibles.filtered()</code> is
   exactly what it should be (i.e., the Interpretation Directive predicate
   is being used correctly).</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script src="../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/require.js"></script>
        <script src="../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
