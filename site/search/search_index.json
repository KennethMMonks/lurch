{
    "docs": [
        {
            "location": "/", 
            "text": "The Lurch Deductive Engine (LDE)\n\n\nThis documentation site contains the design of the LDE.\n\n\nWe will implement that design, and as we do so, the various phases of\ndevelopment (accessible from the navigation menu above) will be converted\nfrom pages describing the plan into pages describing the completed API.\n\n\nUse the menu at the top of this site to find content.\n\n\nSee the source code repository here.", 
            "title": "Home"
        }, 
        {
            "location": "/#the-lurch-deductive-engine-lde", 
            "text": "This documentation site contains the design of the LDE.  We will implement that design, and as we do so, the various phases of\ndevelopment (accessible from the navigation menu above) will be converted\nfrom pages describing the plan into pages describing the completed API.  Use the menu at the top of this site to find content.  See the source code repository here.", 
            "title": "The Lurch Deductive Engine (LDE)"
        }, 
        {
            "location": "/design-overview/", 
            "text": "LDE Design Overview\n\n\nThis page lists the design principles adopted by the Lurch team to date\nregarding the LDE, with reasons and explanations for each.  This document\ncan be used as reference, and to guide development, but it may also be\nchanged as better ideas come along.\n\n\nTo see the specific phases of development planned for the LDE, and what's\ncompleted, use the \"Phases\" menu above.\n\n\nElegance and Simplicity\n\n\nThese are of utmost importance, because\n\n\n\n\nthey make Lurch easier to explain to students or in an Advanced User's\n   Guide (AUG),\n\n\nthey make Lurch easier to test because it has fewer unusual corner cases\n   or special handling of odd circumstances,\n\n\nthey make Lurch easier to implement for the same reason, and\n\n\nthey make it easier for us to be confident that our designs are good,\n   because they're easier to hold in your head and grok all at once.\n\n\n\n\nFeedback and Validation\n\n\n\n\nThe primary purpose of the Lurch application is to give feedback to the\n   user about the work they type into their document.\n\n\nBecause this will often involve validating steps of work in a proof, we\n   may use the terms \"feedback\" and \"validation\" interchangeably, even\n   though technically validation is just a particular type of feedback\n   (though the most common type in our case).\n\n\nOne-Pass Validation (OPV)\n is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   does so by reprocessing every bit of meaningful content from scratch, in\n   one (large, possibly time-consuming) pass over the whole document.\n\n\nReal-Time Validation (RTV)\n is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   attempts to re-use as much information from previous validation as\n   possible, only updating those portions of it that need updating in\n   response to the specific change the user just made.  Thus RTV is\n   trickier to design and implement than OPV, but more efficient at\n   run-time.\n\n\nAn important concept for our test suite is that any RTV design can be\n   converted to an OPV design trivially, and then used for comparison\n   testing.  Simply replace all sophisticated RTV-style change event\n   handlers with OPV-style ones, that mark the entire document as needing\n   reprocessing.  Then any potential change that can be made to the user's\n   document can be run through each of these engines in parallel, and the\n   results compared for equivalence.\n\n\nNote that the choice of OPV vs. RTV is independent of the choice of\n   manual validation vs. automatic validation.  RTV certainly makes\n   automatic validation nicer, and thus makes manual validation less\n   appealing, but you could choose anything from among\n   \n\\{\\text{OPV},\\text{RTV}\\}\\times\\{\\text{auto},\\text{manual}\\}\n.\n\n\n\n\nLDE and UI\n\n\n\n\nWe have a paradigm in which the UI is exactly that (user interface) and\n   the LDE (Lurch Deductive Engine) is the brain that operates in one or\n   more background threads, processing what the user has given the app\n   through the UI.\n\n\nWe aim to implement every feature in the LDE if possible, but implement\n   in the UI only those features that can't be implemented in the LDE.\n   Here, \"if possible\" means that it would not break the model-view\n   paradigm to implement it in the LDE (i.e., the LDE wouldn't need to\n   speak HTML).  Reasons for this:\n\n\nThe LDE will be implemented in pure JS, no DOM, so that it can be\n  used in a WebWorker and in the unit testing suite.\n\n\nTherefore the bigger the LDE is, the more of our code has been\n  subject to rigorous unit tests.\n\n\nAnd the bigger the LDE is, the more of our code is run out of the UX\n  thread, and thus the more responsive our app is.\n\n\n\n\n\n\nThe decisions recorded here are almost entirely about the design of the\n   LDE, not the UI.\n\n\n\n\nStructures\n\n\n\n\nDefine a \nstructure\n to be the basic unit of meaning in the LDE.\n\n\nThis includes document-level structures such as a section,\n  subsection, proof, subproof, etc., which are analogous to block-level\n  items like DIV or P in HTML, and \n\\begin{X}...\\end{X}\n in LaTeX.\n\n\nBut it also includes inline structures (SPANs in HTML, \n\\foo{...}\n or\n  \n$...$\n in LaTeX).\n\n\nStructures can be nested acyclically.\n\n\n\n\n\n\nExamples of types of structures that we may choose to define later:\n\n\nProofs/Subproofs, with one specific flavor of it being the kind that\n  declares a variable first\n\n\nDefinitions of rules, axioms, language rules\n\n\nFormal systems (or \"mathematical topics\")\n\n\nTheorems and pairing of them with proofs\n\n\nExpressions\n\n\nMaybe variables will be declared by based on placing a variable\n  inside an expression by itself, at the head of a variable declaration\n  subproof, or maybe by creating a new structure type for variable\n  declarations, or maybe something else\n\n\nHomework problems\n\n\nExamples (an environment in which anything you declare ends its scope\n  at the end of the example, no matter what it was)\n\n\n\n\n\n\nThe set of structure types should equal the set of common mathematical\n   structures that mathematics students should be learning anyway, and they\n   should behave the same in Lurch as in mathematics.  This ensures that\n   Lurch doesn't add to the mathematics learning curve in this sense.\n\n\nNot every structure is permitted to contain every other type of\n   structure.  But such rules are enforced through validation, which we\n   will not be defining for some time yet, so this comment is just a\n   preview of what's to come.  For instance, expressions can contain only\n   other expressions.\n\n\nAt some later point, we may care about the meanings of structures, so\n   that they can be used as premises in proofs.  At such a time, we will\n   ensure that a structure's meaning includes the unjustified steps in the\n   structure (which function as premises), the final step in the structure\n   (which functions as its conclusion), any variables declared within it\n   (which are bound in it), and so on, but it is not necessary to define\n   those details yet.  I mention them here merely so that the idea is not\n   lost.\n\n\n\n\nAccessibility\n\n\n\n\nA structure A is accessible to a structure B if some ancestor structure\n   of B (possibly B itself) is a sibling of A, but A is the (strictly)\n   earlier of the two siblings within their parent structure.\n\n\nEquivalently, we can speak of \"scope\" rather than accessibility.  The\n   scope of a structure A is all later siblings of A in the same parent,\n   along with all their descendants.  Thus B is in the scope of A iff A is\n   accessible to B.\n\n\n\n\nAttributes\n\n\n\n\nEvery structure contains a key-value dictionary called \nattributes,\n\n   which are read-only from the point of view of the LDE, and are\n   read-write from the point of view of the UI.  From the LDE's point of\n   view, they come from elsewhere (the UI).\n\n\n\n\nDocument\n\n\n\n\nThe entire document will be represented to the LDE as a single\n   structure, usually with a nonzero number of inner structures.\n\n\nWe call the representation of the entire document as a structure the LDE\n   Document, a phrase chosen to connote \"the LDE's view of the document,\n   not the one the user sees in the UI.\"\n\n\nOne main job of the UI is to convert from what the user sees into the\n   LDE Document.\n\n\nSo to the list of structure types above, add \"Document.\"\n\n\nThe entire LDE Document data structure will live inside the LDE module.\n   In the main Lurch app, this implies that the LDE Document will be stored\n   in the background thread where the LDE runs, not in the UI.  Thus the UI\n   will communicate across threads to create the LDE Document.  Details on\n   this later.\n\n\n\n\nSome brief UI comments\n\n\n\n\nMost of the purpose of the UI will be to convert the HTML document the\n   user sees into the LDE Document the LDE processes, then to show the user\n   in the HTML document and feedback the LDE sends back.\n\n\nIn service to that purpose, the UI contains many (largely independent\n  and usually small) features for encoding the HTML document into the\n  LDE Document.\n\n\nExamples include conventions for processing groups, connections,\n  numbered lists, section headings, finding meaning in text through\n  regular expressions, and the meanings of various LaTeX-like\n  \n\\shortcuts\n.\n\n\nA document author chooses which subset of these features to enable by\n  making choices in the document settings dialog.  Those settings are\n  stored in document metadata, and propagate to dependencies (defined\n  below).\n\n\nThe UI will have very little hard-coded (i.e., non-customizable)\n  procedures for interpreting the HTML document into the LDE document;\n  the settings above are highly choosable by the user.\n\n\nThe only constrained interpretation conventions (i.e., few or no\n  options for changing the interpretation) would be those that have\n  mathematical names, such as \"proof,\" which have a specific meaning\n  that it would be educationally counterproductive to interpret another\n  way.\n\n\nIn addition, we may choose a specific set of document settings to use\n  throughout the standard libraries that ship with Lurch, to show best\n  practices and help users with consistency and predictability.\n\n\n\n\n\n\nOther UI details:\n\n\nBecause we have a UI that allows users to make connections among\n  groups, the structures in the hierarchy may include, among their\n  attributes, a binary, edge-labeled multigraph.  (Note that this does\n  not require that every connection in the HTML document become two\n  Structures in the LDE Document with attributes connecting them.  Nor\n  does it stipulate that some concept--such as labeling--that we might\n  decide to represent as part of this multigraph can't also be\n  represented sometimes in another way as well.)\n\n\nIf we require the LDE to send a signal when validation completes,\n  then we can make a UI setting of whether to show feedback as the\n  feedback arrives, or only after the \"all validation complete\" signal\n  arrives (and thus feedback has stabilized).\n\n\n\n\n\n\n\n\nStructures are OOP Objects\n\n\n\n\nA structure exposes a set of data and methods about its internal state\n   to the rest of the app, in much the same way as Objects in OOP do, with\n   the type of structure (from the list above, e.g., Theorem or Example)\n   functioning as the \"class\" of the Object.\n\n\nSome methods in a structure will be time-intensive to run, and thus\n   should use an asynchronous paradigm, queueing the tasks for running when\n   the LDE thread has time.  The most time-intensive tasks, such as\n   matching and parsing, may be delegated to yet other background threads\n   by the LDE thread.\n\n\n\n\nExporting data from structures\n\n\n\n\nHere is an important example method that all structures should have\n   (though each class may implement it differently):\n\n\nA method that reports which structures (usually child structures of\n  A), if any, are to be made accessible to any structure B in the scope\n  of A (thus changing the normal scoping rules).\n\n\nThe flexibility inherent in the vagueness of this exporting notion is\n  useful.  For instance, a single theorem in the document might be\n  encoded in the LDE document as having many children, some of which\n  are its various interpretations as a rule of inference, and export\n  them all, so that any can be used/cited later.\n\n\nNote that the exports method need not copy child structures directly\n  for exporting.  It may combine/manipulate/compute structures to\n  export based on its children in any way.  Thus \"scope\" is a simple\n  and clean definition, which this function sort of indirectly extends.\n\n\n\n\n\n\nWe will define much of the functionality of the LDE as the various\n   structures in the document calling methods in one another, which is\n   simple and elegant.  But it requires that we carefully track and cache\n   the clean/dirty status of each structure, to retain efficiency.\n\n\n\n\nDependencies as a special case\n\n\n\n\nThe current paradigm (already implemented) in webLurch is that a\n   dependency must specify what data it exports to any document that\n   depends on it.\n\n\nSuch data will be stored in the dependency document's metadata, so that\n   documents depending on it can easily import it.  It will include\n   anything that the dependency imported from its dependencies, and so on\n   to arbitrary depth.\n\n\nBecause we now require every structure to know what it exports to later\n   structures, the question of what a document exports is simply a special\n   case of that.  The document is itself a structure, and thus it can\n   already answer the \"what does this document export?\" question.\n\n\nRecall from above that one of the pieces of data that a document will\n   export is its document settings, as described earlier.\n\n\n\n\nDesign Phases\n\n\n\n\nThe question, \"Which structure should be designed first?\" is tricky\n   because each structure is rather complex, and they're rather\n   interdependent.\n\n\nOne approach would be to design each structure incrementally, adding\n   features in phases.\n\n\nThus we might begin with an LDE implementation that has just a few\n   features for a few structure types, and yet is sufficient for building\n   very simply Lurch libraries.\n\n\nThis lets us build familiarity and knowledge as we do the design, so\n   we're better at it by the time we get to the hard stuff.\n\n\nPhases 2, 3, and so on can add features and structure types, thus\n   enabling more and more sophisticated Lurch libraries, until we have\n   reached the level of power that supports a first proof course.\n\n\n\n\nHow to design support for new concepts\n\n\n\n\nBegin with how the new concept will be represented in the Output Tree\n   (OT).  As you do so, respect these constraints.\n\n\nThe OT is pure data that the user never sees, so we are free to store\n  things there without concern for how they will appear to users.\n\n\nThe OT must support validation, so we are constrained to storing\n  things there in a way that makes it easy to write and maintain\n  validation algorithms.\n\n\nValidation is complicated, and yet it must be 100% airtight and\n  correct; therefore we don't want our data storage decisions to add\n  any unnecessary complexity to validation and/or the OT.\n\n\nAs a consequence, there should be one unique, canonical way to store\n  any given concept in the OT.\n\n\n\n\n\n\nThen ask \nbriefly\n how the concept will show up in the main Lurch UI.\n\n\nAdmit up front that it is something that will expand a lot with\n  time.  That is, whatever we design now will be the tip of the iceberg\n  of ideas that will occur to us over the coming years, and we should\n  accept that up front and plan for that as best we can.\n\n\nStart by listing the few ways that you already know that the new\n  feature will show up in the UI, simultaneously admitting that it is\n  just a sample of the ways that the feature might eventually appear.\n\n\n\n\n\n\nCome to the middle of the pipeline, the Input Tree (IT), whose job is to\n   bridge between the UI and the OT.  Recall that the UI will have many ways\n   to represent the new features, and the OT only one.  There are two steps\n   of translation between there that could possibly handle the conversion:\n   Should the UI-to-InputTree phase handle it, or should interpretation\n   handle it, or some combination?  Decide based on these guidelines:\n\n\nThe UI-to-IT conversion does not know about the array of accessible\n  nodes, nor does it know about any of their semantics.  Only the\n  interpretation phase can depend on the semantics of all nodes\n  accessible to the one being interpreted.  So if that information is\n  relevant, the computation must be pushed to the interpretation\n  phase.  For instance, if some feature needs to know what variables\n  are declared and in scope, it would need to wait for the\n  interpretation phase, which will have access to all accessible nodes,\n  including all declarations.\n\n\nOnly the UI knows about any of its features that are specific to that\n  UI.  For instance in the main UI, there may be features specific to\n  HTML and/or mouse events, or in a LaTeX package there may be features\n  specific to LaTeX.  Obviously such features must be handled in the\n  UI-to-IT conversion, because they depend upon the specific UI in\n  which they were invented.\n\n\nIf the previous guidelines do not apply, prefer doing the work in the\n  interpretation phase rather than the UI-to-IT phase, for these\n  reasons:\n\n\nDoing so makes the whole LDE better, rather than just making one\n     of its UIs better.\n\n\nThe interpretation phase can be converted into a queue and handled\n     efficiently, so adding computation burden to it is better than\n     adding computation burden where such efficiency measures are not\n     available.\n\n\nKeep in mind at all times that the features in the UI that\n  interpretation must support are just an example set that will grow\n  over time, so try to design an interpretation phase that can easily\n  be expanded also, to be ready for such later expansion in the UI.\n\n\n\n\n\n\n\n\nSee other documentation on this site for the contents of each design phase.", 
            "title": "Overview"
        }, 
        {
            "location": "/design-overview/#lde-design-overview", 
            "text": "This page lists the design principles adopted by the Lurch team to date\nregarding the LDE, with reasons and explanations for each.  This document\ncan be used as reference, and to guide development, but it may also be\nchanged as better ideas come along.  To see the specific phases of development planned for the LDE, and what's\ncompleted, use the \"Phases\" menu above.", 
            "title": "LDE Design Overview"
        }, 
        {
            "location": "/design-overview/#elegance-and-simplicity", 
            "text": "These are of utmost importance, because   they make Lurch easier to explain to students or in an Advanced User's\n   Guide (AUG),  they make Lurch easier to test because it has fewer unusual corner cases\n   or special handling of odd circumstances,  they make Lurch easier to implement for the same reason, and  they make it easier for us to be confident that our designs are good,\n   because they're easier to hold in your head and grok all at once.", 
            "title": "Elegance and Simplicity"
        }, 
        {
            "location": "/design-overview/#feedback-and-validation", 
            "text": "The primary purpose of the Lurch application is to give feedback to the\n   user about the work they type into their document.  Because this will often involve validating steps of work in a proof, we\n   may use the terms \"feedback\" and \"validation\" interchangeably, even\n   though technically validation is just a particular type of feedback\n   (though the most common type in our case).  One-Pass Validation (OPV)  is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   does so by reprocessing every bit of meaningful content from scratch, in\n   one (large, possibly time-consuming) pass over the whole document.  Real-Time Validation (RTV)  is a paradigm in which, whenever the app\n   needs to update feedback in response to changes made by the user, it\n   attempts to re-use as much information from previous validation as\n   possible, only updating those portions of it that need updating in\n   response to the specific change the user just made.  Thus RTV is\n   trickier to design and implement than OPV, but more efficient at\n   run-time.  An important concept for our test suite is that any RTV design can be\n   converted to an OPV design trivially, and then used for comparison\n   testing.  Simply replace all sophisticated RTV-style change event\n   handlers with OPV-style ones, that mark the entire document as needing\n   reprocessing.  Then any potential change that can be made to the user's\n   document can be run through each of these engines in parallel, and the\n   results compared for equivalence.  Note that the choice of OPV vs. RTV is independent of the choice of\n   manual validation vs. automatic validation.  RTV certainly makes\n   automatic validation nicer, and thus makes manual validation less\n   appealing, but you could choose anything from among\n    \\{\\text{OPV},\\text{RTV}\\}\\times\\{\\text{auto},\\text{manual}\\} .", 
            "title": "Feedback and Validation"
        }, 
        {
            "location": "/design-overview/#lde-and-ui", 
            "text": "We have a paradigm in which the UI is exactly that (user interface) and\n   the LDE (Lurch Deductive Engine) is the brain that operates in one or\n   more background threads, processing what the user has given the app\n   through the UI.  We aim to implement every feature in the LDE if possible, but implement\n   in the UI only those features that can't be implemented in the LDE.\n   Here, \"if possible\" means that it would not break the model-view\n   paradigm to implement it in the LDE (i.e., the LDE wouldn't need to\n   speak HTML).  Reasons for this:  The LDE will be implemented in pure JS, no DOM, so that it can be\n  used in a WebWorker and in the unit testing suite.  Therefore the bigger the LDE is, the more of our code has been\n  subject to rigorous unit tests.  And the bigger the LDE is, the more of our code is run out of the UX\n  thread, and thus the more responsive our app is.    The decisions recorded here are almost entirely about the design of the\n   LDE, not the UI.", 
            "title": "LDE and UI"
        }, 
        {
            "location": "/design-overview/#structures", 
            "text": "Define a  structure  to be the basic unit of meaning in the LDE.  This includes document-level structures such as a section,\n  subsection, proof, subproof, etc., which are analogous to block-level\n  items like DIV or P in HTML, and  \\begin{X}...\\end{X}  in LaTeX.  But it also includes inline structures (SPANs in HTML,  \\foo{...}  or\n   $...$  in LaTeX).  Structures can be nested acyclically.    Examples of types of structures that we may choose to define later:  Proofs/Subproofs, with one specific flavor of it being the kind that\n  declares a variable first  Definitions of rules, axioms, language rules  Formal systems (or \"mathematical topics\")  Theorems and pairing of them with proofs  Expressions  Maybe variables will be declared by based on placing a variable\n  inside an expression by itself, at the head of a variable declaration\n  subproof, or maybe by creating a new structure type for variable\n  declarations, or maybe something else  Homework problems  Examples (an environment in which anything you declare ends its scope\n  at the end of the example, no matter what it was)    The set of structure types should equal the set of common mathematical\n   structures that mathematics students should be learning anyway, and they\n   should behave the same in Lurch as in mathematics.  This ensures that\n   Lurch doesn't add to the mathematics learning curve in this sense.  Not every structure is permitted to contain every other type of\n   structure.  But such rules are enforced through validation, which we\n   will not be defining for some time yet, so this comment is just a\n   preview of what's to come.  For instance, expressions can contain only\n   other expressions.  At some later point, we may care about the meanings of structures, so\n   that they can be used as premises in proofs.  At such a time, we will\n   ensure that a structure's meaning includes the unjustified steps in the\n   structure (which function as premises), the final step in the structure\n   (which functions as its conclusion), any variables declared within it\n   (which are bound in it), and so on, but it is not necessary to define\n   those details yet.  I mention them here merely so that the idea is not\n   lost.", 
            "title": "Structures"
        }, 
        {
            "location": "/design-overview/#accessibility", 
            "text": "A structure A is accessible to a structure B if some ancestor structure\n   of B (possibly B itself) is a sibling of A, but A is the (strictly)\n   earlier of the two siblings within their parent structure.  Equivalently, we can speak of \"scope\" rather than accessibility.  The\n   scope of a structure A is all later siblings of A in the same parent,\n   along with all their descendants.  Thus B is in the scope of A iff A is\n   accessible to B.", 
            "title": "Accessibility"
        }, 
        {
            "location": "/design-overview/#attributes", 
            "text": "Every structure contains a key-value dictionary called  attributes, \n   which are read-only from the point of view of the LDE, and are\n   read-write from the point of view of the UI.  From the LDE's point of\n   view, they come from elsewhere (the UI).", 
            "title": "Attributes"
        }, 
        {
            "location": "/design-overview/#document", 
            "text": "The entire document will be represented to the LDE as a single\n   structure, usually with a nonzero number of inner structures.  We call the representation of the entire document as a structure the LDE\n   Document, a phrase chosen to connote \"the LDE's view of the document,\n   not the one the user sees in the UI.\"  One main job of the UI is to convert from what the user sees into the\n   LDE Document.  So to the list of structure types above, add \"Document.\"  The entire LDE Document data structure will live inside the LDE module.\n   In the main Lurch app, this implies that the LDE Document will be stored\n   in the background thread where the LDE runs, not in the UI.  Thus the UI\n   will communicate across threads to create the LDE Document.  Details on\n   this later.", 
            "title": "Document"
        }, 
        {
            "location": "/design-overview/#some-brief-ui-comments", 
            "text": "Most of the purpose of the UI will be to convert the HTML document the\n   user sees into the LDE Document the LDE processes, then to show the user\n   in the HTML document and feedback the LDE sends back.  In service to that purpose, the UI contains many (largely independent\n  and usually small) features for encoding the HTML document into the\n  LDE Document.  Examples include conventions for processing groups, connections,\n  numbered lists, section headings, finding meaning in text through\n  regular expressions, and the meanings of various LaTeX-like\n   \\shortcuts .  A document author chooses which subset of these features to enable by\n  making choices in the document settings dialog.  Those settings are\n  stored in document metadata, and propagate to dependencies (defined\n  below).  The UI will have very little hard-coded (i.e., non-customizable)\n  procedures for interpreting the HTML document into the LDE document;\n  the settings above are highly choosable by the user.  The only constrained interpretation conventions (i.e., few or no\n  options for changing the interpretation) would be those that have\n  mathematical names, such as \"proof,\" which have a specific meaning\n  that it would be educationally counterproductive to interpret another\n  way.  In addition, we may choose a specific set of document settings to use\n  throughout the standard libraries that ship with Lurch, to show best\n  practices and help users with consistency and predictability.    Other UI details:  Because we have a UI that allows users to make connections among\n  groups, the structures in the hierarchy may include, among their\n  attributes, a binary, edge-labeled multigraph.  (Note that this does\n  not require that every connection in the HTML document become two\n  Structures in the LDE Document with attributes connecting them.  Nor\n  does it stipulate that some concept--such as labeling--that we might\n  decide to represent as part of this multigraph can't also be\n  represented sometimes in another way as well.)  If we require the LDE to send a signal when validation completes,\n  then we can make a UI setting of whether to show feedback as the\n  feedback arrives, or only after the \"all validation complete\" signal\n  arrives (and thus feedback has stabilized).", 
            "title": "Some brief UI comments"
        }, 
        {
            "location": "/design-overview/#structures-are-oop-objects", 
            "text": "A structure exposes a set of data and methods about its internal state\n   to the rest of the app, in much the same way as Objects in OOP do, with\n   the type of structure (from the list above, e.g., Theorem or Example)\n   functioning as the \"class\" of the Object.  Some methods in a structure will be time-intensive to run, and thus\n   should use an asynchronous paradigm, queueing the tasks for running when\n   the LDE thread has time.  The most time-intensive tasks, such as\n   matching and parsing, may be delegated to yet other background threads\n   by the LDE thread.", 
            "title": "Structures are OOP Objects"
        }, 
        {
            "location": "/design-overview/#exporting-data-from-structures", 
            "text": "Here is an important example method that all structures should have\n   (though each class may implement it differently):  A method that reports which structures (usually child structures of\n  A), if any, are to be made accessible to any structure B in the scope\n  of A (thus changing the normal scoping rules).  The flexibility inherent in the vagueness of this exporting notion is\n  useful.  For instance, a single theorem in the document might be\n  encoded in the LDE document as having many children, some of which\n  are its various interpretations as a rule of inference, and export\n  them all, so that any can be used/cited later.  Note that the exports method need not copy child structures directly\n  for exporting.  It may combine/manipulate/compute structures to\n  export based on its children in any way.  Thus \"scope\" is a simple\n  and clean definition, which this function sort of indirectly extends.    We will define much of the functionality of the LDE as the various\n   structures in the document calling methods in one another, which is\n   simple and elegant.  But it requires that we carefully track and cache\n   the clean/dirty status of each structure, to retain efficiency.", 
            "title": "Exporting data from structures"
        }, 
        {
            "location": "/design-overview/#dependencies-as-a-special-case", 
            "text": "The current paradigm (already implemented) in webLurch is that a\n   dependency must specify what data it exports to any document that\n   depends on it.  Such data will be stored in the dependency document's metadata, so that\n   documents depending on it can easily import it.  It will include\n   anything that the dependency imported from its dependencies, and so on\n   to arbitrary depth.  Because we now require every structure to know what it exports to later\n   structures, the question of what a document exports is simply a special\n   case of that.  The document is itself a structure, and thus it can\n   already answer the \"what does this document export?\" question.  Recall from above that one of the pieces of data that a document will\n   export is its document settings, as described earlier.", 
            "title": "Dependencies as a special case"
        }, 
        {
            "location": "/design-overview/#design-phases", 
            "text": "The question, \"Which structure should be designed first?\" is tricky\n   because each structure is rather complex, and they're rather\n   interdependent.  One approach would be to design each structure incrementally, adding\n   features in phases.  Thus we might begin with an LDE implementation that has just a few\n   features for a few structure types, and yet is sufficient for building\n   very simply Lurch libraries.  This lets us build familiarity and knowledge as we do the design, so\n   we're better at it by the time we get to the hard stuff.  Phases 2, 3, and so on can add features and structure types, thus\n   enabling more and more sophisticated Lurch libraries, until we have\n   reached the level of power that supports a first proof course.", 
            "title": "Design Phases"
        }, 
        {
            "location": "/design-overview/#how-to-design-support-for-new-concepts", 
            "text": "Begin with how the new concept will be represented in the Output Tree\n   (OT).  As you do so, respect these constraints.  The OT is pure data that the user never sees, so we are free to store\n  things there without concern for how they will appear to users.  The OT must support validation, so we are constrained to storing\n  things there in a way that makes it easy to write and maintain\n  validation algorithms.  Validation is complicated, and yet it must be 100% airtight and\n  correct; therefore we don't want our data storage decisions to add\n  any unnecessary complexity to validation and/or the OT.  As a consequence, there should be one unique, canonical way to store\n  any given concept in the OT.    Then ask  briefly  how the concept will show up in the main Lurch UI.  Admit up front that it is something that will expand a lot with\n  time.  That is, whatever we design now will be the tip of the iceberg\n  of ideas that will occur to us over the coming years, and we should\n  accept that up front and plan for that as best we can.  Start by listing the few ways that you already know that the new\n  feature will show up in the UI, simultaneously admitting that it is\n  just a sample of the ways that the feature might eventually appear.    Come to the middle of the pipeline, the Input Tree (IT), whose job is to\n   bridge between the UI and the OT.  Recall that the UI will have many ways\n   to represent the new features, and the OT only one.  There are two steps\n   of translation between there that could possibly handle the conversion:\n   Should the UI-to-InputTree phase handle it, or should interpretation\n   handle it, or some combination?  Decide based on these guidelines:  The UI-to-IT conversion does not know about the array of accessible\n  nodes, nor does it know about any of their semantics.  Only the\n  interpretation phase can depend on the semantics of all nodes\n  accessible to the one being interpreted.  So if that information is\n  relevant, the computation must be pushed to the interpretation\n  phase.  For instance, if some feature needs to know what variables\n  are declared and in scope, it would need to wait for the\n  interpretation phase, which will have access to all accessible nodes,\n  including all declarations.  Only the UI knows about any of its features that are specific to that\n  UI.  For instance in the main UI, there may be features specific to\n  HTML and/or mouse events, or in a LaTeX package there may be features\n  specific to LaTeX.  Obviously such features must be handled in the\n  UI-to-IT conversion, because they depend upon the specific UI in\n  which they were invented.  If the previous guidelines do not apply, prefer doing the work in the\n  interpretation phase rather than the UI-to-IT phase, for these\n  reasons:  Doing so makes the whole LDE better, rather than just making one\n     of its UIs better.  The interpretation phase can be converted into a queue and handled\n     efficiently, so adding computation burden to it is better than\n     adding computation burden where such efficiency measures are not\n     available.  Keep in mind at all times that the features in the UI that\n  interpretation must support are just an example set that will grow\n  over time, so try to design an interpretation phase that can easily\n  be expanded also, to be ready for such later expansion in the UI.     See other documentation on this site for the contents of each design phase.", 
            "title": "How to design support for new concepts"
        }, 
        {
            "location": "/phase1-structures/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 1: Structures\n\n\nContent\n\n\nIn this phase, we just design the generic Structure class on which\neverything else will depend, and the infrastructure of the LDE itself.\n\n\nThe \nStructure\n module defines a single \nStructure\n class, and has been\nimplemented. \nIts API Documentation appears here\n.\n\n\nThe \nLDE\n module defines several global functions, and has been implemented.\n\nIts API Documentation appears here\n.\n\n\nGoal\n\n\nAt the end of this phase, we could write unit tests of the whole Structure\nclass and its LDE context, thus guaranteeing that all later phases rest on a\ngood foundation.\n\n\nStatus\n\n\nThis phase has been implemented and documented in the API Documentation,\nand then was thoroughly overhauled to match a new and updated design.  That\noverhaul is complete, and this phase is ready to be used in later phases.", 
            "title": "Phase 1, Structures"
        }, 
        {
            "location": "/phase1-structures/#lde-design-phase-1-structures", 
            "text": "", 
            "title": "LDE Design Phase 1: Structures"
        }, 
        {
            "location": "/phase1-structures/#content", 
            "text": "In this phase, we just design the generic Structure class on which\neverything else will depend, and the infrastructure of the LDE itself.  The  Structure  module defines a single  Structure  class, and has been\nimplemented.  Its API Documentation appears here .  The  LDE  module defines several global functions, and has been implemented. Its API Documentation appears here .", 
            "title": "Content"
        }, 
        {
            "location": "/phase1-structures/#goal", 
            "text": "At the end of this phase, we could write unit tests of the whole Structure\nclass and its LDE context, thus guaranteeing that all later phases rest on a\ngood foundation.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase1-structures/#status", 
            "text": "This phase has been implemented and documented in the API Documentation,\nand then was thoroughly overhauled to match a new and updated design.  That\noverhaul is complete, and this phase is ready to be used in later phases.", 
            "title": "Status"
        }, 
        {
            "location": "/phase2-input-tree/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 2: The Input Tree\n\n\nContent\n\n\nIn this phase, we add the Input Tree, a hierarchy comprised of a new kind of\n\nStructure\n subclass, called \nInputStructure\n.\n\n\nGoal\n\n\nThe \nInputStructure\n class will exist and be used by the LDE module.\n\n\nStatus\n\n\nThis has not been implemented.  See the tasks below.\n\n\nInputStructure\n class\n\n\n\n\n Create a subclass of \nStructure\n, in its own new module,\n   \nsrc/input-structure.litcoffee\n.\n\n\n Add documentation explaining what it is and will do (though that\n   documentation can grow with time).\n\n\n Ensure that the \nInputStructure\n subclass registers itself with the\n   serialization code, as\n   \nthe documentation here\n\n   describes.  (That is, use a line like\n   \nclassName : Structure.addSubclass 'InputStructure', InputStructure\n in\n   the \nInputStructure\n class code.)\n\n\n Rewrite the LDE module so that it no longer takes as input generic\n   \nStructure\n instances, but specifically \nInputStructure\n instances.  All\n   of its methods should be updated to use \nInputStructure\ns where they\n   currently use \nStructure\ns.  This will require importing the\n   \ninput-structure.litcoffee\n module instead of the generic\n   \nstructure.litcoffee\n one.\n\n\n Update all documentation in that file to reflect the changes just\n   made.\n\n\n Create a new unit test file for \nInputStructure\ns that is extremely\n   basic, just testing to be sure that the symbol \nInputStructure\n is\n   defined at the global scope and creates things that are instances of the\n   generic \nStructure\n base class.\n\n\n Add documentation for that unit test file, following the pattern\n   established in the documentation of other unit test files in this\n   repository.\n\n\n Update all unit tests of the LDE module to reflect this change to\n   \nInputStructure\ns.  This will require importing the\n   \ninput-structure.litcoffee\n module instead of the generic\n   \nstructure.litcoffeee\n one.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nAccepting actual instances\n\n\n\n\n The LDE module was written to accept only JSON-serialized forms of\n   \nStructure\ns as parameters to its methods.  Update those functions so\n   that they now accept either serialized forms or actual instances, and can\n   tell the difference and respond appropriately.  (That is, deserialize any\n   serialized instances, but don't do that if the argument was already an\n   instance.)\n\n\n Extend the unit test suite of the LDE module so that it tests this\n   new feature of each API method of the LDE module.\n\n\n Update all documentation in that file to reflect the changes just\n   made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nMarking structures dirty\n\n\n\n\n Extend the \nInputStructure\n class with a field called \ndirty\n, which\n   is initialized to false in the constructor.  This field does not need to\n   be part of any serialization or deserialization of instances.\n\n\n Create an \nisDirty()\n method that returns the value of that member\n   variable.\n\n\n Create a \nmarkDirty()\n method in the \nInputStructure\n class that sets\n   the \ndirty\n flag to true, and does so for all ancestors as well.\n\n\n Update all documentation in that file to reflect the changes just\n   made.\n\n\n Add to the unit tests for \nInputStructure\ns a few simple tests for\n   these new routines.\n\n\n Add documentation in that file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.", 
            "title": "Phase 2, The Input Tree"
        }, 
        {
            "location": "/phase2-input-tree/#lde-design-phase-2-the-input-tree", 
            "text": "", 
            "title": "LDE Design Phase 2: The Input Tree"
        }, 
        {
            "location": "/phase2-input-tree/#content", 
            "text": "In this phase, we add the Input Tree, a hierarchy comprised of a new kind of Structure  subclass, called  InputStructure .", 
            "title": "Content"
        }, 
        {
            "location": "/phase2-input-tree/#goal", 
            "text": "The  InputStructure  class will exist and be used by the LDE module.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase2-input-tree/#status", 
            "text": "This has not been implemented.  See the tasks below.", 
            "title": "Status"
        }, 
        {
            "location": "/phase2-input-tree/#inputstructure-class", 
            "text": "Create a subclass of  Structure , in its own new module,\n    src/input-structure.litcoffee .   Add documentation explaining what it is and will do (though that\n   documentation can grow with time).   Ensure that the  InputStructure  subclass registers itself with the\n   serialization code, as\n    the documentation here \n   describes.  (That is, use a line like\n    className : Structure.addSubclass 'InputStructure', InputStructure  in\n   the  InputStructure  class code.)   Rewrite the LDE module so that it no longer takes as input generic\n    Structure  instances, but specifically  InputStructure  instances.  All\n   of its methods should be updated to use  InputStructure s where they\n   currently use  Structure s.  This will require importing the\n    input-structure.litcoffee  module instead of the generic\n    structure.litcoffee  one.   Update all documentation in that file to reflect the changes just\n   made.   Create a new unit test file for  InputStructure s that is extremely\n   basic, just testing to be sure that the symbol  InputStructure  is\n   defined at the global scope and creates things that are instances of the\n   generic  Structure  base class.   Add documentation for that unit test file, following the pattern\n   established in the documentation of other unit test files in this\n   repository.   Update all unit tests of the LDE module to reflect this change to\n    InputStructure s.  This will require importing the\n    input-structure.litcoffee  module instead of the generic\n    structure.litcoffeee  one.   Once the unit tests pass, build everything and commit.", 
            "title": "InputStructure class"
        }, 
        {
            "location": "/phase2-input-tree/#accepting-actual-instances", 
            "text": "The LDE module was written to accept only JSON-serialized forms of\n    Structure s as parameters to its methods.  Update those functions so\n   that they now accept either serialized forms or actual instances, and can\n   tell the difference and respond appropriately.  (That is, deserialize any\n   serialized instances, but don't do that if the argument was already an\n   instance.)   Extend the unit test suite of the LDE module so that it tests this\n   new feature of each API method of the LDE module.   Update all documentation in that file to reflect the changes just\n   made.   Once the unit tests pass, build everything and commit.", 
            "title": "Accepting actual instances"
        }, 
        {
            "location": "/phase2-input-tree/#marking-structures-dirty", 
            "text": "Extend the  InputStructure  class with a field called  dirty , which\n   is initialized to false in the constructor.  This field does not need to\n   be part of any serialization or deserialization of instances.   Create an  isDirty()  method that returns the value of that member\n   variable.   Create a  markDirty()  method in the  InputStructure  class that sets\n   the  dirty  flag to true, and does so for all ancestors as well.   Update all documentation in that file to reflect the changes just\n   made.   Add to the unit tests for  InputStructure s a few simple tests for\n   these new routines.   Add documentation in that file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Marking structures dirty"
        }, 
        {
            "location": "/phase3-interpretation/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 3: Interpretation\n\n\nContent\n\n\nIn this phase, we add a very rudimentary \nOutputStructure\n class, and\nmethods in the Input Tree to generate it by interpreting the contents of the\ninput.\n\n\nGoal\n\n\nThe \nOutputStructure\n class will exist and a hierarchy of such things will\nbe created by the Input Tree.\n\n\nStatus\n\n\nThis has not been implemented.  See the tasks below.\n\n\nOutputStructure\n class\n\n\n\n\n Create a subclass of \nStructure\n, in its own new module,\n   \nsrc/output-structure.litcoffee\n.\n\n\n Add documentation explaining what it is and will do (though that\n   documentation can grow with time).\n\n\n Ensure that the \nOutputStructure\n subclass registers itself with the\n   serialization code, as\n   \nthe documentation here\n\n   describes.  (That is, use a line like\n   \nclassName : Structure.addSubclass 'OutputStructure', OutputStructure\n in\n   the \nOutputStructure\n class code.)\n\n\n Ensure that the LDE module also imports the\n   \noutput-structure.litcoffee\n module in addition to the\n   \ninput-structure.litcoffee\n one.\n\n\n Update all documentation in that file to reflect the changes just\n   made.\n\n\n Create a new unit test file for \nOutputStructure\ns that is extremely\n   basic, just testing to be sure that the symbol \nOutputStructure\n is\n   defined at the global scope and creates things that are instances of the\n   generic \nStructure\n base class.\n\n\n Add documentation for that unit test file, following the pattern\n   established in the documentation of other unit test files in this\n   repository.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nBuilding interpretation routines\n\n\n\n\n Create an \ninterpret\n routine in the \nInputStructure\n class that\n   takes two arguments, \naccessibles\n (a list of \nOutputStructure\ns\n   accessible to the \nInputStructure\n in question) and \nchildResults\n (a\n   list of lists of \nOutputStructure\n instances that were generated by\n   recursive interpretation calls).  The implementation in this base class\n   should be to create a generic \nOutputStructure\n instance and flatten all\n   the \nchildResults\n arrays into it as children, in order.  Pseudocode:\n\n\n\n\nlet result = new OutputStructure() // plain vanilla wrapper node\nfor each childArray in childResults:\n    for each node in childArray:\n        result.appendChild( node ) // put everything in it\n        return [ result ] // return an array of exactly one tree\n\n\n\n\n\n\n Add documentation in that file describing the changes just made.\n\n\n Extend the unit tests for the \nInputStructure\n module to include some\n   calls to this routine, passing it various example parameters and\n   verifying that it does its job as specified.\n\n\n Add documentation in that test file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n Add documentation stating the limitations on how subclasses are\n   permitted to override the \ninterpret\n routine from the \nInputStructure\n\n   class.  Specifically, the following rules must be obeyed:\n\n\nFor any two nodes A and B in the output tree, if A was created by\n  \nX.interpret()\n and B was created by \nY.interpret()\n, and A is an\n  ancestor of B, then X must be an ancestor of Y.\n\n\nFor any two nodes A and B in the output tree, if A was created by\n  \nX.interpret()\n and B was created by \nY.interpret()\n, and A has any\n  ancestor that is an earlier sibling of any ancestor of B, then X must\n  have an ancestor that is an earlier sibling of some ancestor of Y.\n\n\nIf \nX.interpret()\n calls \nY.markDirty()\n, then X must be accessible\n  to Y.\n\n\nThe result of \nX.interpret()\n may be contingent only upon the\n  following data.  (This is made easy by passing this stuff as\n  parameters to \nX.interpret()\n.  So as long as it just uses its\n  parameters and children, and doesn't go seeking out other data, this\n  rule is automatically followed.)\n\n\nAny descendant \nInputStructure\n Y of X, including (naturally) its\n     most recently computed interpretation.  (Note that X is not\n     accessible to any such Y.)\n\n\nAny \nInputStructure\n Y accessible to X, optionally with its most\n     recently computed interpretation as well.  (Note that this does not\n     include ancestors of X.)\n\n\n\n\n\n\n Rebuild the docs and commit.\n\n\n\n\nCaching interpretation results\n\n\n\n\n Extend the \nInputStructure\n class with a field called\n   \nlastInterpretation\n, which is initialized to undefined in the\n   constructor.  This field does not need to be part of any serialization\n   or deserialization of instances.\n\n\n Create an \ninterpretation()\n method that returns the value of\n   that member variable.\n\n\n Create a \nsaveInterpretation(S)\n method in the \nInputStructure\n class\n   that stores \nOutputStructure\n \nS\n in the \nlastInterpretation\n field.  If\n   no parameter \nS\n is passed, replace the cached value with undefined.\n\n\n Update all documentation in that file to reflect the changes just\n   made.\n\n\n Add to the unit tests for \nInputStructure\ns a few simple tests for\n   these new routines.\n\n\n Add documentation in that file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nBuilding recursive interpretation\n\n\n\n\n Create a \nrecursiveInterpret\n routine in the \nInputStructure\n class\n   that takes one argument, \naccessibles\n (with the same meaning as in the\n   \ninterpret\n routine).  This argument should default to an empty array.\n   Pseudocode:\n\n\n\n\n// use the cache if it's there:\nif my lastInterpretation() is not undefined, return that and quit\notherwise...\n// remember the size of accessibles for later:\nlet L = the current length of the accessibles array.\n// we will be recursively computing child result arrays,\n// and will want to keep a list of them, so initialize that list to empty:\nlet allChildResults = [ ]\n// now the loop for the recursive work:\nfor each child C of X do the following:\n    // do the recursion.\n    // note that for the first child, the same list of accessibles for the\n    // parent applies to that child:\n    let childResult = C.recursiveInterpret( accessibles )\n    // but for later children, more things are accessible.  specifically,\n    // anything just created by interpreting C should be accessible to\n    // C.nextSibling(), so:\n    let accessibles = the concatenation of accessibles\n        with childResult (thus extending accessibles)\n    // and of course remember the result of the recursive call we just made:\n    append childResult as a new entry to the end of allChildResults\n        // (which is an array of arrays)\n// now that we're done recurring,\n// we want to restore the accessibles array to its old state:\nlet accessibles = just the first L entries of accessibles\n    // (restoring it to what it was at the start of this routine)\n// this is because we will now ask this node X to interpret itself in\n// light of (a) what's accessible to it and (b) all the recursive\n// results of interpreting its children.\n// So we need the right accessibles array to do this:\nsaveInterpretation( X.interpret( accessibles, allChildResults ) )\nmark X as no longer dirty\nthen return lastInterpretation() as the result of this function\n\n\n\n\n\n\n Add documentation in that file describing the changes just made.\n\n\n Extend the unit tests for the \nInputStructure\n module to include some\n   calls to this routine, passing it various example parameters and\n   verifying that it does its job as specified.\n\n\n Write more unit tests that create and register some dummy subclasses\n   of \nInputStructure\n that have example custom \ninterpret\n routines.\n   Verify that those routines get called and do exactly what's expected in\n   the creation of their portion of the Output Tree.  Ensure you test a\n   variety of different kinds of \ninterpret\n routines, including ones that\n   copy or create attributes, delete children, don't include the default\n   wrapper, etc.\n\n\n Add documentation in that test file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nCalling interpretation routines\n\n\n\n\n In the LDE module, in every one of the four functions it exposes as\n   part of its API, extend the function so that it calls \n.markDirty()\n on\n   the appropriate \nInputStructure\n instance, then\n   \n.recursiveInterpret()\n on the root of the LDE document (the Input Tree).\n\n\n Update the documentation in that file to describe the changes just\n   made.\n\n\n Extend the unit tests for the LDE module to verify that this\n   assembles an Output Tree that (by default) has exactly the same structure\n   as the Input Tree (but no actual content, just base class nodes).\n\n\n Write more unit tests that create and register some dummy subclasses\n   of \nInputStructure\n that have example custom \ninterpret\n routines.\n   Verify that those routines get called and do exactly what's expected in\n   the creation of the Output Tree.  Ensure you test a variety of different\n   kinds of \ninterpret\n routines, as you did in the previous section.\n\n\n Add documentation in that test file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nTracking origins\n\n\n\n\n Create a class variable in the \nInputStructure\n class called\n   \ninstanceBeingInterpreted\n that is initialized to null.\n\n\n Extend the \nrecursiveInterpret\n routine so that, before each call to\n   \nX.interpret()\n, it sets \ninstanceBeingInterpreted\n to \nX\n, then sets it\n   back to null after \nX.interpret()\n is complete.\n\n\n Extend the constructor for \nOutputStructure\n nodes so that, if the\n   global \nInputStructure\n class is defined, and its\n   \ninstanceBeingInterpreted\n variable is non-null, then that instance is\n   stored within the newly constructed \nOutputStructure\n in a field called\n   \norigin\n.  Otherwise, \norigin\n should be undefined (or null, whatever).\n\n\n Extend the unit tests for the LDE module to verify that Output Trees\n   now have, in each of their nodes, the correct origin node from the Input\n   Tree that gave rise to that \nOutputStructure\n.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nFeedback messages\n\n\n\n\n Add a function to the LDE module that can be called whenever the\n   Input Tree wants to communicate to the UI some attribute of a node in the\n   Input Tree.  That function will send a message (to any listening client)\n   containing the ID of the node and a key-value pair for the attribute in\n   question.\n\n\n Extend each of the LDE module's API functions so that, when any new\n   \nInputStructure\n instances are added in the Input Tree, we recursively go\n   through them and all their descendants, and set their \nwasChanged\n event\n   handlers to call that global message sending function.  It should not\n   filter out any such messages by default; rather, the LDE can make\n   guarantees in its documentation about certain attribute keys that\n   follow certain rules, and the UI can choose whichever subset of those\n   keys it wants to watch for and display to the user in some way.  This\n   will include feedback about validation, but may include other things as\n   well.  Example:\n\n\nConsider a step of work that needs two premises, but none were cited,\n  and the option is enabled that lets Lurch seek the premises automatically.\n\n\nSo Lurch fills in the preceding two steps as the reasons, and as it\n  does so, it might store in one of the step's attributes the fact that\n  it auto-filled, as the premises, those two preceding steps.\n\n\nA user interface might choose to implement a feature that watched for\n  when such an attribute appears on an OT node, and then display the\n  meaning of that attribute to the user, perhaps by showing\n  faint/dotted arrows connecting the step to its auto-inserted premises.\n\n\nIn other words, when premises aren't provided, the user will just see\n  ghostly connections that communicate what the LDE inferred.  No more\n  mystery about which premises are auto-filled.\n\n\n\n\n\n\n Update the documentation in that file to describe the changes just\n   made.\n\n\n Extend the unit tests for the LDE module to verify that this\n   works as described.  (Change attributes of some nodes in the Input Tree\n   and verify that messages are sent by the LDE to that effect.)\n\n\n Add documentation in that test file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.", 
            "title": "Phase 3, Interpretation"
        }, 
        {
            "location": "/phase3-interpretation/#lde-design-phase-3-interpretation", 
            "text": "", 
            "title": "LDE Design Phase 3: Interpretation"
        }, 
        {
            "location": "/phase3-interpretation/#content", 
            "text": "In this phase, we add a very rudimentary  OutputStructure  class, and\nmethods in the Input Tree to generate it by interpreting the contents of the\ninput.", 
            "title": "Content"
        }, 
        {
            "location": "/phase3-interpretation/#goal", 
            "text": "The  OutputStructure  class will exist and a hierarchy of such things will\nbe created by the Input Tree.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase3-interpretation/#status", 
            "text": "This has not been implemented.  See the tasks below.", 
            "title": "Status"
        }, 
        {
            "location": "/phase3-interpretation/#outputstructure-class", 
            "text": "Create a subclass of  Structure , in its own new module,\n    src/output-structure.litcoffee .   Add documentation explaining what it is and will do (though that\n   documentation can grow with time).   Ensure that the  OutputStructure  subclass registers itself with the\n   serialization code, as\n    the documentation here \n   describes.  (That is, use a line like\n    className : Structure.addSubclass 'OutputStructure', OutputStructure  in\n   the  OutputStructure  class code.)   Ensure that the LDE module also imports the\n    output-structure.litcoffee  module in addition to the\n    input-structure.litcoffee  one.   Update all documentation in that file to reflect the changes just\n   made.   Create a new unit test file for  OutputStructure s that is extremely\n   basic, just testing to be sure that the symbol  OutputStructure  is\n   defined at the global scope and creates things that are instances of the\n   generic  Structure  base class.   Add documentation for that unit test file, following the pattern\n   established in the documentation of other unit test files in this\n   repository.   Once the unit tests pass, build everything and commit.", 
            "title": "OutputStructure class"
        }, 
        {
            "location": "/phase3-interpretation/#building-interpretation-routines", 
            "text": "Create an  interpret  routine in the  InputStructure  class that\n   takes two arguments,  accessibles  (a list of  OutputStructure s\n   accessible to the  InputStructure  in question) and  childResults  (a\n   list of lists of  OutputStructure  instances that were generated by\n   recursive interpretation calls).  The implementation in this base class\n   should be to create a generic  OutputStructure  instance and flatten all\n   the  childResults  arrays into it as children, in order.  Pseudocode:   let result = new OutputStructure() // plain vanilla wrapper node\nfor each childArray in childResults:\n    for each node in childArray:\n        result.appendChild( node ) // put everything in it\n        return [ result ] // return an array of exactly one tree    Add documentation in that file describing the changes just made.   Extend the unit tests for the  InputStructure  module to include some\n   calls to this routine, passing it various example parameters and\n   verifying that it does its job as specified.   Add documentation in that test file describing the changes just made.   Once the unit tests pass, build everything and commit.   Add documentation stating the limitations on how subclasses are\n   permitted to override the  interpret  routine from the  InputStructure \n   class.  Specifically, the following rules must be obeyed:  For any two nodes A and B in the output tree, if A was created by\n   X.interpret()  and B was created by  Y.interpret() , and A is an\n  ancestor of B, then X must be an ancestor of Y.  For any two nodes A and B in the output tree, if A was created by\n   X.interpret()  and B was created by  Y.interpret() , and A has any\n  ancestor that is an earlier sibling of any ancestor of B, then X must\n  have an ancestor that is an earlier sibling of some ancestor of Y.  If  X.interpret()  calls  Y.markDirty() , then X must be accessible\n  to Y.  The result of  X.interpret()  may be contingent only upon the\n  following data.  (This is made easy by passing this stuff as\n  parameters to  X.interpret() .  So as long as it just uses its\n  parameters and children, and doesn't go seeking out other data, this\n  rule is automatically followed.)  Any descendant  InputStructure  Y of X, including (naturally) its\n     most recently computed interpretation.  (Note that X is not\n     accessible to any such Y.)  Any  InputStructure  Y accessible to X, optionally with its most\n     recently computed interpretation as well.  (Note that this does not\n     include ancestors of X.)     Rebuild the docs and commit.", 
            "title": "Building interpretation routines"
        }, 
        {
            "location": "/phase3-interpretation/#caching-interpretation-results", 
            "text": "Extend the  InputStructure  class with a field called\n    lastInterpretation , which is initialized to undefined in the\n   constructor.  This field does not need to be part of any serialization\n   or deserialization of instances.   Create an  interpretation()  method that returns the value of\n   that member variable.   Create a  saveInterpretation(S)  method in the  InputStructure  class\n   that stores  OutputStructure   S  in the  lastInterpretation  field.  If\n   no parameter  S  is passed, replace the cached value with undefined.   Update all documentation in that file to reflect the changes just\n   made.   Add to the unit tests for  InputStructure s a few simple tests for\n   these new routines.   Add documentation in that file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Caching interpretation results"
        }, 
        {
            "location": "/phase3-interpretation/#building-recursive-interpretation", 
            "text": "Create a  recursiveInterpret  routine in the  InputStructure  class\n   that takes one argument,  accessibles  (with the same meaning as in the\n    interpret  routine).  This argument should default to an empty array.\n   Pseudocode:   // use the cache if it's there:\nif my lastInterpretation() is not undefined, return that and quit\notherwise...\n// remember the size of accessibles for later:\nlet L = the current length of the accessibles array.\n// we will be recursively computing child result arrays,\n// and will want to keep a list of them, so initialize that list to empty:\nlet allChildResults = [ ]\n// now the loop for the recursive work:\nfor each child C of X do the following:\n    // do the recursion.\n    // note that for the first child, the same list of accessibles for the\n    // parent applies to that child:\n    let childResult = C.recursiveInterpret( accessibles )\n    // but for later children, more things are accessible.  specifically,\n    // anything just created by interpreting C should be accessible to\n    // C.nextSibling(), so:\n    let accessibles = the concatenation of accessibles\n        with childResult (thus extending accessibles)\n    // and of course remember the result of the recursive call we just made:\n    append childResult as a new entry to the end of allChildResults\n        // (which is an array of arrays)\n// now that we're done recurring,\n// we want to restore the accessibles array to its old state:\nlet accessibles = just the first L entries of accessibles\n    // (restoring it to what it was at the start of this routine)\n// this is because we will now ask this node X to interpret itself in\n// light of (a) what's accessible to it and (b) all the recursive\n// results of interpreting its children.\n// So we need the right accessibles array to do this:\nsaveInterpretation( X.interpret( accessibles, allChildResults ) )\nmark X as no longer dirty\nthen return lastInterpretation() as the result of this function    Add documentation in that file describing the changes just made.   Extend the unit tests for the  InputStructure  module to include some\n   calls to this routine, passing it various example parameters and\n   verifying that it does its job as specified.   Write more unit tests that create and register some dummy subclasses\n   of  InputStructure  that have example custom  interpret  routines.\n   Verify that those routines get called and do exactly what's expected in\n   the creation of their portion of the Output Tree.  Ensure you test a\n   variety of different kinds of  interpret  routines, including ones that\n   copy or create attributes, delete children, don't include the default\n   wrapper, etc.   Add documentation in that test file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Building recursive interpretation"
        }, 
        {
            "location": "/phase3-interpretation/#calling-interpretation-routines", 
            "text": "In the LDE module, in every one of the four functions it exposes as\n   part of its API, extend the function so that it calls  .markDirty()  on\n   the appropriate  InputStructure  instance, then\n    .recursiveInterpret()  on the root of the LDE document (the Input Tree).   Update the documentation in that file to describe the changes just\n   made.   Extend the unit tests for the LDE module to verify that this\n   assembles an Output Tree that (by default) has exactly the same structure\n   as the Input Tree (but no actual content, just base class nodes).   Write more unit tests that create and register some dummy subclasses\n   of  InputStructure  that have example custom  interpret  routines.\n   Verify that those routines get called and do exactly what's expected in\n   the creation of the Output Tree.  Ensure you test a variety of different\n   kinds of  interpret  routines, as you did in the previous section.   Add documentation in that test file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Calling interpretation routines"
        }, 
        {
            "location": "/phase3-interpretation/#tracking-origins", 
            "text": "Create a class variable in the  InputStructure  class called\n    instanceBeingInterpreted  that is initialized to null.   Extend the  recursiveInterpret  routine so that, before each call to\n    X.interpret() , it sets  instanceBeingInterpreted  to  X , then sets it\n   back to null after  X.interpret()  is complete.   Extend the constructor for  OutputStructure  nodes so that, if the\n   global  InputStructure  class is defined, and its\n    instanceBeingInterpreted  variable is non-null, then that instance is\n   stored within the newly constructed  OutputStructure  in a field called\n    origin .  Otherwise,  origin  should be undefined (or null, whatever).   Extend the unit tests for the LDE module to verify that Output Trees\n   now have, in each of their nodes, the correct origin node from the Input\n   Tree that gave rise to that  OutputStructure .   Once the unit tests pass, build everything and commit.", 
            "title": "Tracking origins"
        }, 
        {
            "location": "/phase3-interpretation/#feedback-messages", 
            "text": "Add a function to the LDE module that can be called whenever the\n   Input Tree wants to communicate to the UI some attribute of a node in the\n   Input Tree.  That function will send a message (to any listening client)\n   containing the ID of the node and a key-value pair for the attribute in\n   question.   Extend each of the LDE module's API functions so that, when any new\n    InputStructure  instances are added in the Input Tree, we recursively go\n   through them and all their descendants, and set their  wasChanged  event\n   handlers to call that global message sending function.  It should not\n   filter out any such messages by default; rather, the LDE can make\n   guarantees in its documentation about certain attribute keys that\n   follow certain rules, and the UI can choose whichever subset of those\n   keys it wants to watch for and display to the user in some way.  This\n   will include feedback about validation, but may include other things as\n   well.  Example:  Consider a step of work that needs two premises, but none were cited,\n  and the option is enabled that lets Lurch seek the premises automatically.  So Lurch fills in the preceding two steps as the reasons, and as it\n  does so, it might store in one of the step's attributes the fact that\n  it auto-filled, as the premises, those two preceding steps.  A user interface might choose to implement a feature that watched for\n  when such an attribute appears on an OT node, and then display the\n  meaning of that attribute to the user, perhaps by showing\n  faint/dotted arrows connecting the step to its auto-inserted premises.  In other words, when premises aren't provided, the user will just see\n  ghostly connections that communicate what the LDE inferred.  No more\n  mystery about which premises are auto-filled.     Update the documentation in that file to describe the changes just\n   made.   Extend the unit tests for the LDE module to verify that this\n   works as described.  (Change attributes of some nodes in the Input Tree\n   and verify that messages are sent by the LDE to that effect.)   Add documentation in that test file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Feedback messages"
        }, 
        {
            "location": "/phase4-validation/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 4: Validation\n\n\nContent\n\n\nIn this phase, we extend the formerly rudimentary \nOutputStructure\n class\nwith its most important functionality: validating steps of work.\n\n\nGoal\n\n\nInstance of the \nOutputStructure\n class will automatically validate\nthemselves as they are added to the Output Tree.\n\n\nStatus\n\n\nThis has not been implemented.  See the tasks below.\n\n\nAutomatic validation enqueueing\n\n\n\n\n Define a class variable in the \nOutputStructure\n class, an array of\n   all instances that need to be validated.  Initialize it to the empty\n   array.\n\n\n Extend the \nrecursiveInterpret\n routine so that, for any\n   \nOutputStructure\n instances it had to create (not just re-use from its\n   cache), if any of them are also \nOutputStep\n instances, then add them to\n   the to-validate list.  (The \nOutputStep\n class does not yet exist.  Make\n   it a stub for now, and come back to fully implementing it in\n   \nphase 7\n.)\n\n\n Add documentation in those files describing the changes just made.\n\n\n Extend the unit tests for the \nInputStructure\n module to verify\n   that this works as described.\n\n\n Add documentation in that test file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nAutomatic validation processing\n\n\n\n\n In the LDE module, run \nsetInterval()\n at module creation so that it\n   regularly (many times per second, but not so often as to consume copious\n   CPU) checks to see if there is anything on the list of \nOutputStructure\n\n   instances to be validated.  If there are any such things, call their\n   \nvalidate\n routines (which are asynchronous).  The order in which these\n   are processed is irrelevant.\n\n\n Add documentation in that file describing the changes just made.\n\n\n Extend the unit tests for the LDE module to verify that this works\n   as described.  That is, create some \nOutputStep\n subclasses and some\n   \nInputStructure\n subclasses whose \ninterpret\n routines produce instances\n   of those classes.  Verify that validation actually does take place.\n\n\n Add documentation in that test file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nFeedback messages\n\n\n\n\n Add a function to the LDE module that can be called whenever an\n   attribute of an \nOutputStructure\n in the Output Tree changes, and the\n   function will send a message (to any listening client) containing the ID\n   of the origin of the node whose attribute changed, and the key-value pair\n   of the changed attribute.\n\n\n Update the documentation in that file to describe the changes just\n   made.\n\n\n Extend the unit tests for the LDE module to verify that this\n   works as described.  First, simply, just change an attribute of some\n   nodes in the Output Tree and verify that messages are sent by the LDE to\n   that effect.  Then extend the tests that go from API calls to validation\n   results to ensure that the entire process works, from API calls that add\n   to the Input Tree to feedback messages from validation being transmitted\n   back.\n\n\n Add documentation in that test file describing the changes just made.\n\n\n Once the unit tests pass, build everything and commit.\n\n\n\n\nConclusions\n\n\nWe now stipulate and prove a few facts about the preceding design.\n\n\nAxiom 1:\n Lurch creates an \nInputStructure\n from a portion of the user's\ndocument iff that portion is meaningful.\n\n\nRemark:\n This is the job of the UI, with the assistance of the user's\nsettings.  So in some sense this axiom is aspirational, or conditioned upon\nthe assumption that we can provide a robust enough set of UI settings to\ncapture user meaning correctly.\n\n\nAxiom 2:\n Lurch performs interpretation on every \nInputStructure\n\ncreated by the UI, and on nothing else.\n\n\nRemark:\n The design so far has included this as an obvious goal.  Here\nwe just explicitly state it.\n\n\nTheorem 1:\n Lurch does syntactic validation on X iff X corresponds to a piece of meaningful content in the user's document.\n\n\nProof:\n Syntactic validation is a part of interpretation, which by Axiom\n2 gets applied to every \nInputStructure\n, and to nothing else.  By Axiom 1,\nthose \nInputStructure\ns correspond directly to the meaningful content in\nthe user's document.  QED\n\n\nAxiom 3:\n Both the creation and interpretation of \nInputStructure\ns faithfully preserve meaning.\n\n\nRemark:\n That is, neither the UI nor the interpretation phase will\nconvert a premise into a rule, or a grammar rule into a subproof, or any\nother crazy change of meaning.  This is simply a commitment for us to design\nLurch to do what seems mathematically normal and natural to mathematicians\nand math students, as human users of the software.  It's a bit strange to\neven state this rather obvious axiom, but it is needed in the proof of\nTheorem 2.\n\n\nTheorem 2:\n Lurch does semantic validation on X iff X corresponds to a\nsyntactically valid step of work in the user's document.\n\n\nProof:\n Assume X is a syntactically valid step of work in the document.\nThen by Axiom 1, it will become an \nInputStructure\n, and by Axiom 3, it\nwill more precisely have the type of data that lets the LDE know that it is\na step of work.  By Axiom 2, that step will be interpreted, and by Axiom 3,\nthe result will be an \nOutputStep\n.  That \nOutputStep\n will have syntactic\nvalidation performed on it, because of the definition of validation\nenqueueing given above.\n\n\nIn the other direction, assume Lurch does semantic validation on X.  Then by\nthe definition of validation enqueueing above, X must be an \nOutputStep\n.\nOur design permits creation of \nOutputStructure\ns only through\ninterpretation, and by Axiom 3, the interpretation step that created X must\nhave taken as input some \nInputStructure\n that has all the data indicating\nit is a step of work.  By Axiom 1, that must have come from some meaningful\nportion of the user's document, and by Axiom 3, that in-document content\nmust have represented a step of work.  QED", 
            "title": "Phase 4, Validation"
        }, 
        {
            "location": "/phase4-validation/#lde-design-phase-4-validation", 
            "text": "", 
            "title": "LDE Design Phase 4: Validation"
        }, 
        {
            "location": "/phase4-validation/#content", 
            "text": "In this phase, we extend the formerly rudimentary  OutputStructure  class\nwith its most important functionality: validating steps of work.", 
            "title": "Content"
        }, 
        {
            "location": "/phase4-validation/#goal", 
            "text": "Instance of the  OutputStructure  class will automatically validate\nthemselves as they are added to the Output Tree.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase4-validation/#status", 
            "text": "This has not been implemented.  See the tasks below.", 
            "title": "Status"
        }, 
        {
            "location": "/phase4-validation/#automatic-validation-enqueueing", 
            "text": "Define a class variable in the  OutputStructure  class, an array of\n   all instances that need to be validated.  Initialize it to the empty\n   array.   Extend the  recursiveInterpret  routine so that, for any\n    OutputStructure  instances it had to create (not just re-use from its\n   cache), if any of them are also  OutputStep  instances, then add them to\n   the to-validate list.  (The  OutputStep  class does not yet exist.  Make\n   it a stub for now, and come back to fully implementing it in\n    phase 7 .)   Add documentation in those files describing the changes just made.   Extend the unit tests for the  InputStructure  module to verify\n   that this works as described.   Add documentation in that test file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Automatic validation enqueueing"
        }, 
        {
            "location": "/phase4-validation/#automatic-validation-processing", 
            "text": "In the LDE module, run  setInterval()  at module creation so that it\n   regularly (many times per second, but not so often as to consume copious\n   CPU) checks to see if there is anything on the list of  OutputStructure \n   instances to be validated.  If there are any such things, call their\n    validate  routines (which are asynchronous).  The order in which these\n   are processed is irrelevant.   Add documentation in that file describing the changes just made.   Extend the unit tests for the LDE module to verify that this works\n   as described.  That is, create some  OutputStep  subclasses and some\n    InputStructure  subclasses whose  interpret  routines produce instances\n   of those classes.  Verify that validation actually does take place.   Add documentation in that test file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Automatic validation processing"
        }, 
        {
            "location": "/phase4-validation/#feedback-messages", 
            "text": "Add a function to the LDE module that can be called whenever an\n   attribute of an  OutputStructure  in the Output Tree changes, and the\n   function will send a message (to any listening client) containing the ID\n   of the origin of the node whose attribute changed, and the key-value pair\n   of the changed attribute.   Update the documentation in that file to describe the changes just\n   made.   Extend the unit tests for the LDE module to verify that this\n   works as described.  First, simply, just change an attribute of some\n   nodes in the Output Tree and verify that messages are sent by the LDE to\n   that effect.  Then extend the tests that go from API calls to validation\n   results to ensure that the entire process works, from API calls that add\n   to the Input Tree to feedback messages from validation being transmitted\n   back.   Add documentation in that test file describing the changes just made.   Once the unit tests pass, build everything and commit.", 
            "title": "Feedback messages"
        }, 
        {
            "location": "/phase4-validation/#conclusions", 
            "text": "We now stipulate and prove a few facts about the preceding design.  Axiom 1:  Lurch creates an  InputStructure  from a portion of the user's\ndocument iff that portion is meaningful.  Remark:  This is the job of the UI, with the assistance of the user's\nsettings.  So in some sense this axiom is aspirational, or conditioned upon\nthe assumption that we can provide a robust enough set of UI settings to\ncapture user meaning correctly.  Axiom 2:  Lurch performs interpretation on every  InputStructure \ncreated by the UI, and on nothing else.  Remark:  The design so far has included this as an obvious goal.  Here\nwe just explicitly state it.  Theorem 1:  Lurch does syntactic validation on X iff X corresponds to a piece of meaningful content in the user's document.  Proof:  Syntactic validation is a part of interpretation, which by Axiom\n2 gets applied to every  InputStructure , and to nothing else.  By Axiom 1,\nthose  InputStructure s correspond directly to the meaningful content in\nthe user's document.  QED  Axiom 3:  Both the creation and interpretation of  InputStructure s faithfully preserve meaning.  Remark:  That is, neither the UI nor the interpretation phase will\nconvert a premise into a rule, or a grammar rule into a subproof, or any\nother crazy change of meaning.  This is simply a commitment for us to design\nLurch to do what seems mathematically normal and natural to mathematicians\nand math students, as human users of the software.  It's a bit strange to\neven state this rather obvious axiom, but it is needed in the proof of\nTheorem 2.  Theorem 2:  Lurch does semantic validation on X iff X corresponds to a\nsyntactically valid step of work in the user's document.  Proof:  Assume X is a syntactically valid step of work in the document.\nThen by Axiom 1, it will become an  InputStructure , and by Axiom 3, it\nwill more precisely have the type of data that lets the LDE know that it is\na step of work.  By Axiom 2, that step will be interpreted, and by Axiom 3,\nthe result will be an  OutputStep .  That  OutputStep  will have syntactic\nvalidation performed on it, because of the definition of validation\nenqueueing given above.  In the other direction, assume Lurch does semantic validation on X.  Then by\nthe definition of validation enqueueing above, X must be an  OutputStep .\nOur design permits creation of  OutputStructure s only through\ninterpretation, and by Axiom 3, the interpretation step that created X must\nhave taken as input some  InputStructure  that has all the data indicating\nit is a step of work.  By Axiom 1, that must have come from some meaningful\nportion of the user's document, and by Axiom 3, that in-document content\nmust have represented a step of work.  QED", 
            "title": "Conclusions"
        }, 
        {
            "location": "/phase5-labels/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 5: Labels\n\n\nContent\n\n\nIn this phase, we build on the foundation of generic interpretation and\nvalidation to build the first feature necessary for validating steps of\nwork:  Labels.\n\n\nGoal\n\n\nBy the end of this phase, the Input Tree can contain labels that will be\npreserved and transferred to the Output Tree by interpretation, and are\navailable for use in validation.\n\n\nStatus\n\n\nThis has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.\n\n\nDesign\n\n\nWe have high hopes for the flexibility of labels.  We don't want \"1\" to be\na label and then the user says \"1.\" and it's not recognized because of the\nminor difference in punctuation.  Furthermore, if \"Theorem 6\" were a label\nand the user said \"thm 6\" we might like that to be recognized.  So a label\nis not a string, but a string together with a set of policies defining an\nequivalence class surrounding that string in the space of all strings.  Of\ncourse, a subset of the set of all strings is also defined by a predicate,\nwhich would show up in JavaScript as a one-parameter function on strings\nreturning true/false values.\n\n\nWe therefore use this as our definition of \"label.\"  That is, a label for\nan \nOutputStructure\n A is really a function f such that f(L) is true iff A\nanswers to the label L.  Because an \nOutputStructure\n is a\nJavaScript object, it can have a field that stores, in an array, all its\nlabels (as functions).  Like so:\n * \nmyOutputStructure.labelFunctions\n, an array initialized to empty in the\n   constructor\n * \nmyOutputStructure.hasLabel( L )\n returns true iff some f in\n   \nmyOutputStructure.labelFunctions\n returns true on L, and false otherwise\n * We already have built into the generic \nStructure\n class (and therefore\n   into its subclasses, including \nOutputStructure\n and \nInputStructure\n) a\n   routine that can search backwards through all accessible nodes to find\n   the first one satisfying a given predicate.  So we can simply look up\n   labels from any point X in the \nOutputTree\n with CoffeeScript code like\n   so: \nlookupResult = X.firstAccessible ( y ) -\n y.hasLabel L\n\n\nExplicit label bubbles in the document, connected by arrows to their\ntargets, can be passed directly from the UI to the IT without processing.\nThe interpretation phase will then have to take these steps:\n * Convert any labeling data into labeling predicates (as designed above)\n   that get embedded into Output Tree nodes.\n * Delete any label bubbles, since they aren't part of validation, and\n   their data has been embedded in their targets.\n * Hidden attributes will be passed directly from the UI to the Input Tree\n   without processing, and converted similarly during the interpretation\n   phase, but without the need to delete any label bubbles.\n * HTML structures like ordered lists will be converted, by the UI, as it\n   creates the Input Tree, into hidden attributes, which would then be\n   handled by the interpretation phase as in the previous bullet point.\n\n\nThus when the UI embeds into an \nInputStructure\n some information about a\nlabel automatically assigned based on a numbered list, it can also embed\nwith it some data saying whether punctuation is optional, or any other\noption that should be applied when checking to see if a label applies.  That\ninformation will be used by the interpretation step when it creates label\npredicates that it embeds in Output Tree nodes.", 
            "title": "Phase 5, Labels"
        }, 
        {
            "location": "/phase5-labels/#lde-design-phase-5-labels", 
            "text": "", 
            "title": "LDE Design Phase 5: Labels"
        }, 
        {
            "location": "/phase5-labels/#content", 
            "text": "In this phase, we build on the foundation of generic interpretation and\nvalidation to build the first feature necessary for validating steps of\nwork:  Labels.", 
            "title": "Content"
        }, 
        {
            "location": "/phase5-labels/#goal", 
            "text": "By the end of this phase, the Input Tree can contain labels that will be\npreserved and transferred to the Output Tree by interpretation, and are\navailable for use in validation.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase5-labels/#status", 
            "text": "This has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.", 
            "title": "Status"
        }, 
        {
            "location": "/phase5-labels/#design", 
            "text": "We have high hopes for the flexibility of labels.  We don't want \"1\" to be\na label and then the user says \"1.\" and it's not recognized because of the\nminor difference in punctuation.  Furthermore, if \"Theorem 6\" were a label\nand the user said \"thm 6\" we might like that to be recognized.  So a label\nis not a string, but a string together with a set of policies defining an\nequivalence class surrounding that string in the space of all strings.  Of\ncourse, a subset of the set of all strings is also defined by a predicate,\nwhich would show up in JavaScript as a one-parameter function on strings\nreturning true/false values.  We therefore use this as our definition of \"label.\"  That is, a label for\nan  OutputStructure  A is really a function f such that f(L) is true iff A\nanswers to the label L.  Because an  OutputStructure  is a\nJavaScript object, it can have a field that stores, in an array, all its\nlabels (as functions).  Like so:\n *  myOutputStructure.labelFunctions , an array initialized to empty in the\n   constructor\n *  myOutputStructure.hasLabel( L )  returns true iff some f in\n    myOutputStructure.labelFunctions  returns true on L, and false otherwise\n * We already have built into the generic  Structure  class (and therefore\n   into its subclasses, including  OutputStructure  and  InputStructure ) a\n   routine that can search backwards through all accessible nodes to find\n   the first one satisfying a given predicate.  So we can simply look up\n   labels from any point X in the  OutputTree  with CoffeeScript code like\n   so:  lookupResult = X.firstAccessible ( y ) -  y.hasLabel L  Explicit label bubbles in the document, connected by arrows to their\ntargets, can be passed directly from the UI to the IT without processing.\nThe interpretation phase will then have to take these steps:\n * Convert any labeling data into labeling predicates (as designed above)\n   that get embedded into Output Tree nodes.\n * Delete any label bubbles, since they aren't part of validation, and\n   their data has been embedded in their targets.\n * Hidden attributes will be passed directly from the UI to the Input Tree\n   without processing, and converted similarly during the interpretation\n   phase, but without the need to delete any label bubbles.\n * HTML structures like ordered lists will be converted, by the UI, as it\n   creates the Input Tree, into hidden attributes, which would then be\n   handled by the interpretation phase as in the previous bullet point.  Thus when the UI embeds into an  InputStructure  some information about a\nlabel automatically assigned based on a numbered list, it can also embed\nwith it some data saying whether punctuation is optional, or any other\noption that should be applied when checking to see if a label applies.  That\ninformation will be used by the interpretation step when it creates label\npredicates that it embeds in Output Tree nodes.", 
            "title": "Design"
        }, 
        {
            "location": "/phase6-expressions/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 6: Expressions\n\n\nContent\n\n\nIn this phase, we build on the foundation of generic interpretation and\nvalidation to build the second feature necessary for validating steps of\nwork:  Expressions.\n\n\nGoal\n\n\nBy the end of this phase, the Input Tree can contain arbitrarily complex\nmathematical expressions.\n\n\nStatus\n\n\nThis has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.\n\n\nDesign\n\n\nOutput Tree\n\n\nIn the Output Tree, we design things so that they are easy to compute with.\nIn the case of expressions, that means three things.\n\n\n\n\nThey should be in fully expanded form.\n\n\nThey should be \nOutputStructure\n instances because the rest of the tree\n    is.\n\n\nThey should be OpenMath instances, because many of the tools (like the\n    formidable Matching Package) we've created take OpenMath structures as\n    inputs.\n\n\n\n\nThe second and third items conflict, but the design below attempts to solve\nthat problem.\n\n\nDefine a subclass \nOutputExpression\n of \nOutputStructure\n.  It will support\nthese new features:\n\n\n\n\nE.isAtomic() == true\n iff the expression has no children\n\n\nIf \nE.isAtomic()\n, then \nE.text()\n is the value of its \"text\" attribute,\n   treated as a string (or the empty string if there is no such attribute);\n   this will be used to store the text content of atomic expressions.\n\n\nIf \nE.isAtomic()\n is false, then \nE.text()\n is undefined.\n\n\nE.addBound(i)\n marks child \ni\n of \nE\n as a bound variable.  For\n   instance, in an expression like $\\forall x, P(x)$ (which we represent\n   with the LISP notation \n(forall x (P x))\n), you might call\n   \nE.addBound(1)\n to mark it as bound by the forall, if we're counting\n   subexpressions from zero (\nforall\n, then \nx\n, then \n(P x)\n).  And in\n   $\\frac{d}{dx}x$ (\n(diff (f x) x)\n), you might call \nE.addBound(2)\n.\n   These indices can be stored in the \"bound variables\" attribute.\n\n\nE.bound()\n returns the list of all indices of bound children of \nE\n.\n   (At times below, this document may refer to \nE.bound()\n as the variables\n   themselves, because they can easily be looked up from these indices.)\n\n\nE.isBinding() == true\n iff \nE.bound()\n is nonempty.\n\n\n\n\nLater we may extend this with settings that permit various types of\nexpressions to be considered equal (for example, case insensitive\nidentifiers) and the interpretation phase could accomplish this by reducing\nall text to a canonical form as it creates \nOutputStructure\n instances.  But\nfor now we do not stipulate that feature as a requirement.\n\n\nThat should be all we need to create any kind of mathematical expression.\nExamples:\n\n\n\n\n$3$ can be represented as an atomic expression with text 3\n\n\n$x$ can be represented as an atomic expression with text x\n\n\n$x+y$ can be represented as a nonatomic expression with three children:\n\n\nan atomic expression with text +\n\n\nan atomic expression with text x\n\n\nan atomic expression with text y\n\n\n\n\n\n\n$\\forall x, P(x)$ can be represented as a nonatomic expression with\n   three children, the second of which is bound:\n\n\nan atomic expression with text $\\forall$\n\n\nan atomic expression with text x\n\n\nan nonatomic expression with two children:\n\n\nan atomic expression with text P\n\n\nan atomic expression with text x\n\n\n\n\n\n\n\n\nAlthough examples so far have not bound more than one thing, you can bind as\nmany as you like in one expression.  It is not necessary to have just one\nbody of a binding expression, as it was in OpenMath.  It is not necessary to\nhave a head symbol at the start of a binding expression, as it was in\nOpenMath.\n\n\nSo let us then return to criterion 3 from above, about OpenMath.  We need\nexpressions in OpenMath form to hand to the\n\nMatching Package\n,\nbecause that package would be awful to rewrite.  So we create a method on\nthe \nOutputExpression\n class that converts its instances to OpenMath.  It\naccepts a parameter \nV\n listing the names of all known variables in the\nsurrounding context, which defaults to the empty list (but could include,\nfor instance, all variables currently declared).  \nE.toOpenMath(V)\n then\ndoes this:\n\n\n\n\nIf \nE.isAtomic()\n:\n\n\nIf \nE.text()\n is on the list \nV\n, then return a new OpenMath variable\n  with name \nE.text()\n.  (This may require an embedding from all strings\n  into the space of valid OpenMath variable names.)\n\n\nOtherwise, return a new OpenMath string with contents \nE.text()\n.\n\n\n\n\n\n\nOtherwise let $c_1,\\ldots,c_n$ be the children of \nE\n and do this:\n\n\nIf \nE.isBinding() == false\n:\n\n\nLet $C_1=c_1$\n.toOpenMath(V)\n, and so on through\n     $C_n=c_n$\n.toOpenMath(V)\n.\n\n\nReturn the OpenMath application node with children $C_1$ through\n     $C_n$, in that order.\n\n\nOtherwise:\n\n\nLet V' be the list \nV\n appended with the names of all the variables\n     in \nE.bound()\n.\n\n\nLet $C_1=c_1$\n.toOpenMath(V')\n, and so on through\n     $C_n=c_n$\n.toOpenMath(V')\n.\n\n\nLet \nP\n be a single, fixed OpenMath symbol we will use as a\n     placeholder, just to satisfy the OpenMath syntactic requirements.\n\n\nLet \nQ\n be the OpenMath application of \nP\n to the nodes $C_1$\n     through $C_n$, in that order.\n\n\nReturn the OpenMath binding with head symbol \nP\n, bound variables\n     \nE.bound()\n, and body \nQ\n.\n\n\n\n\n\n\n\n\nFurthermore, \nE.toOpenMath(V)\n will cache its result, so that it needs to be\ncomputed only once in the life of \nE\n.\n\n\nInput Tree\n\n\nThere will be simple \nInputStructure\n subclasses that allow the client to\nform expressions hierarchically in the Input Tree by nesting atomic nodes\nwithin nonatomic ones in hierarchies like those described above, which get\nconverted directly (during the interpretation phase) into isomorphic\nstructures in the Output Tree.  So there will be a subclass\n\nInputExpression\n that also supports \nE.isAtomic()\n, \nE.text()\n,\n\nE.addBound()\n, \nE.bound()\n, and \nE.isBinding()\n, and in which\n\nE.interpret()\n creates the fully-expanded-form \nOutputExpression\n\nisomorphic to \nE\n.\n\n\nWe will also want there to be parseable \nInputExpression\ns that create\nfully-expanded \nOutputExpression\ns.  But this document does not attempt to\nalso design all of customizable parsing.  Instead, we make a few brief\nnotes:\n\n\n\n\nIf \nE\n is an atomic \nInputExpression\n, and \nE\n has a \"grammar\"\n    attribute, then \nE.interpret()\n will try to find a grammar with the\n    name \nE.getAttribute(\"grammar\")\n and use it to parse \nE.text()\n, and\n    use the parsed result as the result of \nE.interpret()\n.\n\n\nTo test this feature without building customizable parsing, build a few\n    simple parsers for testing purposes into the \nInputExpression\n class,\n    like a LISP parser, so that an atomic \nInputExpression\n with text\n    \"(diff (f x) x)\" and grammar \"LISP\" would be parsed into a non-atomic\n    \nOutputExpression\n in the expected way.  Such built-in parsers could be\n    very handy in early testing.\n\n\n\n\nAs per \nexisting design\n, \nE.interpret()\n will\nhave access to all its accessibles, so later when it becomes possible to\ncite a grammar defined in the document or a dependency, it will be able to\nfind all that grammar's details in those accessible nodes.\n\n\nUser Interface\n\n\nThere will be many ways to write expressions in the UI, including unusual\nand very handy methods such as automatic bubbling, default grammars for all\nexpressions in certain libraries, and so on.  But let us begin simpler than\nthat.\n\n\nAn early UI should have a bubble type for expressions, and it should be the\nmain/default bubble type, just as Meaningful Expression is the most common\ntype in Desktop Lurch.  By default, such bubbles will have no grammar\nattached, and will thus convert into \nInputExpression\ns in fully expanded\nform, and from there into \nOutputExpression\ns in fully expanded form.  There\nwill be no way to bind variables at first.  We can later add features, like\ncontext menu items for choosing a grammar, specifying which variables are\nbound in a fully expanded form expression, and more.", 
            "title": "Phase 6, Expressions"
        }, 
        {
            "location": "/phase6-expressions/#lde-design-phase-6-expressions", 
            "text": "", 
            "title": "LDE Design Phase 6: Expressions"
        }, 
        {
            "location": "/phase6-expressions/#content", 
            "text": "In this phase, we build on the foundation of generic interpretation and\nvalidation to build the second feature necessary for validating steps of\nwork:  Expressions.", 
            "title": "Content"
        }, 
        {
            "location": "/phase6-expressions/#goal", 
            "text": "By the end of this phase, the Input Tree can contain arbitrarily complex\nmathematical expressions.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase6-expressions/#status", 
            "text": "This has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.", 
            "title": "Status"
        }, 
        {
            "location": "/phase6-expressions/#design", 
            "text": "", 
            "title": "Design"
        }, 
        {
            "location": "/phase6-expressions/#output-tree", 
            "text": "In the Output Tree, we design things so that they are easy to compute with.\nIn the case of expressions, that means three things.   They should be in fully expanded form.  They should be  OutputStructure  instances because the rest of the tree\n    is.  They should be OpenMath instances, because many of the tools (like the\n    formidable Matching Package) we've created take OpenMath structures as\n    inputs.   The second and third items conflict, but the design below attempts to solve\nthat problem.  Define a subclass  OutputExpression  of  OutputStructure .  It will support\nthese new features:   E.isAtomic() == true  iff the expression has no children  If  E.isAtomic() , then  E.text()  is the value of its \"text\" attribute,\n   treated as a string (or the empty string if there is no such attribute);\n   this will be used to store the text content of atomic expressions.  If  E.isAtomic()  is false, then  E.text()  is undefined.  E.addBound(i)  marks child  i  of  E  as a bound variable.  For\n   instance, in an expression like $\\forall x, P(x)$ (which we represent\n   with the LISP notation  (forall x (P x)) ), you might call\n    E.addBound(1)  to mark it as bound by the forall, if we're counting\n   subexpressions from zero ( forall , then  x , then  (P x) ).  And in\n   $\\frac{d}{dx}x$ ( (diff (f x) x) ), you might call  E.addBound(2) .\n   These indices can be stored in the \"bound variables\" attribute.  E.bound()  returns the list of all indices of bound children of  E .\n   (At times below, this document may refer to  E.bound()  as the variables\n   themselves, because they can easily be looked up from these indices.)  E.isBinding() == true  iff  E.bound()  is nonempty.   Later we may extend this with settings that permit various types of\nexpressions to be considered equal (for example, case insensitive\nidentifiers) and the interpretation phase could accomplish this by reducing\nall text to a canonical form as it creates  OutputStructure  instances.  But\nfor now we do not stipulate that feature as a requirement.  That should be all we need to create any kind of mathematical expression.\nExamples:   $3$ can be represented as an atomic expression with text 3  $x$ can be represented as an atomic expression with text x  $x+y$ can be represented as a nonatomic expression with three children:  an atomic expression with text +  an atomic expression with text x  an atomic expression with text y    $\\forall x, P(x)$ can be represented as a nonatomic expression with\n   three children, the second of which is bound:  an atomic expression with text $\\forall$  an atomic expression with text x  an nonatomic expression with two children:  an atomic expression with text P  an atomic expression with text x     Although examples so far have not bound more than one thing, you can bind as\nmany as you like in one expression.  It is not necessary to have just one\nbody of a binding expression, as it was in OpenMath.  It is not necessary to\nhave a head symbol at the start of a binding expression, as it was in\nOpenMath.  So let us then return to criterion 3 from above, about OpenMath.  We need\nexpressions in OpenMath form to hand to the Matching Package ,\nbecause that package would be awful to rewrite.  So we create a method on\nthe  OutputExpression  class that converts its instances to OpenMath.  It\naccepts a parameter  V  listing the names of all known variables in the\nsurrounding context, which defaults to the empty list (but could include,\nfor instance, all variables currently declared).   E.toOpenMath(V)  then\ndoes this:   If  E.isAtomic() :  If  E.text()  is on the list  V , then return a new OpenMath variable\n  with name  E.text() .  (This may require an embedding from all strings\n  into the space of valid OpenMath variable names.)  Otherwise, return a new OpenMath string with contents  E.text() .    Otherwise let $c_1,\\ldots,c_n$ be the children of  E  and do this:  If  E.isBinding() == false :  Let $C_1=c_1$ .toOpenMath(V) , and so on through\n     $C_n=c_n$ .toOpenMath(V) .  Return the OpenMath application node with children $C_1$ through\n     $C_n$, in that order.  Otherwise:  Let V' be the list  V  appended with the names of all the variables\n     in  E.bound() .  Let $C_1=c_1$ .toOpenMath(V') , and so on through\n     $C_n=c_n$ .toOpenMath(V') .  Let  P  be a single, fixed OpenMath symbol we will use as a\n     placeholder, just to satisfy the OpenMath syntactic requirements.  Let  Q  be the OpenMath application of  P  to the nodes $C_1$\n     through $C_n$, in that order.  Return the OpenMath binding with head symbol  P , bound variables\n      E.bound() , and body  Q .     Furthermore,  E.toOpenMath(V)  will cache its result, so that it needs to be\ncomputed only once in the life of  E .", 
            "title": "Output Tree"
        }, 
        {
            "location": "/phase6-expressions/#input-tree", 
            "text": "There will be simple  InputStructure  subclasses that allow the client to\nform expressions hierarchically in the Input Tree by nesting atomic nodes\nwithin nonatomic ones in hierarchies like those described above, which get\nconverted directly (during the interpretation phase) into isomorphic\nstructures in the Output Tree.  So there will be a subclass InputExpression  that also supports  E.isAtomic() ,  E.text() , E.addBound() ,  E.bound() , and  E.isBinding() , and in which E.interpret()  creates the fully-expanded-form  OutputExpression \nisomorphic to  E .  We will also want there to be parseable  InputExpression s that create\nfully-expanded  OutputExpression s.  But this document does not attempt to\nalso design all of customizable parsing.  Instead, we make a few brief\nnotes:   If  E  is an atomic  InputExpression , and  E  has a \"grammar\"\n    attribute, then  E.interpret()  will try to find a grammar with the\n    name  E.getAttribute(\"grammar\")  and use it to parse  E.text() , and\n    use the parsed result as the result of  E.interpret() .  To test this feature without building customizable parsing, build a few\n    simple parsers for testing purposes into the  InputExpression  class,\n    like a LISP parser, so that an atomic  InputExpression  with text\n    \"(diff (f x) x)\" and grammar \"LISP\" would be parsed into a non-atomic\n     OutputExpression  in the expected way.  Such built-in parsers could be\n    very handy in early testing.   As per  existing design ,  E.interpret()  will\nhave access to all its accessibles, so later when it becomes possible to\ncite a grammar defined in the document or a dependency, it will be able to\nfind all that grammar's details in those accessible nodes.", 
            "title": "Input Tree"
        }, 
        {
            "location": "/phase6-expressions/#user-interface", 
            "text": "There will be many ways to write expressions in the UI, including unusual\nand very handy methods such as automatic bubbling, default grammars for all\nexpressions in certain libraries, and so on.  But let us begin simpler than\nthat.  An early UI should have a bubble type for expressions, and it should be the\nmain/default bubble type, just as Meaningful Expression is the most common\ntype in Desktop Lurch.  By default, such bubbles will have no grammar\nattached, and will thus convert into  InputExpression s in fully expanded\nform, and from there into  OutputExpression s in fully expanded form.  There\nwill be no way to bind variables at first.  We can later add features, like\ncontext menu items for choosing a grammar, specifying which variables are\nbound in a fully expanded form expression, and more.", 
            "title": "User Interface"
        }, 
        {
            "location": "/phase7-citations/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 7: Citations\n\n\nContent\n\n\nIn this phase, we build on the foundation of generic interpretation and\nvalidation, plus \nthe design of labels\n, to design how to\nrefer to (or \"cite\") labeled structures.\n\n\nGoal\n\n\nBy the end of this phase, the Input Tree can contain references to previous\nlabeled structures, and we will also have a design for how to package up\nsuch references into a structure called a \"step of work,\" which will cite\nthe rules and premises on which it purports to depend.\n\n\nStatus\n\n\nThis has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.\n\n\nDesign\n\n\nOverview\n\n\nWhile we defined labels \nin an earlier phase\n, we have not\nyet defined a way to refer to them.  For instance, in the design of Desktop\nLurch, we use the informal notation\n\n\n\n\n[foo]:ME\n because of \nmodus ponens):reason\n using line \n3):premise\n,\n\n\n\n\nand the \n3):premise\n bubble is a way to refer to some earlier line with the\nlabel 3.  We haven't added to our new design anything corresponding to the\n\n3):premise\n bubble.\n\n\nLet us call such things \nreferences,\n creating a parallel with LaTeX, since\nmany students will learn both Lurch and LaTeX.  So we have labels and\nreferences in Lurch just as we have labels and references in LaTeX, and they\nfunction similarly in both cases.\n\n\nInput Tree\n\n\nDefine a new subclass of \nInputStructure\n called \nInputReference\n, which\nmust be atomic and its text content is its essential attribute.  That class\ncan provide a member function \n.lookup(fromHere)\n that will look up the\n\nInputStructure\n to which the instance refers, searching from the point in\nthe document given by the parameter \nfromHere\n, which must be an\n\nInputStructure\n.\n\n\nSo in the case of the example above with the bubbles for foo, modus ponens,\nand 3, let's call those three bubbles A, B, and C respectively; we would\nthen call \nC.lookup(A)\n to find the bubble somewhere preceding A that has\nthe label 3.  It is, of course, essential to look up the reference from A\nrather than C, because C's position in the document is not relevant; what we\ncare about is whether or not A is permitted to cite the bubble labeled with\na 3.\n\n\nNote that we do not define a corresponding \nOutputStructure\n subclass for\nreferences, because we won't need one.  That may not be obvious, but read\non.\n\n\nAssuming the existence of Rules\n\n\nOn the one hand, it doesn't make a lot of sense to design, in this document,\nhow steps of work will cite premises and rules if we haven't designed what a\nrule is.  On the other hand, it doesn't make any sense to say how we will\ndefine rules and validation algorithms if we can't talk about an important\npiece of what those algorithms will assess (cited premises).\n\n\nConsequently we assuming for now that there exists some notion of a \"rule\"\nthat will be designed later, resulting in two subclasses, \nInputRule\n as a\nsubclass of \nInputStructure\n and \nOutputRule\n as a subclass of\n\nOutputStructure\n.  We then proceed with the design of citations in this\ndocument, and come back in a later phase and design those subclasses in\ndetail.\n\n\nAssuming limited citations\n\n\nI further assume that for now we care only about citing only two kinds of\nthings:  Either a step of work is citing another expression as a premise or\nit is citing a rule (which is not an expression).  For the purposes of this\ndesign, there are no other types of citations.  We can extend this list of\ncitable things later if needed, but for this document those are the only\ncitations in view.\n\n\nFor instance, when we design customizable parsing, we may say that a\nreference to a grammar for parsing is a citation of the most recent grammar\nrule for that language.  (Or we might choose a different implementation for\ngrammar citations; we will see.)  So the reader should assume for now that\nwe have only two types of citations, but that list may grow.\n\n\nOutput Tree\n\n\nIn the Output Tree, we create a new class called \nOutputStep\n that is a\nsubclass of \nOutputExpression\n.  The defining characteristics of\n\nOutputStep\ns are that each instance will have the following two fields.\n\n\n\n\npremises\n - an ordered array of \nOutputExpression\ns, each of which must\n   be accessible to the step.  (Order is important here because some\n   libraries will care about the order of premises, so this is not just a\n   set.)\n\n\nrules\n - an ordered array of \nOutputRule\ns, each of which must be\n   accessible to the step.\n\n\n\n\nThese are fields of \nOutputStep\n instances, not attributes of them.  That\nis, an instance of the \nOutputStep\n class is a JavaScript object, and in any\nsuch instance \nS\n, I'm saying that \nS.premises\n and \nS.rules\n contain data\nas just described.  (This is not the same as \nS.getAttribute('premises')\n\nand \nS.getAttribute('rules')\n; attributes are JSON data for storing static\ninformation like feedback.)  So \nS.premises\n will be an array of the actual\n\nOutputExpression\n instances that exist in the \nOutputTree\n, accessible to\n\nS\n, so that validation algorithms (and other code) can inspect/use them\ndirectly.  Similarly, \nS.rules\n will be the actual \nOutputRule\n instances in\nthe Output Tree accessible to \nS\n and cited by it.\n\n\nTo be even more precise, all of the following CoffeeScript expressions would\nevaluate to true:\n\n\n\n\nS.premises[i] instanceof OutputExpression\n (assuming \ni\n is a valid\n   index into \nS.premises\n)\n\n\nS.premises[i].accessibleTo S\n (assuming \ni\n is a valid index into\n   \nS.premises\n)\n\n\nS.rules[i] instanceof OutputExpression\n (assuming \ni\n is a valid index\n   into \nS.rules\n)\n\n\nS.rules[i].accessibleTo S\n (assuming \ni\n is a valid index into\n   \nS.rules\n)\n\n\n\n\nNote that the rules list is indeed a list rather than a single rule, because\nwe want to support libraries that attach the same label to several different\nrules, so that users can cite things ambiguously, using just one rule name.\nIn such libraries, validation will need to figure out whether any of the\nambiguously cited rules justifies the step.  This is not the same thing as\nletting the user attach several different rule citations to the same step;\nmore details on this below.\n\n\nUser Interface\n\n\nThe main Lurch UI will invent many ways for users to cite premises.  In\nDesktop Lurch, we have the method represented by the notation \n3):premise\n\nin the example above.  In the web version, the \n...)\n aspect of that bubble\nwill now be handled using the arrows feature in the main UI, rather than\nlittle arrow symbols in the bubble tag.  We can also permit new types of\npremise citations, using new features of the web UI, including a direct\narrow connection from a premise to a conclusion, and a hidden attribute in\nthe conclusion that cites the premise by its label.\n\n\nOther things may be invented later as well, but this design document\nconsiders these for now.  We design aspects of the Input Tree that support\nthese features.  Recall that data about arrows among bubbles (also called\nconnections) gets transferred directly into the Input Tree for use in\ninterpretation routines.\n\n\nFurthermore, there is a clearly defined notion of \"order\" among the arrows\nbetween bubbles.  This is shown visually in the order of arrowheads entering\na bubble, and arrow stems leaving a bubble.  This order is preserved when\narrow data is converted into connections in the data in \nInputStructure\ns.\nThus that order can be preserved further in the interpretation phase, into\nthe Output Tree, where a premise array is ordered.\n\n\nThe same holds true of hidden attributes in a bubble; we can stipulate any\norder among those attributes, because any hidden attributes will be edited\nthrough some user interface we create for doing so (context menu items,\npopup dialogs, etc.) and thus we can make it as flexible as we like.  \n\n\nHowever, there is no natural way to unite these two different orderings.\nEach way seems as good as any other.  So we just define the convention that\ncitations in hidden attributes always follow citations made by arrows.\n\n\nInput Tree\n\n\nWe therefore create three types of rule/premise citations that the Input\nTree supports, to correspond to the three types of citation that the UI\nsupports.  Any \nInputExpression\n \nE\n may cite an \nInputExpression\n \nF\n\naccessible to \nE\n through any of the following means.\n\n\n\n\na connection (informally called an \"arrow\") from \nF\n to \nE\n; this is\n    something entirely new in the web version of Lurch because we didn't\n    have arrows in Desktop Lurch\n\n\na hidden attribute in \nE\n containing a label that, when looked up from\n    the point of \nE\n, yields \nF\n (where lookup is as defined in \nan earlier\n    phase\n); this, too, is new for web Lurch, because we\n    didn't have hidden attributes in Desktop Lurch\n\n\na connection from \nG\n to \nE\n, for some \nInputStructure\n \nG\n functioning\n    as a reference to \nF\n; this is exactly like what we had in Desktop\n    Lurch, and it's the first thing designed at the top of this document,\n    called \nreferences.\n\n\n\n\nThis means that the UI must know the difference between citations of type 1.\nvs. type 3.  But the UI will not be able to discern that distinction without\nthe user's aid.  This is because we will later add customizable parsing, and\nthus the language for expressions could be anything at all, making it\nimpossible for the UI to use the contents of a bubble to distinguish\nreferences from expressions.  So we will need to make the user specify which\nkind of connection it is, either by choosing a particular type of source\nbubble, or by choosing some attribute of the connection itself.  \n\n\nWe do not design a new class \nInputStep\n.  Rather, the implementation of\n\n.interpret()\n in the \nInputExpression\n class is extended as follows:\n\n\n\n\nIf the expression does not cite any rules or premises, then it is\n   interpreted the old way--into an \nOutputExpression\n that does not need\n   validation.\n\n\nIf the expression has precisely one rule citation and any number\n   (including zero) of premise citations, then it is interpreted in a new\n   way--as an \nOutputStep\n, which is a subclass of \nOutputExpression\n and\n   thus has all data that any \nOutputExpression\n has, plus \npremises\n and\n   \nrules\n fields.  The \n.interpret()\n routine in the \nInputExpression\n\n   class is in charge of looking up the cited premises and rule in the\n   accessibles list provided to it as one of its parameters, and using them\n   to populate the \npremises\n and \nrules\n fields in the \nOutputStep\n\n   instance it creates.\n\n\nIf the expression has more than one rule citation, then we call it a\n   syntactically invalid step, do not create any \nOutputStep\n as its\n   interpretation, but let the interpretation phase give feedback to the\n   user about the error.  This is because multiple rule citations on a\n   single step of work violates the Lurch mission statement:  In actual\n   math practice, no one cites a few theorems hoping that one will work!\n\n\n\n\n(If, for toy proof style games, we later change our minds to want to permit\nmultiple rule citations for a single step of work, we could make this an\noption users or libraries can enable/disable.  But that is low priority.)", 
            "title": "Phase 7, Citations"
        }, 
        {
            "location": "/phase7-citations/#lde-design-phase-7-citations", 
            "text": "", 
            "title": "LDE Design Phase 7: Citations"
        }, 
        {
            "location": "/phase7-citations/#content", 
            "text": "In this phase, we build on the foundation of generic interpretation and\nvalidation, plus  the design of labels , to design how to\nrefer to (or \"cite\") labeled structures.", 
            "title": "Content"
        }, 
        {
            "location": "/phase7-citations/#goal", 
            "text": "By the end of this phase, the Input Tree can contain references to previous\nlabeled structures, and we will also have a design for how to package up\nsuch references into a structure called a \"step of work,\" which will cite\nthe rules and premises on which it purports to depend.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase7-citations/#status", 
            "text": "This has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.", 
            "title": "Status"
        }, 
        {
            "location": "/phase7-citations/#design", 
            "text": "", 
            "title": "Design"
        }, 
        {
            "location": "/phase7-citations/#overview", 
            "text": "While we defined labels  in an earlier phase , we have not\nyet defined a way to refer to them.  For instance, in the design of Desktop\nLurch, we use the informal notation   [foo]:ME  because of  modus ponens):reason  using line  3):premise ,   and the  3):premise  bubble is a way to refer to some earlier line with the\nlabel 3.  We haven't added to our new design anything corresponding to the 3):premise  bubble.  Let us call such things  references,  creating a parallel with LaTeX, since\nmany students will learn both Lurch and LaTeX.  So we have labels and\nreferences in Lurch just as we have labels and references in LaTeX, and they\nfunction similarly in both cases.", 
            "title": "Overview"
        }, 
        {
            "location": "/phase7-citations/#input-tree", 
            "text": "Define a new subclass of  InputStructure  called  InputReference , which\nmust be atomic and its text content is its essential attribute.  That class\ncan provide a member function  .lookup(fromHere)  that will look up the InputStructure  to which the instance refers, searching from the point in\nthe document given by the parameter  fromHere , which must be an InputStructure .  So in the case of the example above with the bubbles for foo, modus ponens,\nand 3, let's call those three bubbles A, B, and C respectively; we would\nthen call  C.lookup(A)  to find the bubble somewhere preceding A that has\nthe label 3.  It is, of course, essential to look up the reference from A\nrather than C, because C's position in the document is not relevant; what we\ncare about is whether or not A is permitted to cite the bubble labeled with\na 3.  Note that we do not define a corresponding  OutputStructure  subclass for\nreferences, because we won't need one.  That may not be obvious, but read\non.", 
            "title": "Input Tree"
        }, 
        {
            "location": "/phase7-citations/#assuming-the-existence-of-rules", 
            "text": "On the one hand, it doesn't make a lot of sense to design, in this document,\nhow steps of work will cite premises and rules if we haven't designed what a\nrule is.  On the other hand, it doesn't make any sense to say how we will\ndefine rules and validation algorithms if we can't talk about an important\npiece of what those algorithms will assess (cited premises).  Consequently we assuming for now that there exists some notion of a \"rule\"\nthat will be designed later, resulting in two subclasses,  InputRule  as a\nsubclass of  InputStructure  and  OutputRule  as a subclass of OutputStructure .  We then proceed with the design of citations in this\ndocument, and come back in a later phase and design those subclasses in\ndetail.", 
            "title": "Assuming the existence of Rules"
        }, 
        {
            "location": "/phase7-citations/#assuming-limited-citations", 
            "text": "I further assume that for now we care only about citing only two kinds of\nthings:  Either a step of work is citing another expression as a premise or\nit is citing a rule (which is not an expression).  For the purposes of this\ndesign, there are no other types of citations.  We can extend this list of\ncitable things later if needed, but for this document those are the only\ncitations in view.  For instance, when we design customizable parsing, we may say that a\nreference to a grammar for parsing is a citation of the most recent grammar\nrule for that language.  (Or we might choose a different implementation for\ngrammar citations; we will see.)  So the reader should assume for now that\nwe have only two types of citations, but that list may grow.", 
            "title": "Assuming limited citations"
        }, 
        {
            "location": "/phase7-citations/#output-tree", 
            "text": "In the Output Tree, we create a new class called  OutputStep  that is a\nsubclass of  OutputExpression .  The defining characteristics of OutputStep s are that each instance will have the following two fields.   premises  - an ordered array of  OutputExpression s, each of which must\n   be accessible to the step.  (Order is important here because some\n   libraries will care about the order of premises, so this is not just a\n   set.)  rules  - an ordered array of  OutputRule s, each of which must be\n   accessible to the step.   These are fields of  OutputStep  instances, not attributes of them.  That\nis, an instance of the  OutputStep  class is a JavaScript object, and in any\nsuch instance  S , I'm saying that  S.premises  and  S.rules  contain data\nas just described.  (This is not the same as  S.getAttribute('premises') \nand  S.getAttribute('rules') ; attributes are JSON data for storing static\ninformation like feedback.)  So  S.premises  will be an array of the actual OutputExpression  instances that exist in the  OutputTree , accessible to S , so that validation algorithms (and other code) can inspect/use them\ndirectly.  Similarly,  S.rules  will be the actual  OutputRule  instances in\nthe Output Tree accessible to  S  and cited by it.  To be even more precise, all of the following CoffeeScript expressions would\nevaluate to true:   S.premises[i] instanceof OutputExpression  (assuming  i  is a valid\n   index into  S.premises )  S.premises[i].accessibleTo S  (assuming  i  is a valid index into\n    S.premises )  S.rules[i] instanceof OutputExpression  (assuming  i  is a valid index\n   into  S.rules )  S.rules[i].accessibleTo S  (assuming  i  is a valid index into\n    S.rules )   Note that the rules list is indeed a list rather than a single rule, because\nwe want to support libraries that attach the same label to several different\nrules, so that users can cite things ambiguously, using just one rule name.\nIn such libraries, validation will need to figure out whether any of the\nambiguously cited rules justifies the step.  This is not the same thing as\nletting the user attach several different rule citations to the same step;\nmore details on this below.", 
            "title": "Output Tree"
        }, 
        {
            "location": "/phase7-citations/#user-interface", 
            "text": "The main Lurch UI will invent many ways for users to cite premises.  In\nDesktop Lurch, we have the method represented by the notation  3):premise \nin the example above.  In the web version, the  ...)  aspect of that bubble\nwill now be handled using the arrows feature in the main UI, rather than\nlittle arrow symbols in the bubble tag.  We can also permit new types of\npremise citations, using new features of the web UI, including a direct\narrow connection from a premise to a conclusion, and a hidden attribute in\nthe conclusion that cites the premise by its label.  Other things may be invented later as well, but this design document\nconsiders these for now.  We design aspects of the Input Tree that support\nthese features.  Recall that data about arrows among bubbles (also called\nconnections) gets transferred directly into the Input Tree for use in\ninterpretation routines.  Furthermore, there is a clearly defined notion of \"order\" among the arrows\nbetween bubbles.  This is shown visually in the order of arrowheads entering\na bubble, and arrow stems leaving a bubble.  This order is preserved when\narrow data is converted into connections in the data in  InputStructure s.\nThus that order can be preserved further in the interpretation phase, into\nthe Output Tree, where a premise array is ordered.  The same holds true of hidden attributes in a bubble; we can stipulate any\norder among those attributes, because any hidden attributes will be edited\nthrough some user interface we create for doing so (context menu items,\npopup dialogs, etc.) and thus we can make it as flexible as we like.    However, there is no natural way to unite these two different orderings.\nEach way seems as good as any other.  So we just define the convention that\ncitations in hidden attributes always follow citations made by arrows.", 
            "title": "User Interface"
        }, 
        {
            "location": "/phase7-citations/#input-tree_1", 
            "text": "We therefore create three types of rule/premise citations that the Input\nTree supports, to correspond to the three types of citation that the UI\nsupports.  Any  InputExpression   E  may cite an  InputExpression   F \naccessible to  E  through any of the following means.   a connection (informally called an \"arrow\") from  F  to  E ; this is\n    something entirely new in the web version of Lurch because we didn't\n    have arrows in Desktop Lurch  a hidden attribute in  E  containing a label that, when looked up from\n    the point of  E , yields  F  (where lookup is as defined in  an earlier\n    phase ); this, too, is new for web Lurch, because we\n    didn't have hidden attributes in Desktop Lurch  a connection from  G  to  E , for some  InputStructure   G  functioning\n    as a reference to  F ; this is exactly like what we had in Desktop\n    Lurch, and it's the first thing designed at the top of this document,\n    called  references.   This means that the UI must know the difference between citations of type 1.\nvs. type 3.  But the UI will not be able to discern that distinction without\nthe user's aid.  This is because we will later add customizable parsing, and\nthus the language for expressions could be anything at all, making it\nimpossible for the UI to use the contents of a bubble to distinguish\nreferences from expressions.  So we will need to make the user specify which\nkind of connection it is, either by choosing a particular type of source\nbubble, or by choosing some attribute of the connection itself.    We do not design a new class  InputStep .  Rather, the implementation of .interpret()  in the  InputExpression  class is extended as follows:   If the expression does not cite any rules or premises, then it is\n   interpreted the old way--into an  OutputExpression  that does not need\n   validation.  If the expression has precisely one rule citation and any number\n   (including zero) of premise citations, then it is interpreted in a new\n   way--as an  OutputStep , which is a subclass of  OutputExpression  and\n   thus has all data that any  OutputExpression  has, plus  premises  and\n    rules  fields.  The  .interpret()  routine in the  InputExpression \n   class is in charge of looking up the cited premises and rule in the\n   accessibles list provided to it as one of its parameters, and using them\n   to populate the  premises  and  rules  fields in the  OutputStep \n   instance it creates.  If the expression has more than one rule citation, then we call it a\n   syntactically invalid step, do not create any  OutputStep  as its\n   interpretation, but let the interpretation phase give feedback to the\n   user about the error.  This is because multiple rule citations on a\n   single step of work violates the Lurch mission statement:  In actual\n   math practice, no one cites a few theorems hoping that one will work!   (If, for toy proof style games, we later change our minds to want to permit\nmultiple rule citations for a single step of work, we could make this an\noption users or libraries can enable/disable.  But that is low priority.)", 
            "title": "Input Tree"
        }, 
        {
            "location": "/phase8-validating-steps/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nLDE Design Phase 8: Validating Steps\n\n\nContent\n\n\nIn this phase, we unite all the preceding phases into a design for how to\ndo the core operation of Lurch: validating a step of work.\n\n\nGoal\n\n\nBy the end of this phase, the LDE will be able to give feedback on input,\nwhich is its core purpose.\n\n\nStatus\n\n\nThis has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.\n\n\nDesign\n\n\nRecall from the conclusions at the end of \nphase 4\n\nthat the only things that get validated are steps of work.\n\n\nThe \nOutputStep\n validation routine\n\n\nAs defined in \nphase 7\n, an \nOutputStep\n will have as\none of its attributes a list of rules that the user has attached to it.  Now\nwe stipulate that each \nOutputRule\n must have a routine \n.validate(step)\n,\nand that the \n.validate()\n routine for the \nOutputStep\n class just does\nthis:  For the first rule \nR\n in the step's \nrules\n list, try \nR.validate()\n\non the step.  If it marks the step valid, then use that feedback and stop.\nIf not, try the next rule, and so on.  If none of them mark the step valid,\ngive feedback saying that none of the possible rules applies.\n\n\nTherefore subclasses of \nOutputStep\n do not define their own type of\nvalidation routines.  They all use the same validation routine, which defers\nto the list of rules attached to the step.  Steps cite rules, and delegate\ntheir validation to them.  That one routine can include careful error\nhandling (with \ntry\n/\ncatch\n, and paying attention to asynchronous error\nparameters) so that error handling is installed once for all.\n\n\nBackground on background processes\n\n\nThe \nOutputRule\n class will maintain a global list of Web Workers, each\nflagged with the specific subclass of \nOutputRule\n that created that worker\nand initialized it with validation tools (as described next, in this same\nsection).  Whenever any rule instance asks for a Web Worker to use for\nvalidation, the \nOutputRule\n class will either find an inactive one that's\nalready been created and ready to validate instances of that subclass, or it\nwill create a new one if none exist.  When such a worker finishes doing its\njob, it gets added to the pool of inactive workers ready for use later.\n\n\nEach of these workers will be pre-loaded with bootstrap code that knows to\nwatch for and obey certain types of messages from the main thread,\nspecifically, messages that tell it to install new features in itself, such\nas functions, data, and pre-existing code modules.  So a Lurch Web Worker\nwill know how to, say, load the matching package, or the parsing package, or\ninstall an arbitrary function given to it by the main thread, and so on.  We\ncan implement this by making a subclass of \nWorker\n, called \nLurchWorker\n,\nthat has these features.  Then for a \nLurchWorker\n \nL\n, you can call\n\nL.loadScript()\n or \nL.installFunction()\n or \nL.installData()\n or\n\nL.runFunction()\n or whatever.\n\n\nEvery subclass of \nOutputRule\n will have a set of tools it needs to have\ninstalled in a Web Worker.  Specifically, it should implement a function\n\n.setupWorker(L)\n that takes a \nLurchWorker\n \nL\n as parameter and makes all\nthe appropriate calls to \nL.loadScript()\n, \nL.installFunction()\n, and so on.\nWe require that \n.setupWorker(L)\n, in particular, install a function called\n\n.validate()\n, which runs the validation algorithm on whatever data has been\ninstalled in \nL\n, and sends the results back (later) in the usual way that\nJavaScript Web Workers notify their parent threads of events/results/etc.,\nthat is, through a call to \npostMessage()\n, passing any necessary data (such\nas validation feedback).\n\n\nOutputRule\n validation routines\n\n\nConsider an \nOutputRule\n \nR\n is cited by an \nOutputStep\n \nS\n.\n\n\nAlthough informally, above, we spoke of a function \nR.validate(S)\n, the\nactual signature is \nR.validate(S,callback)\n, because validation is\nasynchronous.  Consequently, the loop through rules mentioned earlier will\nbe a series of connected callbacks (or uses of \nawait\n), rather than a\nsynchronous loop.\n\n\nAs described above, \nR.validate(S,callback)\n begins by loading/creating a\n\nLurchWorker\n \nL\n that knows how to do validation for the specific\n\nOutputRule\n subclass of which \nR\n is an instance.  (Note: Use\n\nobject.constructor\n or \nobject.constructor.name\n to get a \"class\" or its\nname in JavaScript or CoffeeScript.)\n\n\nThe rule \nR\n will then need to tell the worker \nL\n about the specifics of\nthe step \nS\n (e.g., the step itself, its cited premises, any other options),\nso that validation can be run on that specific data.  (Recall that \nS\n is an\nobject in the LDE thread, and it is not possible to send objects across\nthread boundaries (into \nL\n, in this case) without first converting them to\nJSON.  For this reason, the \nOutputStructure\n class must define a\n\n.toJSON()\n routine, and every \nLurchWorker\n should have installed in it the\ninverse routine, for reconstituting an \nOutputStructure\n from JSON data.)\nWe require each \nOutputRule\n subclass to define a function\n\nR.prepareToValidate(L,S)\n that prepares \nL\n to validate \nS\n by exporting\nall the relevant data about \nS\n (and any relevant \nOutputStructure\ns\naccessible to it) from the LDE into \nL\n, using \nS.toJSON()\n,\n\nL.installData()\n, and so on.\n\n\n(In order to help enforce the constraint that validation is supposed to be\ncontingent upon only those structures accessible to the one being validated,\nwe may create a convenience function \nL.installStructure()\n that does the\nconversion to and from JSON for us, but checks to be sure that only\naccessible structures are transferred.)\n\n\nR\n will then call \nL.runFunction('validate')\n.  It will also install an\nevent listener so that when \nL\n sends back a message (either that validation\nis complete or that an error occurred), \nR\n hears about it and can react.\nSpecifically, \nR\n's reaction will be to call the \ncallback\n function\nprovided to \nR.validate(S,callback)\n, passing the validation feedback.\n\n\nBecause all validation is therefore shipped into background processes like\n\nL\n, it is therefore perfectly acceptable for those processes to do lengthy\ncomputations, such as trying all permutations of ordered premises when\nmatching.\n\n\nThus each \nOutputRule\n subclass will not implement its own \n.validate()\n\nroutine, but rather its own \n.prepareToValidate()\n and \n.setupWorker()\n\nroutines.  The latter installs the actual validation algorithms, and the\nformer installs the necessary parameters.  But \n.validate()\n can be defined\nonce for all in the \nOutputRule\n class itself.  Consequently, we can place\nextensive error handling there, in several different ways:\n\n\n\n\ntry\n/\ncatch\n blocks where needed\n\n\npaying attention to asynchronous error parameters\n\n\nlistening for the \nonerror\n event of the worker\n\n\nwatching the worker to make sure it does not exceed a maximum time limit\n   (e.g., 10 seconds, or whatever the user's settings dictate)", 
            "title": "Phase 8, Validating Steps"
        }, 
        {
            "location": "/phase8-validating-steps/#lde-design-phase-8-validating-steps", 
            "text": "", 
            "title": "LDE Design Phase 8: Validating Steps"
        }, 
        {
            "location": "/phase8-validating-steps/#content", 
            "text": "In this phase, we unite all the preceding phases into a design for how to\ndo the core operation of Lurch: validating a step of work.", 
            "title": "Content"
        }, 
        {
            "location": "/phase8-validating-steps/#goal", 
            "text": "By the end of this phase, the LDE will be able to give feedback on input,\nwhich is its core purpose.", 
            "title": "Goal"
        }, 
        {
            "location": "/phase8-validating-steps/#status", 
            "text": "This has not been implemented.  In fact, the design below has not yet been\nconverted into actionable tasks.  So the next steps are to do that\nconversion, and then execute the resulting tasks.", 
            "title": "Status"
        }, 
        {
            "location": "/phase8-validating-steps/#design", 
            "text": "Recall from the conclusions at the end of  phase 4 \nthat the only things that get validated are steps of work.", 
            "title": "Design"
        }, 
        {
            "location": "/phase8-validating-steps/#the-outputstep-validation-routine", 
            "text": "As defined in  phase 7 , an  OutputStep  will have as\none of its attributes a list of rules that the user has attached to it.  Now\nwe stipulate that each  OutputRule  must have a routine  .validate(step) ,\nand that the  .validate()  routine for the  OutputStep  class just does\nthis:  For the first rule  R  in the step's  rules  list, try  R.validate() \non the step.  If it marks the step valid, then use that feedback and stop.\nIf not, try the next rule, and so on.  If none of them mark the step valid,\ngive feedback saying that none of the possible rules applies.  Therefore subclasses of  OutputStep  do not define their own type of\nvalidation routines.  They all use the same validation routine, which defers\nto the list of rules attached to the step.  Steps cite rules, and delegate\ntheir validation to them.  That one routine can include careful error\nhandling (with  try / catch , and paying attention to asynchronous error\nparameters) so that error handling is installed once for all.", 
            "title": "The OutputStep validation routine"
        }, 
        {
            "location": "/phase8-validating-steps/#background-on-background-processes", 
            "text": "The  OutputRule  class will maintain a global list of Web Workers, each\nflagged with the specific subclass of  OutputRule  that created that worker\nand initialized it with validation tools (as described next, in this same\nsection).  Whenever any rule instance asks for a Web Worker to use for\nvalidation, the  OutputRule  class will either find an inactive one that's\nalready been created and ready to validate instances of that subclass, or it\nwill create a new one if none exist.  When such a worker finishes doing its\njob, it gets added to the pool of inactive workers ready for use later.  Each of these workers will be pre-loaded with bootstrap code that knows to\nwatch for and obey certain types of messages from the main thread,\nspecifically, messages that tell it to install new features in itself, such\nas functions, data, and pre-existing code modules.  So a Lurch Web Worker\nwill know how to, say, load the matching package, or the parsing package, or\ninstall an arbitrary function given to it by the main thread, and so on.  We\ncan implement this by making a subclass of  Worker , called  LurchWorker ,\nthat has these features.  Then for a  LurchWorker   L , you can call L.loadScript()  or  L.installFunction()  or  L.installData()  or L.runFunction()  or whatever.  Every subclass of  OutputRule  will have a set of tools it needs to have\ninstalled in a Web Worker.  Specifically, it should implement a function .setupWorker(L)  that takes a  LurchWorker   L  as parameter and makes all\nthe appropriate calls to  L.loadScript() ,  L.installFunction() , and so on.\nWe require that  .setupWorker(L) , in particular, install a function called .validate() , which runs the validation algorithm on whatever data has been\ninstalled in  L , and sends the results back (later) in the usual way that\nJavaScript Web Workers notify their parent threads of events/results/etc.,\nthat is, through a call to  postMessage() , passing any necessary data (such\nas validation feedback).", 
            "title": "Background on background processes"
        }, 
        {
            "location": "/phase8-validating-steps/#outputrule-validation-routines", 
            "text": "Consider an  OutputRule   R  is cited by an  OutputStep   S .  Although informally, above, we spoke of a function  R.validate(S) , the\nactual signature is  R.validate(S,callback) , because validation is\nasynchronous.  Consequently, the loop through rules mentioned earlier will\nbe a series of connected callbacks (or uses of  await ), rather than a\nsynchronous loop.  As described above,  R.validate(S,callback)  begins by loading/creating a LurchWorker   L  that knows how to do validation for the specific OutputRule  subclass of which  R  is an instance.  (Note: Use object.constructor  or  object.constructor.name  to get a \"class\" or its\nname in JavaScript or CoffeeScript.)  The rule  R  will then need to tell the worker  L  about the specifics of\nthe step  S  (e.g., the step itself, its cited premises, any other options),\nso that validation can be run on that specific data.  (Recall that  S  is an\nobject in the LDE thread, and it is not possible to send objects across\nthread boundaries (into  L , in this case) without first converting them to\nJSON.  For this reason, the  OutputStructure  class must define a .toJSON()  routine, and every  LurchWorker  should have installed in it the\ninverse routine, for reconstituting an  OutputStructure  from JSON data.)\nWe require each  OutputRule  subclass to define a function R.prepareToValidate(L,S)  that prepares  L  to validate  S  by exporting\nall the relevant data about  S  (and any relevant  OutputStructure s\naccessible to it) from the LDE into  L , using  S.toJSON() , L.installData() , and so on.  (In order to help enforce the constraint that validation is supposed to be\ncontingent upon only those structures accessible to the one being validated,\nwe may create a convenience function  L.installStructure()  that does the\nconversion to and from JSON for us, but checks to be sure that only\naccessible structures are transferred.)  R  will then call  L.runFunction('validate') .  It will also install an\nevent listener so that when  L  sends back a message (either that validation\nis complete or that an error occurred),  R  hears about it and can react.\nSpecifically,  R 's reaction will be to call the  callback  function\nprovided to  R.validate(S,callback) , passing the validation feedback.  Because all validation is therefore shipped into background processes like L , it is therefore perfectly acceptable for those processes to do lengthy\ncomputations, such as trying all permutations of ordered premises when\nmatching.  Thus each  OutputRule  subclass will not implement its own  .validate() \nroutine, but rather its own  .prepareToValidate()  and  .setupWorker() \nroutines.  The latter installs the actual validation algorithms, and the\nformer installs the necessary parameters.  But  .validate()  can be defined\nonce for all in the  OutputRule  class itself.  Consequently, we can place\nextensive error handling there, in several different ways:   try / catch  blocks where needed  paying attention to asynchronous error parameters  listening for the  onerror  event of the worker  watching the worker to make sure it does not exceed a maximum time limit\n   (e.g., 10 seconds, or whatever the user's settings dictate)", 
            "title": "OutputRule validation routines"
        }, 
        {
            "location": "/phaseN-archive/", 
            "text": "We have designed the work on the Lurch Deductive Engine (LDE) to progress in\nphases.  The idea is that each phase ends with a completed whole that can be\ntested in that state, and that provides more features than the previous\nstate did.  By the time the final phase is complete, the LDE will be a\nrobust and useful product.\n\n\nThis file contains ideas that were formerly listed as phases 2 through 11.\nBut since they were written, phase 1 was completely redesigned (in a very\nhelpful way).  Thus these ideas no longer apply as they once did.\n\n\nHowever, they have many good ideas within them, and are thus retained here\nto be referenced later when building on top of the newly-redesigned\nfoundation of \nStructure\ns.\n\n\nLDE Design Phase 2: Basic Validation\n\n\nThis phase defines:\n\n\n\n\nStatements (just atomic expressions whose contents are a string, and\n   contain no child structures)\n\n\nDefinitions of the simplest rule type only: code rules written in\n   JavaScript\n\n\nFormal systems (or \"mathematical topics\", which are structures we can\n   put rules inside of)\n\n\n\n\nThis enables really simple formal systems, ones whose statements are strings\nand that require no citing of premises.  Examples:\n\n\n\n\nTriX game (in which the previous statement is always the only premise,\n   and is never cited) would become possible after Phase 2.\n\n\nA system that verifies each statement independently (e.g., arithmetic\n   equations and inequalities) would also be possible.\n\n\n\n\nWhile the intent is eventually for nontrivial validation tasks to be placed\nin a queue and handled in background threads, that work is not part of\nPhase 2.  A later phase will add support for it.\n\n\nExtending the \nStructure\n module\n\n\nGiving feedback\n\n\n\n\nExtend the generic \nStructure\n class with a convenience function called\n   \nfeedback(a,b)\n that sets the computed attribute with key \"feedback\" to a\n   JSON object whose validation result is \na\n and whose corresponding brief\n   message is \nb\n.  If both arguments are omitted, then the \"feedback\"\n   computed attribute is removed.  For instance, we might make calls like\n   \nS.feedback('valid','This rule is used correctly.')\n or\n   \nS.feedback('invalid','You did not provide a valid reason.')\n.\n\n\n\n\nEvent handlers\n\n\n\n\nExtend the generic \nStructure\n class with new event handlers for\n   \naboutToChange\n, \naboutToBeInserted\n, and \naboutToBeRemoved\n.\n\n\nCheck to see whether the existing event handlers (\nwasInserted\n,\n   \nwasRemoved\n, and \nwasChanged\n) are tested in the unit tests.  If not,\n   add tests for them, together with tests for these new events.\n\n\nProvide a default implementation for \naboutToBeRemoved()\n that calls\n   \nwhatCitesMe()\n in the same object and stores the result in a temporary\n   field in the object.  Then provide a default implementation of\n   \nwasRemoved()\n that calls \nvalidate()\n on every structure on that list.\n\n\nProvide default implementations of \nwasInserted()\n and \nwasChanged()\n\n   that each call \nvalidate()\n in the same object, if that function exists.\n\n\n\n\nBuilding and running functions\n\n\n\n\nAdd to the \nStructure\n class a class method \nrunFunction(f,args,cb)\n that\n   converts the string of JavaScript code \nf\n into a function (through the\n   \nFunction\n constructor), then runs it on the given set of arguments,\n   sending the result to the given callback (or an error instead, using the\n   standard two-argument callback signature).  This will be overridden by\n   the LDE with an asynchronous method, but it needs to exist so that the\n   \nStructure\n class is, in theory, independent of the LDE.\n\n\n\n\nExtending the \nLDE\n module\n\n\nBuilding and running functions in the background\n\n\n\n\nAfter loading the \nStructure\n module, replace its class method\n   \nrunFunction\n with one that operates asynchronously, sending the job to a\n   background thread.  If the thread does not terminate in a short time,\n   send back an error about termination time.  Keep track of all background\n   threads that are currently running, so that the total can be queried at\n   any given time.\n\n\nExtend each of the LDE's functions (\ninsert\n, \nreplace\n, etc.) so that if\n   it terminates without there being any currently running background\n   threads then it posts a message that LDE computations are complete.\n\n\nExtend the LDE's new implementation of \nrunFunction\n so that whenever it\n   finishes calling the callback, if there are no background threads\n   running at that time, it posts the same message about computations being\n   complete.\n\n\n\n\nCode-based rules\n\n\nThe \nRule\n class will be a subclass of \nStructure\n.  If \nR\n is an instance\nof \nRule\n then its \nvalidate()\n function should be as follows.\n\n\n\n\nIf \nR.isA 'code'\n fails, then call \nR.feedback('invalid','...')\n with\n   a message that only code rules are supported so far.  Then jump to the\n   final bullet point in this list.\n\n\nIf \nR.text()\n isn't valid JavaScript code that defines a function,\n   then \nR.feedback('invalid','...')\n with a message to that effect.\n   Then jump to the final bullet point in this list.\n\n\nOtherwise \nR.feedback('valid','This is a valid code rule.')\n.  Then:\n\n\nFor every expression in \nR.whatCitesMe()\n, revalidate it.\n\n\n\n\nStatements\n\n\nThe \nStatement\n class will be a subclass of \nStructure\n.  If \nS\n is an\ninstance of \nStatement\n then its \nvalidate()\n function should be as follows.\n\n\n\n\nIf \nS.children().length \n 0\n then call \nS.feedback('invalid','...')\n\n   with a message that only atomic statements supported so far.\n   Then stop.\n\n\nIf \nS\n does not have a reason attached to it, then call\n   \nS.feedback()\n to clear feedback, and stop.\n\n\nIf \nS\n has more than one reason attached to it, then call\n   \nS.feedback('invalid','...')\n with a message that multiple reasons is\n   not permitted.  Then stop.\n\n\nTreat the one reason attached to \nS\n as a reference and look it up.\n   If it produces no structure, call \nS.feedback('invalid','...')\n with a\n   message that there is no such reason.  Then stop.\n\n\nTake the object found in the previous bullet point.  If it is not an\n   instance of the \nRule\n subclass defined below, call\n   \nS.feedback('invalid','...')\n with a message that the cited reason is\n   not a rule.  Then stop.\n\n\nIf the cited rule has not been validated, then stop here.  (When it\n   gets validated, it will trigger a re-validation of \nS\n.)\n\n\nLet f be the JavaScript function defined in the text of the rule and\n   call \nf(S)\n in a background thread.\n\n\nIf \nf(S)\n ends with an error, then call \nS.feedback(\"invalid\",\"...\")\n\n   with a message about an internal rule error.\n\n\nIf \nf(S)\n does not terminate quickly, then call\n   \nS.feedback(\"invalid\",\"...\")\n with a message about an internal rule\n   error.\n\n\nIf \nf(S)\n is not a correctly formed validation result object, then\n   call \nS.feedback(\"invalid\",\"...\")\n with a message about an internal\n   rule error.  Note that a correctly formed validation result object\n   will have a \ntype\n (\"valid\", \"invalid\") and a \nmessage\n.\n\n\nOtherwise call \nS.feedback(f(S).type,f(S).message)\n.\n\n\n\n\nFormal systems (or \"mathematical topics\")\n\n\nThe \nFormalSystem\n class will be a subclass of \nStructure\n, and will add\nsupport for the following new member functions.  Assume \nF\n is an instance\nof \nFormalSystem\n in each case.  Further assume that \nS\n is an instance of\n\nStructure\n in each case.\n\n\n\n\nF.exports()\n returns an array composed of these things, in the order\n   they appear in the document:\n\n\nany \nRule\n instance in \nF.children()\n\n\nany element of \nF2.exports()\n for any formal system \nF2\n in\n  \nF.children()\n\n\n\n\n\n\nExtend \nS.lookup(label)\n to also check \nF.exports()\n whenever it\n   encounters an accessible \nFormalSystem\n instance.\n\n\nExtend \nS.whatCitesMe()\n to also looks at the scope of \nS.parent()\n iff\n   it is a \nFormalSystem\n instance (and its \nparent()\n iff that is a\n   \nFormalSystem\n instance, and so on).\n\n\nOverride the default implementation of \nF.wasInserted()\n so that it now\n   calls \nR.whatCitesMe()\n for every \nR\n in \nF.exports()\n and revalidates\n   every structure on any of those lists.\n\n\nExtend the implementation of \nF.aboutToBeRemoved()\n and \nF.wasRemoved()\n\n   so that each propagates the call to the function of the same name in all\n   structures in \nF.exports()\n.\n\n\n\n\nUnit testing\n\n\nHow we could do unit testing on this simple LDE:\n\n\n\n\nFire up the LDE so that its document is new and thus blank.\n\n\nSet up a listener for the \"computation finished\" signals from the LDE,\n   storing the results for use in testing.\n\n\nTell the LDE to add three children to the LDE Document: a rule, a step\n   using it correctly, and a step using it incorrectly.\n\n\nWait until we receive the signal that says the LDE has finished\n   computing.\n\n\nExamine the computation results stored in step 2 and verify correct\n   processing of the rule and two steps.\n\n\n\n\nConsider each of the unusual corner cases handled above and create tests for\nit, including such situations as these:\n\n\n\n\nSend a signal to the LDE to alter the incorrect use of the rule, making\n   it correct.  Wait for computation to finish and check to be sure it\n   re-validated that step as correct now.\n\n\nInsert a rule with label X, followed by a statement with label X,\n   followed by a statement citing reason X.  Ensure the statement does not\n   validate because it cites a non-rule.  Remove the statement labeled X.\n   Ensure the remaining statement validates because it now cites rule X.\n\n\nIn a blank document, insert a statement that cites rule Y.  Then insert a\n   formal system containing rule Y before the statement.  Ensure that the\n   system notices, and that the statement automatically had its validation\n   updated.\n\n\n\n\nLDE Design Phase 3: The Client\n\n\nThis phase defines the LDE Client, a thin interface to the LDE defined in a\nseparate module.\n\n\nThe Client maintains the Facade, a shallow copy of the LDE Document that it\nkeeps in sync with it, thus providing an easy API for interacting with the\nLDE.\n\n\nThis page is just a description; it's not actually written in a \"design\" or\n\"how to build\" manner, at least not to the same degree that Phase 2 was.\n\n\nThis phase's work just makes Phase 1's work easier to use for most clients.\n\n\nApp launch\n\n\nWhen the Client is loaded into memory (say, at app launch) it will create a\nglobal structure that is intended to be a sort of shallow/shadow/fake copy\nof the LDE Document.\n\n\n\n\nBecause it will imitate the structure of the LDE Document, it will be\n   a hierarchy.\n\n\nBut it will not be a hierarchy of Structures, because as we know,\n   Structures do computation, and that's the job of the LDE.  This is\n   just a front-end; it doesn't do anything.\n\n\nSo rather than calling each node in the Client's hierarchy a\n   Structure, I'll call it a \nFacade.\n  This is to emphasize that this\n   hierarchy, stored in the Client (part of the UI) can't do anything at\n   all.  It's picture of what's really going on elsewhere, in the LDE.\n\n\n\n\nBackground threads\n\n\nThe Client can be told about the existence of a background thread that's\nrunning the LDE.\n\n\n\n\nIf it is told about such a thread, then any later\n   insertions/deletions/changes to the Facade hierarchy will immediately\n   be communicated by the Client to that LDE thread as a change event\n   (defined above).\n\n\nThis guarantees that the Facade hierarchy and LDE Document are always\n   in sync:  Because the LDE never alters its hierarchy, messages need\n   propagate in only one direction to guarantee that the two hierarchies\n   are isomorphic.\n\n\n\n\nNo subclasses\n\n\nBecause the nodes in the Facade don't actually do anything, they have no\nsubclasses.\n\n\n\n\nUnlike the Structure class, which it makes sense to subclass so that\n   we can add various features like validation functions and so forth,\n   none of that matters in the Facade.  It ships all that work to\n   someone else.\n\n\nThus every node in the Facade hierarchy is a generic Facade node,\n   storing a dictionary of attributes given to it at construction time,\n   which are precisely the attributes for that node.\n\n\nThese attributes will have been communicated to the LDE when the\n   Facade node was constructed, and the LDE can use them to figure out\n   how to create a corresponding Structure node on the LDE side (or any\n   subclass of Structure; one attribute should be the class name\n   itself!).\n\n\nBut the point here is that what it means for the Facade to be a\n   shallow/inactive copy of the LDE Document is that:\n\n\nEvery node is just a Facade node, and thus they have no\n  specialized functionality at all.\n\n\nEvery node just stores its attributes, not doing anything with\n  them, unlike on the LDE Document side, which does computation.\n\n\n\n\n\n\n\n\nSerialization\n\n\n\n\nFacade nodes do one thing, actually:  They know how to serialize\n   themselves into JSON, including all their children.\n\n\nThis is so that they can pass themselves across to the LDE for syncing,\n   and so that the entire Facade can be serialized by the UI (later of\n   course) for saving in document metadata.\n\n\n\n\nIDs\n\n\nEach Facade node will be given, at the time it's created, an ID unique\namong all nodes in the Facade hierarchy.\n\n\n\n\nThis unique ID will be part of what's communicated in the change event\n   to the LDE, so that the corresponding Structure created in the LDE can\n   have the same ID.\n\n\nThus future change events from the Client to the LDE can reference nodes\n   in the hierarchy by this common ID system.\n\n\nSimilarly, when the LDE sends out signals about new computed attributes\n   being stored in the LDE Document, it will mention these unique IDs to\n   unambiguously indicate in which node the new computed attribute is\n   stored.\n\n\nThe Client will then store the same computed attribute in the\n   corresponding Facade node, so that it is accessible to the entire UI as\n   well.\n\n\n\n\nUnit testing\n\n\n\n\nVerify that the Facade hierarchy can be built and works independent of\n   the LDE\n\n\nVerify that if you connect it to an LDE background thread, the documents\n   stay in sync\n\n\nVerify that the same tests done in Phase 2 can be done also through this\n   \"API\" to the LDE\n\n\nAll further testing in later phases has the option of using the Client\n   or not, depending on what's best for testing in that particular instance.\n\n\n\n\nExtendability\n\n\n\n\nThe LDE is free to expose to clients any other functionality it sees\n   fit.  That is, interaction with the LDE is not limited to syncing the\n   Facade with the LDE Document and waiting for computed responses.\n\n\nFor instance, one type of response that should only be produced when\n   specifically asked for is a \"verbose feedback\" response, like what we\n   get in the old desktop Lurch by double-clicking a traffic light.  This\n   is too much work to create for every step of work, but should be created\n   only when needed.\n\n\nThus the LDE could expose a computeVerboseFeedback() function that took\n   the unique ID of an LDE Document structure as input and later sent back\n   a message with the corresponding verbose feedback (in HTML form) as the\n   result.\n\n\n\n\nLDE Design Phase 4: Dependencies\n\n\n\n\nSupport dependencies as read-only first-few-children of the document.\n\n\nThey need to be validated only to be sure they don't redeclare one\n   another's stuff.\n\n\nNote that every structure already has an .exports() method, so we just\n   need to implement that structure for the root of the LDE Document, and\n   that will be what a document exports when it is used as a dependency.\n\n\n\n\nRule definitions can be stored in a master document on which others depend,\nand many later documents can all use the same central rule set.\n\n\nLDE Design Phase 5: Background Queue\n\n\nNew stuff\n\n\nThe stuff in the \"old stuff\" section, immediately after this one, may no\nlonger apply; it is from an old design.  But these new plans may still be\nrelevant, depending on how efficiently interpretation is eventually seen to\nbe:\n\n\nCurrently, interpretation is triggered immediately in response to calls to\nthe LDE's API.  If that interpretation process takes too long, a queue of\nAPI calls can be formed.  When any request comes in to the LDE API, rather\nthan being immediately executed, it would go on a queue.  The \nold\n way of\nprocessing such events is analogous to handling the queue like so:\n\n\n\n\nPop an item off this API command queue\n\n\nPerform the item\n\n\nCall .markDirty() in the relevant node\n\n\nCall root.recursiveInterpret()\n\n\nRepeat from step 1 until the queue is empty\n\n\n\n\nBut now that we have a queue, we can do the following more efficient procedure instead:\n\n\n\n\nPop an item off this API command queue\n\n\nPerform the item\n\n\nCall .markDirty in the relevant node\n\n\nRepeat from step 1 until the queue is empty\n\n\nCall root.recursiveInterpret()\n\n\n\n\nThus many quick API calls in succession will result in just one (possibly\nexpensive) call to root.recursiveInterpret(), rather than many such\n(possibly expensive) calls.\n\n\nOld stuff\n\n\n\n\nAdd a mechanism for queueing tasks to be done later.\n\n\nIt should be smart enough that, whenever task X is enqueued, then any\n   already-enqueued task Y that will need to be redone after X anyway\n   should be removed form the queue, for efficiency.\n\n\nThen rewrite Phases 2 and 3 to use this feature as needed.\n   All later phases should enqueue all nontrivial processing tasks this way.\n\n\n\n\nAll the work done before this operates more efficiently, and the large and\ncomplex deductive engine we plan to build on the foundation we have so far\nwill still be performant.\n\n\nLDE Design Phase 6: String Matching\n\n\nExtend rules to include string-based matching (like the kind of matching\nCircle-Dot and MIU use)\n\n\nThis enables: toy systems like Circle-Dot and MIU\n\n\nLDE Design Phase 7: Theorems and Proofs\n\n\n\n\nProofs (which are also subproofs)\n\n\nTheorem statements\n\n\nPairing of theorems with proofs\n\n\nHomework problems (which may be the same as a theorem-proof pair!)\n\n\n\n\nThis enables:\n\n\n\n\nProofs\n\n\nHomework assignments\n\n\n\n\nLDE Design Phase 8: Expressions\n\n\n\n\nExpanded form for non-atomic expressions (function applications,\n   binding, variables, constants, etc.)\n\n\nExtend rules to pattern-based matching (the usual kind of rules we think\n   of in math)\n\n\n\n\nThis enables: propositional logic, but with statements in expanded form only\n\n\nLDE Design Phase 9: Parsing\n\n\n\n\nRules for defining parsing\n\n\nConstant declarations may be implemented under the hood as special cases\n   of language rules.\n\n\nThis does not mean they must parse into OpenMath symbols.  It is\n  acceptable to parse them into, for example, OpenMath strings, with a\n  special attribute Constant=True, or any equally unique/recognizable\n  expression.\n\n\nAlso, this does not mean that constant declarations must feel to the\n  user like language rule declarations feel.  We can let users think of\n  them and express them as constant declarations, but under the hood it\n  may be implemented as if it had been a language rule.\n\n\n\n\n\n\n\n\nThis enables: propositional logic in its usual notation, and other related\nsimple systems\n\n\nLDE Design Phase 10: Declarations\n\n\n\n\nVariable declarations (which may be a special type of expression, or may\n   be a special type of subproof--i.e., do we mark a variable as a\n   declaration, or do we mark a subproof as a variable declaration one, and\n   then the variable at the start of it is declared?)\n\n\nExamples (structures in which you declare all manner of stuff that\n   doesn't bleed out)\n\n\n\n\nThis enables: predicate logic in standard math notation, and many other math\ntopics\n\n\nLDE Design Phase 11: Features\n\n\nAdd features to anything built so far (like multiple conclusions from a\nrule, or automatic premise finding, or automatic premise ordering, or the\nability to specify metavariable instantiations, or any of 1000 other\nfeatures we'd like to add)", 
            "title": "Phase N, List of outdated phases"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-2-basic-validation", 
            "text": "This phase defines:   Statements (just atomic expressions whose contents are a string, and\n   contain no child structures)  Definitions of the simplest rule type only: code rules written in\n   JavaScript  Formal systems (or \"mathematical topics\", which are structures we can\n   put rules inside of)   This enables really simple formal systems, ones whose statements are strings\nand that require no citing of premises.  Examples:   TriX game (in which the previous statement is always the only premise,\n   and is never cited) would become possible after Phase 2.  A system that verifies each statement independently (e.g., arithmetic\n   equations and inequalities) would also be possible.   While the intent is eventually for nontrivial validation tasks to be placed\nin a queue and handled in background threads, that work is not part of\nPhase 2.  A later phase will add support for it.", 
            "title": "LDE Design Phase 2: Basic Validation"
        }, 
        {
            "location": "/phaseN-archive/#extending-the-structure-module", 
            "text": "Giving feedback   Extend the generic  Structure  class with a convenience function called\n    feedback(a,b)  that sets the computed attribute with key \"feedback\" to a\n   JSON object whose validation result is  a  and whose corresponding brief\n   message is  b .  If both arguments are omitted, then the \"feedback\"\n   computed attribute is removed.  For instance, we might make calls like\n    S.feedback('valid','This rule is used correctly.')  or\n    S.feedback('invalid','You did not provide a valid reason.') .   Event handlers   Extend the generic  Structure  class with new event handlers for\n    aboutToChange ,  aboutToBeInserted , and  aboutToBeRemoved .  Check to see whether the existing event handlers ( wasInserted ,\n    wasRemoved , and  wasChanged ) are tested in the unit tests.  If not,\n   add tests for them, together with tests for these new events.  Provide a default implementation for  aboutToBeRemoved()  that calls\n    whatCitesMe()  in the same object and stores the result in a temporary\n   field in the object.  Then provide a default implementation of\n    wasRemoved()  that calls  validate()  on every structure on that list.  Provide default implementations of  wasInserted()  and  wasChanged() \n   that each call  validate()  in the same object, if that function exists.   Building and running functions   Add to the  Structure  class a class method  runFunction(f,args,cb)  that\n   converts the string of JavaScript code  f  into a function (through the\n    Function  constructor), then runs it on the given set of arguments,\n   sending the result to the given callback (or an error instead, using the\n   standard two-argument callback signature).  This will be overridden by\n   the LDE with an asynchronous method, but it needs to exist so that the\n    Structure  class is, in theory, independent of the LDE.", 
            "title": "Extending the Structure module"
        }, 
        {
            "location": "/phaseN-archive/#extending-the-lde-module", 
            "text": "Building and running functions in the background   After loading the  Structure  module, replace its class method\n    runFunction  with one that operates asynchronously, sending the job to a\n   background thread.  If the thread does not terminate in a short time,\n   send back an error about termination time.  Keep track of all background\n   threads that are currently running, so that the total can be queried at\n   any given time.  Extend each of the LDE's functions ( insert ,  replace , etc.) so that if\n   it terminates without there being any currently running background\n   threads then it posts a message that LDE computations are complete.  Extend the LDE's new implementation of  runFunction  so that whenever it\n   finishes calling the callback, if there are no background threads\n   running at that time, it posts the same message about computations being\n   complete.", 
            "title": "Extending the LDE module"
        }, 
        {
            "location": "/phaseN-archive/#code-based-rules", 
            "text": "The  Rule  class will be a subclass of  Structure .  If  R  is an instance\nof  Rule  then its  validate()  function should be as follows.   If  R.isA 'code'  fails, then call  R.feedback('invalid','...')  with\n   a message that only code rules are supported so far.  Then jump to the\n   final bullet point in this list.  If  R.text()  isn't valid JavaScript code that defines a function,\n   then  R.feedback('invalid','...')  with a message to that effect.\n   Then jump to the final bullet point in this list.  Otherwise  R.feedback('valid','This is a valid code rule.') .  Then:  For every expression in  R.whatCitesMe() , revalidate it.", 
            "title": "Code-based rules"
        }, 
        {
            "location": "/phaseN-archive/#statements", 
            "text": "The  Statement  class will be a subclass of  Structure .  If  S  is an\ninstance of  Statement  then its  validate()  function should be as follows.   If  S.children().length   0  then call  S.feedback('invalid','...') \n   with a message that only atomic statements supported so far.\n   Then stop.  If  S  does not have a reason attached to it, then call\n    S.feedback()  to clear feedback, and stop.  If  S  has more than one reason attached to it, then call\n    S.feedback('invalid','...')  with a message that multiple reasons is\n   not permitted.  Then stop.  Treat the one reason attached to  S  as a reference and look it up.\n   If it produces no structure, call  S.feedback('invalid','...')  with a\n   message that there is no such reason.  Then stop.  Take the object found in the previous bullet point.  If it is not an\n   instance of the  Rule  subclass defined below, call\n    S.feedback('invalid','...')  with a message that the cited reason is\n   not a rule.  Then stop.  If the cited rule has not been validated, then stop here.  (When it\n   gets validated, it will trigger a re-validation of  S .)  Let f be the JavaScript function defined in the text of the rule and\n   call  f(S)  in a background thread.  If  f(S)  ends with an error, then call  S.feedback(\"invalid\",\"...\") \n   with a message about an internal rule error.  If  f(S)  does not terminate quickly, then call\n    S.feedback(\"invalid\",\"...\")  with a message about an internal rule\n   error.  If  f(S)  is not a correctly formed validation result object, then\n   call  S.feedback(\"invalid\",\"...\")  with a message about an internal\n   rule error.  Note that a correctly formed validation result object\n   will have a  type  (\"valid\", \"invalid\") and a  message .  Otherwise call  S.feedback(f(S).type,f(S).message) .", 
            "title": "Statements"
        }, 
        {
            "location": "/phaseN-archive/#formal-systems-or-mathematical-topics", 
            "text": "The  FormalSystem  class will be a subclass of  Structure , and will add\nsupport for the following new member functions.  Assume  F  is an instance\nof  FormalSystem  in each case.  Further assume that  S  is an instance of Structure  in each case.   F.exports()  returns an array composed of these things, in the order\n   they appear in the document:  any  Rule  instance in  F.children()  any element of  F2.exports()  for any formal system  F2  in\n   F.children()    Extend  S.lookup(label)  to also check  F.exports()  whenever it\n   encounters an accessible  FormalSystem  instance.  Extend  S.whatCitesMe()  to also looks at the scope of  S.parent()  iff\n   it is a  FormalSystem  instance (and its  parent()  iff that is a\n    FormalSystem  instance, and so on).  Override the default implementation of  F.wasInserted()  so that it now\n   calls  R.whatCitesMe()  for every  R  in  F.exports()  and revalidates\n   every structure on any of those lists.  Extend the implementation of  F.aboutToBeRemoved()  and  F.wasRemoved() \n   so that each propagates the call to the function of the same name in all\n   structures in  F.exports() .", 
            "title": "Formal systems (or \"mathematical topics\")"
        }, 
        {
            "location": "/phaseN-archive/#unit-testing", 
            "text": "How we could do unit testing on this simple LDE:   Fire up the LDE so that its document is new and thus blank.  Set up a listener for the \"computation finished\" signals from the LDE,\n   storing the results for use in testing.  Tell the LDE to add three children to the LDE Document: a rule, a step\n   using it correctly, and a step using it incorrectly.  Wait until we receive the signal that says the LDE has finished\n   computing.  Examine the computation results stored in step 2 and verify correct\n   processing of the rule and two steps.   Consider each of the unusual corner cases handled above and create tests for\nit, including such situations as these:   Send a signal to the LDE to alter the incorrect use of the rule, making\n   it correct.  Wait for computation to finish and check to be sure it\n   re-validated that step as correct now.  Insert a rule with label X, followed by a statement with label X,\n   followed by a statement citing reason X.  Ensure the statement does not\n   validate because it cites a non-rule.  Remove the statement labeled X.\n   Ensure the remaining statement validates because it now cites rule X.  In a blank document, insert a statement that cites rule Y.  Then insert a\n   formal system containing rule Y before the statement.  Ensure that the\n   system notices, and that the statement automatically had its validation\n   updated.", 
            "title": "Unit testing"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-3-the-client", 
            "text": "This phase defines the LDE Client, a thin interface to the LDE defined in a\nseparate module.  The Client maintains the Facade, a shallow copy of the LDE Document that it\nkeeps in sync with it, thus providing an easy API for interacting with the\nLDE.  This page is just a description; it's not actually written in a \"design\" or\n\"how to build\" manner, at least not to the same degree that Phase 2 was.  This phase's work just makes Phase 1's work easier to use for most clients.", 
            "title": "LDE Design Phase 3: The Client"
        }, 
        {
            "location": "/phaseN-archive/#app-launch", 
            "text": "When the Client is loaded into memory (say, at app launch) it will create a\nglobal structure that is intended to be a sort of shallow/shadow/fake copy\nof the LDE Document.   Because it will imitate the structure of the LDE Document, it will be\n   a hierarchy.  But it will not be a hierarchy of Structures, because as we know,\n   Structures do computation, and that's the job of the LDE.  This is\n   just a front-end; it doesn't do anything.  So rather than calling each node in the Client's hierarchy a\n   Structure, I'll call it a  Facade.   This is to emphasize that this\n   hierarchy, stored in the Client (part of the UI) can't do anything at\n   all.  It's picture of what's really going on elsewhere, in the LDE.", 
            "title": "App launch"
        }, 
        {
            "location": "/phaseN-archive/#background-threads", 
            "text": "The Client can be told about the existence of a background thread that's\nrunning the LDE.   If it is told about such a thread, then any later\n   insertions/deletions/changes to the Facade hierarchy will immediately\n   be communicated by the Client to that LDE thread as a change event\n   (defined above).  This guarantees that the Facade hierarchy and LDE Document are always\n   in sync:  Because the LDE never alters its hierarchy, messages need\n   propagate in only one direction to guarantee that the two hierarchies\n   are isomorphic.", 
            "title": "Background threads"
        }, 
        {
            "location": "/phaseN-archive/#no-subclasses", 
            "text": "Because the nodes in the Facade don't actually do anything, they have no\nsubclasses.   Unlike the Structure class, which it makes sense to subclass so that\n   we can add various features like validation functions and so forth,\n   none of that matters in the Facade.  It ships all that work to\n   someone else.  Thus every node in the Facade hierarchy is a generic Facade node,\n   storing a dictionary of attributes given to it at construction time,\n   which are precisely the attributes for that node.  These attributes will have been communicated to the LDE when the\n   Facade node was constructed, and the LDE can use them to figure out\n   how to create a corresponding Structure node on the LDE side (or any\n   subclass of Structure; one attribute should be the class name\n   itself!).  But the point here is that what it means for the Facade to be a\n   shallow/inactive copy of the LDE Document is that:  Every node is just a Facade node, and thus they have no\n  specialized functionality at all.  Every node just stores its attributes, not doing anything with\n  them, unlike on the LDE Document side, which does computation.", 
            "title": "No subclasses"
        }, 
        {
            "location": "/phaseN-archive/#serialization", 
            "text": "Facade nodes do one thing, actually:  They know how to serialize\n   themselves into JSON, including all their children.  This is so that they can pass themselves across to the LDE for syncing,\n   and so that the entire Facade can be serialized by the UI (later of\n   course) for saving in document metadata.", 
            "title": "Serialization"
        }, 
        {
            "location": "/phaseN-archive/#ids", 
            "text": "Each Facade node will be given, at the time it's created, an ID unique\namong all nodes in the Facade hierarchy.   This unique ID will be part of what's communicated in the change event\n   to the LDE, so that the corresponding Structure created in the LDE can\n   have the same ID.  Thus future change events from the Client to the LDE can reference nodes\n   in the hierarchy by this common ID system.  Similarly, when the LDE sends out signals about new computed attributes\n   being stored in the LDE Document, it will mention these unique IDs to\n   unambiguously indicate in which node the new computed attribute is\n   stored.  The Client will then store the same computed attribute in the\n   corresponding Facade node, so that it is accessible to the entire UI as\n   well.", 
            "title": "IDs"
        }, 
        {
            "location": "/phaseN-archive/#unit-testing_1", 
            "text": "Verify that the Facade hierarchy can be built and works independent of\n   the LDE  Verify that if you connect it to an LDE background thread, the documents\n   stay in sync  Verify that the same tests done in Phase 2 can be done also through this\n   \"API\" to the LDE  All further testing in later phases has the option of using the Client\n   or not, depending on what's best for testing in that particular instance.", 
            "title": "Unit testing"
        }, 
        {
            "location": "/phaseN-archive/#extendability", 
            "text": "The LDE is free to expose to clients any other functionality it sees\n   fit.  That is, interaction with the LDE is not limited to syncing the\n   Facade with the LDE Document and waiting for computed responses.  For instance, one type of response that should only be produced when\n   specifically asked for is a \"verbose feedback\" response, like what we\n   get in the old desktop Lurch by double-clicking a traffic light.  This\n   is too much work to create for every step of work, but should be created\n   only when needed.  Thus the LDE could expose a computeVerboseFeedback() function that took\n   the unique ID of an LDE Document structure as input and later sent back\n   a message with the corresponding verbose feedback (in HTML form) as the\n   result.", 
            "title": "Extendability"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-4-dependencies", 
            "text": "Support dependencies as read-only first-few-children of the document.  They need to be validated only to be sure they don't redeclare one\n   another's stuff.  Note that every structure already has an .exports() method, so we just\n   need to implement that structure for the root of the LDE Document, and\n   that will be what a document exports when it is used as a dependency.   Rule definitions can be stored in a master document on which others depend,\nand many later documents can all use the same central rule set.", 
            "title": "LDE Design Phase 4: Dependencies"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-5-background-queue", 
            "text": "", 
            "title": "LDE Design Phase 5: Background Queue"
        }, 
        {
            "location": "/phaseN-archive/#new-stuff", 
            "text": "The stuff in the \"old stuff\" section, immediately after this one, may no\nlonger apply; it is from an old design.  But these new plans may still be\nrelevant, depending on how efficiently interpretation is eventually seen to\nbe:  Currently, interpretation is triggered immediately in response to calls to\nthe LDE's API.  If that interpretation process takes too long, a queue of\nAPI calls can be formed.  When any request comes in to the LDE API, rather\nthan being immediately executed, it would go on a queue.  The  old  way of\nprocessing such events is analogous to handling the queue like so:   Pop an item off this API command queue  Perform the item  Call .markDirty() in the relevant node  Call root.recursiveInterpret()  Repeat from step 1 until the queue is empty   But now that we have a queue, we can do the following more efficient procedure instead:   Pop an item off this API command queue  Perform the item  Call .markDirty in the relevant node  Repeat from step 1 until the queue is empty  Call root.recursiveInterpret()   Thus many quick API calls in succession will result in just one (possibly\nexpensive) call to root.recursiveInterpret(), rather than many such\n(possibly expensive) calls.", 
            "title": "New stuff"
        }, 
        {
            "location": "/phaseN-archive/#old-stuff", 
            "text": "Add a mechanism for queueing tasks to be done later.  It should be smart enough that, whenever task X is enqueued, then any\n   already-enqueued task Y that will need to be redone after X anyway\n   should be removed form the queue, for efficiency.  Then rewrite Phases 2 and 3 to use this feature as needed.\n   All later phases should enqueue all nontrivial processing tasks this way.   All the work done before this operates more efficiently, and the large and\ncomplex deductive engine we plan to build on the foundation we have so far\nwill still be performant.", 
            "title": "Old stuff"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-6-string-matching", 
            "text": "Extend rules to include string-based matching (like the kind of matching\nCircle-Dot and MIU use)  This enables: toy systems like Circle-Dot and MIU", 
            "title": "LDE Design Phase 6: String Matching"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-7-theorems-and-proofs", 
            "text": "Proofs (which are also subproofs)  Theorem statements  Pairing of theorems with proofs  Homework problems (which may be the same as a theorem-proof pair!)   This enables:   Proofs  Homework assignments", 
            "title": "LDE Design Phase 7: Theorems and Proofs"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-8-expressions", 
            "text": "Expanded form for non-atomic expressions (function applications,\n   binding, variables, constants, etc.)  Extend rules to pattern-based matching (the usual kind of rules we think\n   of in math)   This enables: propositional logic, but with statements in expanded form only", 
            "title": "LDE Design Phase 8: Expressions"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-9-parsing", 
            "text": "Rules for defining parsing  Constant declarations may be implemented under the hood as special cases\n   of language rules.  This does not mean they must parse into OpenMath symbols.  It is\n  acceptable to parse them into, for example, OpenMath strings, with a\n  special attribute Constant=True, or any equally unique/recognizable\n  expression.  Also, this does not mean that constant declarations must feel to the\n  user like language rule declarations feel.  We can let users think of\n  them and express them as constant declarations, but under the hood it\n  may be implemented as if it had been a language rule.     This enables: propositional logic in its usual notation, and other related\nsimple systems", 
            "title": "LDE Design Phase 9: Parsing"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-10-declarations", 
            "text": "Variable declarations (which may be a special type of expression, or may\n   be a special type of subproof--i.e., do we mark a variable as a\n   declaration, or do we mark a subproof as a variable declaration one, and\n   then the variable at the start of it is declared?)  Examples (structures in which you declare all manner of stuff that\n   doesn't bleed out)   This enables: predicate logic in standard math notation, and many other math\ntopics", 
            "title": "LDE Design Phase 10: Declarations"
        }, 
        {
            "location": "/phaseN-archive/#lde-design-phase-11-features", 
            "text": "Add features to anything built so far (like multiple conclusions from a\nrule, or automatic premise finding, or automatic premise ordering, or the\nability to specify metavariable instantiations, or any of 1000 other\nfeatures we'd like to add)", 
            "title": "LDE Design Phase 11: Features"
        }, 
        {
            "location": "/enhancements/", 
            "text": "Enhancements for Later\n\n\nThis page lists helpful enhancements to work already completed, but which\nwere not essential enough to have been included in the work done so far.  We\nlist them here so as not to lose track of important improvements we might\nmake later, and we leave empty check boxes next to them so that we can later\nmark them complete as they are implemented.\n\n\n(Entries that were here have been deleted.  This page continues to exist in\nthe event that it may be used again later for other ideas.)", 
            "title": "Enhancements for Later"
        }, 
        {
            "location": "/enhancements/#enhancements-for-later", 
            "text": "This page lists helpful enhancements to work already completed, but which\nwere not essential enough to have been included in the work done so far.  We\nlist them here so as not to lose track of important improvements we might\nmake later, and we leave empty check boxes next to them so that we can later\nmark them complete as they are implemented.  (Entries that were here have been deleted.  This page continues to exist in\nthe event that it may be used again later for other ideas.)", 
            "title": "Enhancements for Later"
        }, 
        {
            "location": "/ideas/", 
            "text": "LDE Design Idea Archive\n\n\nThis document records incomplete ideas the Lurch team is keeping in mind\nfor integration into later design plans.\n\n\n\n\nHow to handle dependencies in the new design:\n\n\nEvery \nOutputStructure\n instance knows whether or not it should get\n  exported to dependencies or not.  For instance, steps of work don't\n  get exported, but declarations of grammar rules, ROIs, and constants\n  would get exported.\n\n\nA method in the generic \nOutputStructure\n class called \n.export()\n\n  would be called on the \nOutputTree\n root and would just check to see\n  if any of the children of the root have the property mentioned in\n  the previous bullet point (because only the children of the root are\n  accessible to subsequent documents; everything else is inside\n  something else).  It would return the result as an array.\n\n\nThat array of \nOutputTree\n nodes would be serialized and packaged up\n  as the data that dependency would export, as a big chunk of JSON.\n\n\nAny future Lurch document that imported that dependency would\n  represent the dependency using, as you suggest, a single\n  \nInputStructure\n of type \nInputDependency\n, with a payload of data\n  that is that big chunk of JSON.\n\n\nThe \n.interpret()\n routine for \nInputDependency\n instances is to\n  simply deserialize the \nOutpuTree\n nodes back from JSON.  So we are\n  quite literally copying nodes from a dependency document into the\n  documents on which they depend.\n\n\n\n\n\n\nWe have considered a UI with buttons with mathematical names on them,\n   such as Justify (which would let you choose a reason and it would insert\n   it), Cite (which would let you click any premise and it would make the\n   arrow), a toolbar of all math words.\n\n\nWe have tested a Suggestions feature, and could really use it widely:\n\n\nWhen the cursor is near something the software could recognize as a\n  statement or a reason, it gives a faint shadow over it of what it\n  thinks you're saying.\n\n\nA single keystroke confirms, and if you don't use that keystroke, the\n  shadowy suggestion is never actually realized in the document.\n\n\nExample usage:\n\n\nType, then hit \nCtrl+Enter\n to approve an interpretation of what\n  you said as a statement.\n\n\nA visual indicator of some kind shows that the bubble was formed,\n  but since your cursor is after it, the bubble-forming animation\n  fades.\n\n\nKeep typing, then hit \nCtrl+Enter\n to approve an interpretation of\n  what you said as a reason.\n\n\nSame visual indicator process.\n\n\nImmediately a suggested connection of the reason to the statement\n  appears, and you hit \nCtrl+Enter\n again to connect them.\n\n\nSame visual indicator process.\n\n\nStart typing your next statement, and repeat from step 1.\n\n\n\n\n\n\nWhenever your cursor is in a statement accessible to the most recent\n  justification you formed, a suggested premise citation arrow could\n  appear; \nCtrl+Enter\n to confirm.\n\n\n\n\n\n\nMathQuill (and, one day, MathJax, if we choose to add it) are UX sugar\n   that sits above the document, and can be converted to text as part of\n   the UI's processing of HTML into Structures.\n\n\nA UI idea from long ago recorded here for safe keeping:\n\n\nConsider all situations in which it\u2019s possible to write a small JS\n  function that can easily take in a string of text and split it into\n  an array of substrings, like \n\"Fred is a fish\"\n to\n  \n[\"Fred is\", \"a\", \"fish\"]\n, such that the array alternates between\n  meaningful stuff and non-meaningful stuff. Then we have two things we\n  can do with such a function.\n\n\nFirst, the translator can obviously use that to trivially lift the\n  meaningful stuff out.\n\n\nSecond, the UX can also use it to \nhighlight\n \nwhile the user is\n  typing in a group\n which parts of the group\u2019s content the app is\n  paying attention to, and which parts it\u2019s ignoring. Imagine typing\n  \n[Fred is a fish]\n and the app is gently highlighting everything\n  except the 'a' or typing\n  \n[Fred, who we all love, is a very nice fish]\n\n  and the app highlights like so:\n  [\nFRED\n, who we all love, \nIS\n a very nice \nFISH\n].\n  Such highlighting would be in the overlay where the bubble is drawn,\n  and shown only when the cursor is in there.\n\n\nOne specific subclass of this idea is when we require rigid formal\n  syntax, like line-numbered proofs with\n  \nstatement[whitespace]reason[whitespace]premise,...\n\n\n\n\n\n\nWe have long intended to support a feature in which a typical formal\n   proof line (statement, reason, premise numbers) might be auto-parsed, but\n   we now have an easy way to do so:\n\n\nHave the UI wrap every single numbered list item in an InputStructure\n  that parses its contents in that way.  That\u2019s all you have to do!\n\n\nWhile this assumes line-numbered proofs, this is often how a course\n  begins.\n\n\nThis brings about a very nice user experience, where users simply type\n  proofs and they are graded without any bubbling procedure!  Automated\n  feedback just appears near your proof as you type it, and no bubbles\n  have to exist anywhere.  This is the ideal.\n\n\nLater, this feature could be extended so that, within a proof block,\n  for example, every paragraph is treated this way even if it is not a\n  numbered list item, and such items are automatically labeled if they\n  end with standard math labeling markers like \n(*)\n or \n(**)\n or \n(1)\n\n  and so on.", 
            "title": "Ideas Archive"
        }, 
        {
            "location": "/ideas/#lde-design-idea-archive", 
            "text": "This document records incomplete ideas the Lurch team is keeping in mind\nfor integration into later design plans.   How to handle dependencies in the new design:  Every  OutputStructure  instance knows whether or not it should get\n  exported to dependencies or not.  For instance, steps of work don't\n  get exported, but declarations of grammar rules, ROIs, and constants\n  would get exported.  A method in the generic  OutputStructure  class called  .export() \n  would be called on the  OutputTree  root and would just check to see\n  if any of the children of the root have the property mentioned in\n  the previous bullet point (because only the children of the root are\n  accessible to subsequent documents; everything else is inside\n  something else).  It would return the result as an array.  That array of  OutputTree  nodes would be serialized and packaged up\n  as the data that dependency would export, as a big chunk of JSON.  Any future Lurch document that imported that dependency would\n  represent the dependency using, as you suggest, a single\n   InputStructure  of type  InputDependency , with a payload of data\n  that is that big chunk of JSON.  The  .interpret()  routine for  InputDependency  instances is to\n  simply deserialize the  OutpuTree  nodes back from JSON.  So we are\n  quite literally copying nodes from a dependency document into the\n  documents on which they depend.    We have considered a UI with buttons with mathematical names on them,\n   such as Justify (which would let you choose a reason and it would insert\n   it), Cite (which would let you click any premise and it would make the\n   arrow), a toolbar of all math words.  We have tested a Suggestions feature, and could really use it widely:  When the cursor is near something the software could recognize as a\n  statement or a reason, it gives a faint shadow over it of what it\n  thinks you're saying.  A single keystroke confirms, and if you don't use that keystroke, the\n  shadowy suggestion is never actually realized in the document.  Example usage:  Type, then hit  Ctrl+Enter  to approve an interpretation of what\n  you said as a statement.  A visual indicator of some kind shows that the bubble was formed,\n  but since your cursor is after it, the bubble-forming animation\n  fades.  Keep typing, then hit  Ctrl+Enter  to approve an interpretation of\n  what you said as a reason.  Same visual indicator process.  Immediately a suggested connection of the reason to the statement\n  appears, and you hit  Ctrl+Enter  again to connect them.  Same visual indicator process.  Start typing your next statement, and repeat from step 1.    Whenever your cursor is in a statement accessible to the most recent\n  justification you formed, a suggested premise citation arrow could\n  appear;  Ctrl+Enter  to confirm.    MathQuill (and, one day, MathJax, if we choose to add it) are UX sugar\n   that sits above the document, and can be converted to text as part of\n   the UI's processing of HTML into Structures.  A UI idea from long ago recorded here for safe keeping:  Consider all situations in which it\u2019s possible to write a small JS\n  function that can easily take in a string of text and split it into\n  an array of substrings, like  \"Fred is a fish\"  to\n   [\"Fred is\", \"a\", \"fish\"] , such that the array alternates between\n  meaningful stuff and non-meaningful stuff. Then we have two things we\n  can do with such a function.  First, the translator can obviously use that to trivially lift the\n  meaningful stuff out.  Second, the UX can also use it to  highlight   while the user is\n  typing in a group  which parts of the group\u2019s content the app is\n  paying attention to, and which parts it\u2019s ignoring. Imagine typing\n   [Fred is a fish]  and the app is gently highlighting everything\n  except the 'a' or typing\n   [Fred, who we all love, is a very nice fish] \n  and the app highlights like so:\n  [ FRED , who we all love,  IS  a very nice  FISH ].\n  Such highlighting would be in the overlay where the bubble is drawn,\n  and shown only when the cursor is in there.  One specific subclass of this idea is when we require rigid formal\n  syntax, like line-numbered proofs with\n   statement[whitespace]reason[whitespace]premise,...    We have long intended to support a feature in which a typical formal\n   proof line (statement, reason, premise numbers) might be auto-parsed, but\n   we now have an easy way to do so:  Have the UI wrap every single numbered list item in an InputStructure\n  that parses its contents in that way.  That\u2019s all you have to do!  While this assumes line-numbered proofs, this is often how a course\n  begins.  This brings about a very nice user experience, where users simply type\n  proofs and they are graded without any bubbling procedure!  Automated\n  feedback just appears near your proof as you type it, and no bubbles\n  have to exist anywhere.  This is the ideal.  Later, this feature could be extended so that, within a proof block,\n  for example, every paragraph is treated this way even if it is not a\n  numbered list item, and such items are automatically labeled if they\n  end with standard math labeling markers like  (*)  or  (**)  or  (1) \n  and so on.", 
            "title": "LDE Design Idea Archive"
        }, 
        {
            "location": "/api-overview/", 
            "text": "API Documentation Overview\n\n\nDesign Plans vs. API Documentation\n\n\nAt the top of this site, notice the two navigation menus entitled \"Design\nPlans\" and \"API Documentation.\"  The difference between them is this:\n\n\n\n\nDesign Plans\n lists concepts that have not yet been implemented and\n   documented.  Consequently, the concepts are usually not described in full\n   detail, but just the best detail available in the planning phase.\n   It answers the question, \"What do we plan to build?\"\n\n\nAPI Documentation\n lists concepts that have been implemented, and for\n   which the developers have therefore been able to document their work.\n   Having the benefit of hindsight, this is therefore more detailed, and\n   often even contains links directly into the source code.\n   It answers the question, \"What did we build?\" and is the official\n   documentation for the modules.\n\n\n\n\nAny page in the Design Plans that has been complete has had most of its\ncontent removed, because it has been superceded by the corresponding API\ndocumentation.  What remains is just a record of what was planne for that\nphase, with links to the corresponding API Documentation.\n\n\nDeveloper Workflow\n\n\nDevelopers designing and/or implementing concepts should therefore progress\nthose concepts through a lifecycle like so:\n\n\n\n\nDescribe the concept in one of the Design Plans page.  Provide as much\n    detail as you can, knowing of course that full details is impossible to\n    provide before the work has been done.\n\n\nAs you implement and test the concept, update those design documents\n    with whatever new information you create or learn as part of the work,\n    thus making them more precise.\n\n\nOnce the concept is fully implemented and tested, document the work in\n    an existing or new page in the API Documentation section.  This may\n    involve copying and pasting some of the content from the design plan,\n    provided that it still applies.  It will probably also involve adding\n    significant detail about the particulars of the implementation.\n\n\nReplace the original (less detailed) documentation in the design plans\n    with a brief description of the concept, followed by a link to the\n    corresponding part of the API Documentation for full details.\n\n\n\n\nFor the Reader\n\n\nReaders of this documentation will therefore be able to see how much has\nbeen implemented by perusing the Design Plans pages.  Those that are brief\noverviews of concepts with links to API Documentation have been implemented.\nThose that are plans for future work, with no links to any API\nDocumentation, have not yet been implemented.", 
            "title": "Overview"
        }, 
        {
            "location": "/api-overview/#api-documentation-overview", 
            "text": "", 
            "title": "API Documentation Overview"
        }, 
        {
            "location": "/api-overview/#design-plans-vs-api-documentation", 
            "text": "At the top of this site, notice the two navigation menus entitled \"Design\nPlans\" and \"API Documentation.\"  The difference between them is this:   Design Plans  lists concepts that have not yet been implemented and\n   documented.  Consequently, the concepts are usually not described in full\n   detail, but just the best detail available in the planning phase.\n   It answers the question, \"What do we plan to build?\"  API Documentation  lists concepts that have been implemented, and for\n   which the developers have therefore been able to document their work.\n   Having the benefit of hindsight, this is therefore more detailed, and\n   often even contains links directly into the source code.\n   It answers the question, \"What did we build?\" and is the official\n   documentation for the modules.   Any page in the Design Plans that has been complete has had most of its\ncontent removed, because it has been superceded by the corresponding API\ndocumentation.  What remains is just a record of what was planne for that\nphase, with links to the corresponding API Documentation.", 
            "title": "Design Plans vs. API Documentation"
        }, 
        {
            "location": "/api-overview/#developer-workflow", 
            "text": "Developers designing and/or implementing concepts should therefore progress\nthose concepts through a lifecycle like so:   Describe the concept in one of the Design Plans page.  Provide as much\n    detail as you can, knowing of course that full details is impossible to\n    provide before the work has been done.  As you implement and test the concept, update those design documents\n    with whatever new information you create or learn as part of the work,\n    thus making them more precise.  Once the concept is fully implemented and tested, document the work in\n    an existing or new page in the API Documentation section.  This may\n    involve copying and pasting some of the content from the design plan,\n    provided that it still applies.  It will probably also involve adding\n    significant detail about the particulars of the implementation.  Replace the original (less detailed) documentation in the design plans\n    with a brief description of the concept, followed by a link to the\n    corresponding part of the API Documentation for full details.", 
            "title": "Developer Workflow"
        }, 
        {
            "location": "/api-overview/#for-the-reader", 
            "text": "Readers of this documentation will therefore be able to see how much has\nbeen implemented by perusing the Design Plans pages.  Those that are brief\noverviews of concepts with links to API Documentation have been implemented.\nThose that are plans for future work, with no links to any API\nDocumentation, have not yet been implemented.", 
            "title": "For the Reader"
        }, 
        {
            "location": "/api-lde/", 
            "text": "API Documentation for the LDE Module\n\n\nThe main LDE module is not yet complete.  So far it supports only the\nfunctionality documented below, which will grow with time.\n\n\nOne Global Document\n\n\nThe module initializes a single \nStructure\n instance in a global variable,\nwhich can be queried with the public API function \ngetDocument()\n.  It\nbegins life as a freshly created \nStructure\n with no attributes, but an ID.\n\n\nThis document is called the \nLDE Document,\n and is the structure on which\nall computations done by the LDE will operate.  In the main Lurch\napplication, it will represent the meaningful content that has been\nextracted from the user's document.\n\n\nManipulating the Document\n\n\nThe document can be manipulated with four functions in the public API of\nthis module:\n\n\n\n\ninsert(structureToInsert,parentID,insertionIndex)\n inserts a new\n   structure within the global document hierarchy, as follows:\n\n\nstructureToInsert\n should be the serialized form of the structure to\n  insert (optionally created with \n.toJSON()\n in a \nStructure\n\n  instance).  After the structure is deserialized and inserted into the\n  document, \ntrackIDs()\n will be called in it; for more information on\n  that function, see \nits entry in the API docs\n.\n\n\nparentID\n is the ID of the parent under which this new child should\n  be inserted.  This must be a string ID that belongs to a structure\n  already in the global document hierarchy.  Note that the root of the\n  hierarchy is given the ID \"root\" at the time the module is loaded.\n\n\ninsertionIndex\n is the index of the child to insert, which must be\n  greater than or equal to zero and less than or equal to the number of\n  children of the parent\n\n\n\n\n\n\ndelete(ID)\n deletes from the global document hierarchy the structure\n   with the given ID, which is interpreted with the same conventions as the\n   \nparentID\n is for the \ninsert\n function.  After the structure is deleted,\n   \nuntrackIDs()\n will be called in it; for more information on that\n   function, see \nits entry in the API docs\n.\n\n\nreplace(ID,newStructure)\n replaces the structure with the given ID with\n   the given new structure.\n\n\nID\n is interpreted with the same conventions as the \nparentID\n is for\n  the \ninsert\n function\n\n\nnewStructure\n is a serialized structure, as \nstructureToInsert\n is\n  for the \ninsert\n function\n\n\nAfter this operation, \nuntrackIDs()\n will be called in the replaced\n  structure and \ntrackIDs()\n in the replacement; for more information\n  on those functions, see\n  \ntheir entries in the API docs\n.\n\n\n\n\n\n\nsetAttribute(ID,key,value)\n modifies a single attribute of a structure\n   within the global document hierarchy, as follows:\n\n\nID\n is interpreted with the same conventions as the \nparentID\n is for\n  the \ninsert\n function\n\n\nkey\n is the key of the attribute to create or overwrite.  If this\n  key happens to be \"id\", then the class-level tracking of IDs will be\n  updated to repsect the change.\n\n\nvalue\n is the new value, which must be JSON data.  (No checks are\n  done to verify that it is JSON data, but errors will transpire\n  eventually if non-JSON data is passed.)\n\n\n\n\n\n\n\n\nAsynchronous API\n\n\nIf the LDE detects that it is being run in a background thread, it will set\nup listeners for messages from the parent thread.  These listeners will\nhandle messages of four types, \ninsert\n/\ndelete\n/\nreplace\n/\nsetAttribute\n,\nmirroring the four functions given above, and calling them internally.\n\n\nThey can be called by passing a message of the form \n[ command, args... ]\n,\nwhere the command is a string (one of \n\"insert\"\n, \n\"delete\"\n, etc.) and the\narguments list is the same list that would be passed to the function itself,\nas documented in the previous section on this page.\n\n\nFor example, you could start an LDE in a WebWorker and insert a new\nstructure as the first child of its global document as follows.\n\n\n    // import the lde.js file (kept in the release/ folder)\n    // (This requires having the structure.js file in the same folder.)\n    var worker = new Worker( 'lde.js' );\n    var A = new Structure();\n    worker.postMessage( [ 'insert', A.toJSON(), 'root', 0 ] );", 
            "title": "The LDE"
        }, 
        {
            "location": "/api-lde/#api-documentation-for-the-lde-module", 
            "text": "The main LDE module is not yet complete.  So far it supports only the\nfunctionality documented below, which will grow with time.", 
            "title": "API Documentation for the LDE Module"
        }, 
        {
            "location": "/api-lde/#one-global-document", 
            "text": "The module initializes a single  Structure  instance in a global variable,\nwhich can be queried with the public API function  getDocument() .  It\nbegins life as a freshly created  Structure  with no attributes, but an ID.  This document is called the  LDE Document,  and is the structure on which\nall computations done by the LDE will operate.  In the main Lurch\napplication, it will represent the meaningful content that has been\nextracted from the user's document.", 
            "title": "One Global Document"
        }, 
        {
            "location": "/api-lde/#manipulating-the-document", 
            "text": "The document can be manipulated with four functions in the public API of\nthis module:   insert(structureToInsert,parentID,insertionIndex)  inserts a new\n   structure within the global document hierarchy, as follows:  structureToInsert  should be the serialized form of the structure to\n  insert (optionally created with  .toJSON()  in a  Structure \n  instance).  After the structure is deserialized and inserted into the\n  document,  trackIDs()  will be called in it; for more information on\n  that function, see  its entry in the API docs .  parentID  is the ID of the parent under which this new child should\n  be inserted.  This must be a string ID that belongs to a structure\n  already in the global document hierarchy.  Note that the root of the\n  hierarchy is given the ID \"root\" at the time the module is loaded.  insertionIndex  is the index of the child to insert, which must be\n  greater than or equal to zero and less than or equal to the number of\n  children of the parent    delete(ID)  deletes from the global document hierarchy the structure\n   with the given ID, which is interpreted with the same conventions as the\n    parentID  is for the  insert  function.  After the structure is deleted,\n    untrackIDs()  will be called in it; for more information on that\n   function, see  its entry in the API docs .  replace(ID,newStructure)  replaces the structure with the given ID with\n   the given new structure.  ID  is interpreted with the same conventions as the  parentID  is for\n  the  insert  function  newStructure  is a serialized structure, as  structureToInsert  is\n  for the  insert  function  After this operation,  untrackIDs()  will be called in the replaced\n  structure and  trackIDs()  in the replacement; for more information\n  on those functions, see\n   their entries in the API docs .    setAttribute(ID,key,value)  modifies a single attribute of a structure\n   within the global document hierarchy, as follows:  ID  is interpreted with the same conventions as the  parentID  is for\n  the  insert  function  key  is the key of the attribute to create or overwrite.  If this\n  key happens to be \"id\", then the class-level tracking of IDs will be\n  updated to repsect the change.  value  is the new value, which must be JSON data.  (No checks are\n  done to verify that it is JSON data, but errors will transpire\n  eventually if non-JSON data is passed.)", 
            "title": "Manipulating the Document"
        }, 
        {
            "location": "/api-lde/#asynchronous-api", 
            "text": "If the LDE detects that it is being run in a background thread, it will set\nup listeners for messages from the parent thread.  These listeners will\nhandle messages of four types,  insert / delete / replace / setAttribute ,\nmirroring the four functions given above, and calling them internally.  They can be called by passing a message of the form  [ command, args... ] ,\nwhere the command is a string (one of  \"insert\" ,  \"delete\" , etc.) and the\narguments list is the same list that would be passed to the function itself,\nas documented in the previous section on this page.  For example, you could start an LDE in a WebWorker and insert a new\nstructure as the first child of its global document as follows.      // import the lde.js file (kept in the release/ folder)\n    // (This requires having the structure.js file in the same folder.)\n    var worker = new Worker( 'lde.js' );\n    var A = new Structure();\n    worker.postMessage( [ 'insert', A.toJSON(), 'root', 0 ] );", 
            "title": "Asynchronous API"
        }, 
        {
            "location": "/api-structures/", 
            "text": "API Documentation for the \nStructure\n Class\n\n\nSource Code\n\n\n\n\nThe \nStructure\n class\n\n\nUnit tests of the \nStructure\n class\n\n\n\n\nPurpose\n\n\nThe Lurch Deductive Engine (LDE, \ndocumented here\n) maintains a\ndocument called the LDE Document, which is a hierarchy (or tree).  The nodes\nin that tree are instances of this class (\nStructure\n) or one of its\nsubclasses.\n\n\nWe build into this base class all the functionality that must be present at\nevery point in that hierarchy, and leave to subclasses that functionality\nthat makes sense only for specific types of structures.  For instance, this\nclass contains no functionality to support rules of inference, because they\nare one specific type of structure, so their functionality will be\nimplemented in a subclass for that purpose.\n\n\nConstructing and Serialization\n\n\nThere is one constructor for the class\n(\nsee source code\n):\n\n\nStructure(child1,child2,...)\n creates a new instance, with the given list\nof children, each of which must be a \nStructure\n instance (or it will be\nignored).  All such children are removed from any old parent they had before\nbeing inserted into this newly created one.\n\n\nInstances can be converted to and from JSON, for saving to a file, storing\npermanently anywhere, or transmitting across threads or network connections.\nTo ensure that deserialization correctly reconstructs instances of the right\nsubclass of \nStructure\n, each subclass must be registered.  To do so, we\nprovide the \naddSubclass\n function.  Use it like so.\n\n\nJavaScript:\n\n\n    MySubclass = function ( /* ... */ ) { /* ... */ };\n    // ...\n    MySubclass.prototype.className = Structure.addSubclass( 'MySubclass', MySubclass );\n\n\n\n\nCoffeeScript, somewhere inside the class definition:\n\n\n    class MySubclass extends Structure\n        # ...\n        className : Structure.addSubclass 'MySubclass', MySubclass\n        # ...\n\n\n\n\nThen one can serialize and deserialize any hierarchy containing \nStructure\n\ninstances, as well as instances of its subclasses, using the member function\n\nsomeInstance.toJSON()\n (which obviously yields a JSON structure) or the\nclass function \nStructure.fromJSON(data)\n, which accepts JSON data created\nfrom the first function.\n\n\nSerializing a structure preserves its class, its attributes (\ndocumented\nbelow\n), and the hierarchy for which\nit is the root.\n\n\nStructure hierarchies\n\n\nTo navigate or alter a hierarchy of \nStructure\n instances, use the\nfollowing member functions present in each instance.\n\n\n\n\ninstance.parent()\n yields the parent structure, or \nnull\n if there is\n   no parent (i.e., the instance is the root of a hierarchy)\n\n\ninstance.children()\n yields an array containing the children structures,\n   in order, or an empty array if there are none\n\n\ninstance.indexInParent()\n yields the index of the child in its parent's\n   ordered list of children, or unddefined if the instance has no parent\n\n\ninstance.previousSibling()\n and \ninstance.nextSibling()\n yield the\n   adjacent structure in the parent's child list, forward or backward, as\n   expected, or undefined if there is no such sibling\n\n\ninstance.removeFromParent()\n drops the instance from it's parent's list\n   of children (thereby decreasing the length of that child list by 1) and\n   thus making \ninstance.parent()\n null\n\n\ninstance.removeChild(index)\n is a convenience equivalent to\n   \ninstance.children()[index].removeFromParent()\n\n\ninstance.insertChild(child,index)\n expects a structure instance as the\n   first argument and an index into the children list as the second.  It\n   inserts the new child at that index, thus increasing the number of\n   children by 1.  You may use an index equal to the length of the child\n   list to append.  The child is removed from its previous parent, if any,\n   before being inserted here.\n\n\ninstance.replaceWith(other)\n expects another structure instance as its\n   argument.  It removes \ninstance\n from its parent, if there is one, and\n   then inserts \nother\n at the same index in the parent, thus replacing\n   \ninstance\n.  This has no effect if \ninstance\n has no parent.  It is\n   equivalent to successive calls to \nremoveFromParent()\n and\n   \ninsertChild()\n at the instance and its parent, respectively.\n\n\ninstance.copy()\n makes a deep copy of the instance, including all nodes\n   below it in the hierarchy.  This new copy will have all the same IDs as\n   the previous copy, so to preserve uniqueness of IDs, you will usually\n   want to call \ncopiedInstance.clearIDs()\n afterwards.\n\n\n\n\nThe order of nodes in the hierarchy is often important.  We have one simple\norder relation on the nodes in the hierarchy, and one more complex.  The\nsimplest is just whether node A is \"earlier than\" node B, in the order\ninduced by an in-order tree traversal (that is, the order in which the open\nparentheses would appear if the tree were written as a LISP expression).\nThis relation can be tested with \ninstance.isEarlierThan(other)\n.\n\n\nThe more complex order relation is accessibility, which we do not define\nhere, because it is already defined \nin the source code\ndocumentation\n.\nThat relation is implemented with the following member functions available\nin all instances of the class.\n\n\n\n\nA.isAccessibleTo(B)\n implements the relation as defined at the link\n   given above.\n\n\nA.isInTheScopeOf(B)\n is equivalent to \nB.isAccessibleTo(A)\n.\n\n\nA.iteratorOverAccessibles()\n yields an \"iterator\" object, which is an\n   object that can produce the list of nodes accessible to \nA\n by repeated\n   calls to the \nnext()\n member of the object.  Consider the following\n   JavaScript code that would use such an iterator.\n\n\n\n\n    var iterator = A.iteratorOverAccessibles();\n    var accessible;\n    while ( accessible = iterator.next() ) {\n        console.log( 'The next accessible structure is:',\n            accessible.toJSON() );\n    }\n\n\n\n\nNodes are produced by the iterator in reverse order (under the\n\nisEarlierThan\n relation) starting from the first accessible node before\n\nA\n.  When the \nnext()\n function yields null for the first time, the end of\nthe list has been reached.  (The \nnext()\n function will yield null forever\nthereafter.)\n\n\nIterators are more efficient than producing the entire list and returning\nit, because the client may be seeking just one particular node in the list,\nand thus producing the entire list so that the client can search just a\nsmall part of it could be wasteful.\n\n\nThere is an analogous function for scopes.\n\n\n\n\nA.iteratorOverScope()\n functions like \nA.iteratorOverAccessibles()\n, but\n   walks forwards through the structure, including precisely those nodes for\n   which \nB.isInTheScopeOf(A)\n holds true.\n\n\n\n\nThere are then four functions that use these iterators under the hood.\nClients will most likely wish to use these rather than have direct access\nto the iterators.\n\n\n\n\nA.firstAccessible(P)\n expects \nP\n to be a one-place predicate (that is,\n   a JavaScript function that can be evaluated on a single argument, and\n   yields true or false in each case) and yields the first item on the\n   \"accessibles\" list (as given by \nA.iteratorOverAccessibles()\n) for which\n   \nP\n yields true.  It returns undefined if there is no such thing.\n\n\nA.firstInScope(P)\n expects \nP\n to be a one-place predicate, as just\n   defined, and behaves just like \nfirstAccessible()\n, except it walks\n   through \nA.iteratorOverScope()\n instead.\n\n\nA.allAccessibles(P)\n expects \nP\n as in the previous two functions, and\n   yields all nodes accessible to \nA\n that satisfy \nP\n, in the same order\n   they would be reported by \niteratorOverAccessibles()\n.\n\n\nA.allInScope(P)\n expects \nP\n as in the previous two functions, and\n   yields all nodes in the scope of \nA\n that satisfy \nP\n, in the same order\n   they would be reported by \niteratorOverScope()\n.\n\n\n\n\nStructure attributes and connections\n\n\nThe following functions available in each instance of the structure class\nsupport attributes.\n\n\n\n\ninstance.getAttribute(key)\n looks up attributes by a given string \nkey\n.\n\n\ninstance.setAttribute(key,value)\n stores attributes under a given\n   string \nkey\n with value \nvalue\n, which should be a JSON structure (or\n   atomic data).  No check is made to verify that the value is of this\n   type, but errors will transpire later if this condition is not satisfied\n   (specifically, serialization errors).\n\n\ninstance.clearAttributes(key1,key2,...)\n removes the key-value pairs\n   of attributes associated with any of the keys passed as parameters.  It\n   is acceptable to pass any number of keys, including just one.  If zero\n   are passed, \nall\n key-value pairs are removed.\n\n\ninstance.attr(object)\n adds all attributes of the given object as\n   attributes to the instance, and returns the instance itself.  This is\n   useful when constructing hierarchies, as follows.\n\n\n\n\n    var A = new Structure(\n        ( new Structure() ).attr( { name : 'example structure' } ),\n        ( new Structure() ).attr( { color : '#99ff00' } )\n    );\n\n\n\n\nConnections as a type of attribute\n\n\nWithin a structure's attributes are two key-value pairs that should not be\nused for any other purpose, those with keys \nconnectionsOut\n and\n\nconnectionsIn\n.  These store data about connections between pairs of\nstructures in the same heirarchy.  The data is stored by structure IDs, so\nmaking connections assumes that structures each have a unique ID, as\ndocumented \nbelow\n.\n\n\nYou can query the connections among structures with these functions:\n\n\n\n\nsource.allConnectionsOut(type)\n returns a list of all destinations to\n   which the source is connected by one or more connections of the given\n   type.  Each destination appears on the list a number of times equal to\n   the number of connections of the given type from the source to that\n   destination.\n\n\ndestination.allConnectionsIn(type)\n functions analogously to the\n   previous, but for connections into a destination, rather than out from a\n   source.\n\n\nsource.allConnectionsOut()\n returns a list of destination-type pairs,\n   all connections that go out from the given source structure.\n\n\ndestination.allConnectionsIn()\n functions analogously to the previous,\n   but for connections into a destination, rather than out from a source.\n\n\n\n\nTo create or destroy connections, use these functions:\n\n\n\n\nsource.connectTo(destination,type)\n, where \nsource\n and \ndestination\n\n   are \nStructure\n instances and \ntype\n is a string containing the type of\n   connection, creates a new connection.  There can be multiple connections\n   between the same two structures, even of the same type.  Returns true if\n   the connection was formed, false if some error prevented it (such as the\n   destination not being a structure, or not having an ID, or the source\n   not having an ID).\n\n\nsource.disconnectFrom(destination,type)\n undoes the previous operation.\n   Because there may be multiple connections between the source and\n   destination of the same type, this simply decreases that number by one.\n   Returns true on success or false on failure (for example, if there were\n   no connection to delete).\n\n\n\n\nIf the \nconnectionsOut\n and \nconnectionsIn\n data is directly manipulated by\nthe client (not recommended), then you can call \nroot.fillOutConnections()\n\nto ensure that the connection data stored in every source matches that\nstored in the corresponding destinations, and vice versa.\n\n\nUnique IDs\n\n\nThe \nStructure\n class maintains a mapping from IDs (as strings) to instances\nof the class.  An instance gets its ID from the attribute with key \"id.\"\nAll IDs in a hierarchy can be tracked (that is, recorded into this\nclass-level mapping) with the \ntrackIDs()\n function documented below.\n\n\nHere are the relevant functions:\n\n\n\n\ninstance.id()\n returns the instance's ID, if it has one, or undefined if\n   not\n\n\ninstance.trackIDs()\n asks the class to update the class variable that\n   maps IDs to instances, recording the connection of all IDs for all nodes\n   in the hierarchy whose root is \ninstance\n.  This will overwrite earlier\n   data in that mapping if and only if you have not kept IDs unique.\n\n\ninstance.untrackIDs()\n removes from the class-level mapping all IDs that\n   appear in the hierarchy whose root is \ninstance\n.  If you are done with\n   a \nStructure\n instance, you must call this function in it, so that its\n   memory is guaranteed to eventually be garbage collected.\n\n\nStructure.instanceWithID(id)\n takes a string ID and yields the instance\n   with that ID, if there is one, and that instance has recorded its ID in\n   the class-level variable for this purpose by means of a call to\n   \ntrackIDs()\n, or null or undefined if there is none.\n\n\n\n\nEvents and event handlers\n\n\nAny \nStructure\n instance fires up to six different types of events during\nits lifetime: \nwillBeInserted\n, \nwasInserted\n, \nwillBeRemoved\n,\n\nwasRemoved\n, \nwillBeChanged\n, and \nwasChanged\n.  To install an event\nhandler for one of these, simply overwrite that key in the \nStructure\n\nobject itself, as in \nmyStructure.willBeRemoved = myHandlerFunction\n.\n\n\nInsertion events are fired immediately before/after the \nStructure\n is added\nas a child under a new parent.  Removal events are fired immediately\nbefore/after the \nStructure\n is removed from an existing parent.  Change\nevents are fired immediately before/after an attribute of the \nStructure\n\ninstance changes.\n\n\nExample:\n\n\n    var A = new Structure();\n    var B = new Structure();\n    A.willBeInserted = function () { console.log( 'Now!' ); };\n    B.insertChild( A ); // prints 'Now!' to console just before inserting", 
            "title": "Structures"
        }, 
        {
            "location": "/api-structures/#api-documentation-for-the-structure-class", 
            "text": "", 
            "title": "API Documentation for the Structure Class"
        }, 
        {
            "location": "/api-structures/#source-code", 
            "text": "The  Structure  class  Unit tests of the  Structure  class", 
            "title": "Source Code"
        }, 
        {
            "location": "/api-structures/#purpose", 
            "text": "The Lurch Deductive Engine (LDE,  documented here ) maintains a\ndocument called the LDE Document, which is a hierarchy (or tree).  The nodes\nin that tree are instances of this class ( Structure ) or one of its\nsubclasses.  We build into this base class all the functionality that must be present at\nevery point in that hierarchy, and leave to subclasses that functionality\nthat makes sense only for specific types of structures.  For instance, this\nclass contains no functionality to support rules of inference, because they\nare one specific type of structure, so their functionality will be\nimplemented in a subclass for that purpose.", 
            "title": "Purpose"
        }, 
        {
            "location": "/api-structures/#constructing-and-serialization", 
            "text": "There is one constructor for the class\n( see source code ):  Structure(child1,child2,...)  creates a new instance, with the given list\nof children, each of which must be a  Structure  instance (or it will be\nignored).  All such children are removed from any old parent they had before\nbeing inserted into this newly created one.  Instances can be converted to and from JSON, for saving to a file, storing\npermanently anywhere, or transmitting across threads or network connections.\nTo ensure that deserialization correctly reconstructs instances of the right\nsubclass of  Structure , each subclass must be registered.  To do so, we\nprovide the  addSubclass  function.  Use it like so.  JavaScript:      MySubclass = function ( /* ... */ ) { /* ... */ };\n    // ...\n    MySubclass.prototype.className = Structure.addSubclass( 'MySubclass', MySubclass );  CoffeeScript, somewhere inside the class definition:      class MySubclass extends Structure\n        # ...\n        className : Structure.addSubclass 'MySubclass', MySubclass\n        # ...  Then one can serialize and deserialize any hierarchy containing  Structure \ninstances, as well as instances of its subclasses, using the member function someInstance.toJSON()  (which obviously yields a JSON structure) or the\nclass function  Structure.fromJSON(data) , which accepts JSON data created\nfrom the first function.  Serializing a structure preserves its class, its attributes ( documented\nbelow ), and the hierarchy for which\nit is the root.", 
            "title": "Constructing and Serialization"
        }, 
        {
            "location": "/api-structures/#structure-hierarchies", 
            "text": "To navigate or alter a hierarchy of  Structure  instances, use the\nfollowing member functions present in each instance.   instance.parent()  yields the parent structure, or  null  if there is\n   no parent (i.e., the instance is the root of a hierarchy)  instance.children()  yields an array containing the children structures,\n   in order, or an empty array if there are none  instance.indexInParent()  yields the index of the child in its parent's\n   ordered list of children, or unddefined if the instance has no parent  instance.previousSibling()  and  instance.nextSibling()  yield the\n   adjacent structure in the parent's child list, forward or backward, as\n   expected, or undefined if there is no such sibling  instance.removeFromParent()  drops the instance from it's parent's list\n   of children (thereby decreasing the length of that child list by 1) and\n   thus making  instance.parent()  null  instance.removeChild(index)  is a convenience equivalent to\n    instance.children()[index].removeFromParent()  instance.insertChild(child,index)  expects a structure instance as the\n   first argument and an index into the children list as the second.  It\n   inserts the new child at that index, thus increasing the number of\n   children by 1.  You may use an index equal to the length of the child\n   list to append.  The child is removed from its previous parent, if any,\n   before being inserted here.  instance.replaceWith(other)  expects another structure instance as its\n   argument.  It removes  instance  from its parent, if there is one, and\n   then inserts  other  at the same index in the parent, thus replacing\n    instance .  This has no effect if  instance  has no parent.  It is\n   equivalent to successive calls to  removeFromParent()  and\n    insertChild()  at the instance and its parent, respectively.  instance.copy()  makes a deep copy of the instance, including all nodes\n   below it in the hierarchy.  This new copy will have all the same IDs as\n   the previous copy, so to preserve uniqueness of IDs, you will usually\n   want to call  copiedInstance.clearIDs()  afterwards.   The order of nodes in the hierarchy is often important.  We have one simple\norder relation on the nodes in the hierarchy, and one more complex.  The\nsimplest is just whether node A is \"earlier than\" node B, in the order\ninduced by an in-order tree traversal (that is, the order in which the open\nparentheses would appear if the tree were written as a LISP expression).\nThis relation can be tested with  instance.isEarlierThan(other) .  The more complex order relation is accessibility, which we do not define\nhere, because it is already defined  in the source code\ndocumentation .\nThat relation is implemented with the following member functions available\nin all instances of the class.   A.isAccessibleTo(B)  implements the relation as defined at the link\n   given above.  A.isInTheScopeOf(B)  is equivalent to  B.isAccessibleTo(A) .  A.iteratorOverAccessibles()  yields an \"iterator\" object, which is an\n   object that can produce the list of nodes accessible to  A  by repeated\n   calls to the  next()  member of the object.  Consider the following\n   JavaScript code that would use such an iterator.       var iterator = A.iteratorOverAccessibles();\n    var accessible;\n    while ( accessible = iterator.next() ) {\n        console.log( 'The next accessible structure is:',\n            accessible.toJSON() );\n    }  Nodes are produced by the iterator in reverse order (under the isEarlierThan  relation) starting from the first accessible node before A .  When the  next()  function yields null for the first time, the end of\nthe list has been reached.  (The  next()  function will yield null forever\nthereafter.)  Iterators are more efficient than producing the entire list and returning\nit, because the client may be seeking just one particular node in the list,\nand thus producing the entire list so that the client can search just a\nsmall part of it could be wasteful.  There is an analogous function for scopes.   A.iteratorOverScope()  functions like  A.iteratorOverAccessibles() , but\n   walks forwards through the structure, including precisely those nodes for\n   which  B.isInTheScopeOf(A)  holds true.   There are then four functions that use these iterators under the hood.\nClients will most likely wish to use these rather than have direct access\nto the iterators.   A.firstAccessible(P)  expects  P  to be a one-place predicate (that is,\n   a JavaScript function that can be evaluated on a single argument, and\n   yields true or false in each case) and yields the first item on the\n   \"accessibles\" list (as given by  A.iteratorOverAccessibles() ) for which\n    P  yields true.  It returns undefined if there is no such thing.  A.firstInScope(P)  expects  P  to be a one-place predicate, as just\n   defined, and behaves just like  firstAccessible() , except it walks\n   through  A.iteratorOverScope()  instead.  A.allAccessibles(P)  expects  P  as in the previous two functions, and\n   yields all nodes accessible to  A  that satisfy  P , in the same order\n   they would be reported by  iteratorOverAccessibles() .  A.allInScope(P)  expects  P  as in the previous two functions, and\n   yields all nodes in the scope of  A  that satisfy  P , in the same order\n   they would be reported by  iteratorOverScope() .", 
            "title": "Structure hierarchies"
        }, 
        {
            "location": "/api-structures/#structure-attributes-and-connections", 
            "text": "The following functions available in each instance of the structure class\nsupport attributes.   instance.getAttribute(key)  looks up attributes by a given string  key .  instance.setAttribute(key,value)  stores attributes under a given\n   string  key  with value  value , which should be a JSON structure (or\n   atomic data).  No check is made to verify that the value is of this\n   type, but errors will transpire later if this condition is not satisfied\n   (specifically, serialization errors).  instance.clearAttributes(key1,key2,...)  removes the key-value pairs\n   of attributes associated with any of the keys passed as parameters.  It\n   is acceptable to pass any number of keys, including just one.  If zero\n   are passed,  all  key-value pairs are removed.  instance.attr(object)  adds all attributes of the given object as\n   attributes to the instance, and returns the instance itself.  This is\n   useful when constructing hierarchies, as follows.       var A = new Structure(\n        ( new Structure() ).attr( { name : 'example structure' } ),\n        ( new Structure() ).attr( { color : '#99ff00' } )\n    );", 
            "title": "Structure attributes and connections"
        }, 
        {
            "location": "/api-structures/#connections-as-a-type-of-attribute", 
            "text": "Within a structure's attributes are two key-value pairs that should not be\nused for any other purpose, those with keys  connectionsOut  and connectionsIn .  These store data about connections between pairs of\nstructures in the same heirarchy.  The data is stored by structure IDs, so\nmaking connections assumes that structures each have a unique ID, as\ndocumented  below .  You can query the connections among structures with these functions:   source.allConnectionsOut(type)  returns a list of all destinations to\n   which the source is connected by one or more connections of the given\n   type.  Each destination appears on the list a number of times equal to\n   the number of connections of the given type from the source to that\n   destination.  destination.allConnectionsIn(type)  functions analogously to the\n   previous, but for connections into a destination, rather than out from a\n   source.  source.allConnectionsOut()  returns a list of destination-type pairs,\n   all connections that go out from the given source structure.  destination.allConnectionsIn()  functions analogously to the previous,\n   but for connections into a destination, rather than out from a source.   To create or destroy connections, use these functions:   source.connectTo(destination,type) , where  source  and  destination \n   are  Structure  instances and  type  is a string containing the type of\n   connection, creates a new connection.  There can be multiple connections\n   between the same two structures, even of the same type.  Returns true if\n   the connection was formed, false if some error prevented it (such as the\n   destination not being a structure, or not having an ID, or the source\n   not having an ID).  source.disconnectFrom(destination,type)  undoes the previous operation.\n   Because there may be multiple connections between the source and\n   destination of the same type, this simply decreases that number by one.\n   Returns true on success or false on failure (for example, if there were\n   no connection to delete).   If the  connectionsOut  and  connectionsIn  data is directly manipulated by\nthe client (not recommended), then you can call  root.fillOutConnections() \nto ensure that the connection data stored in every source matches that\nstored in the corresponding destinations, and vice versa.", 
            "title": "Connections as a type of attribute"
        }, 
        {
            "location": "/api-structures/#unique-ids", 
            "text": "The  Structure  class maintains a mapping from IDs (as strings) to instances\nof the class.  An instance gets its ID from the attribute with key \"id.\"\nAll IDs in a hierarchy can be tracked (that is, recorded into this\nclass-level mapping) with the  trackIDs()  function documented below.  Here are the relevant functions:   instance.id()  returns the instance's ID, if it has one, or undefined if\n   not  instance.trackIDs()  asks the class to update the class variable that\n   maps IDs to instances, recording the connection of all IDs for all nodes\n   in the hierarchy whose root is  instance .  This will overwrite earlier\n   data in that mapping if and only if you have not kept IDs unique.  instance.untrackIDs()  removes from the class-level mapping all IDs that\n   appear in the hierarchy whose root is  instance .  If you are done with\n   a  Structure  instance, you must call this function in it, so that its\n   memory is guaranteed to eventually be garbage collected.  Structure.instanceWithID(id)  takes a string ID and yields the instance\n   with that ID, if there is one, and that instance has recorded its ID in\n   the class-level variable for this purpose by means of a call to\n    trackIDs() , or null or undefined if there is none.", 
            "title": "Unique IDs"
        }, 
        {
            "location": "/api-structures/#events-and-event-handlers", 
            "text": "Any  Structure  instance fires up to six different types of events during\nits lifetime:  willBeInserted ,  wasInserted ,  willBeRemoved , wasRemoved ,  willBeChanged , and  wasChanged .  To install an event\nhandler for one of these, simply overwrite that key in the  Structure \nobject itself, as in  myStructure.willBeRemoved = myHandlerFunction .  Insertion events are fired immediately before/after the  Structure  is added\nas a child under a new parent.  Removal events are fired immediately\nbefore/after the  Structure  is removed from an existing parent.  Change\nevents are fired immediately before/after an attribute of the  Structure \ninstance changes.  Example:      var A = new Structure();\n    var B = new Structure();\n    A.willBeInserted = function () { console.log( 'Now!' ); };\n    B.insertChild( A ); // prints 'Now!' to console just before inserting", 
            "title": "Events and event handlers"
        }
    ]
}