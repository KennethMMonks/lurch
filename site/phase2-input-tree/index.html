<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Phase 2, The Input Tree - Lurch Deductive Engine Documentation</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">Lurch Deductive Engine Documentation</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Home</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Design Plans <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../design-overview/">Overview</a>
</li>
                            
<li >
    <a href="../phase1-structures/">Phase 1, Structures</a>
</li>
                            
<li class="active">
    <a href="./">Phase 2, The Input Tree</a>
</li>
                            
<li >
    <a href="../phase3-output-tree/">Phase 3, The Output Tree</a>
</li>
                            
<li >
    <a href="../phase4-modification/">Phase 4, Modification</a>
</li>
                            
<li >
    <a href="../phase5-interpretation/">Phase 5, Interpretation</a>
</li>
                            
<li >
    <a href="../phase6-labels/">Phase 6, Labels</a>
</li>
                            
<li >
    <a href="../phase7-validation/">Phase 7, Validation</a>
</li>
                            
<li >
    <a href="../phase8-expressions-and-rules/">Phase 8, Expressions and Rules</a>
</li>
                            
<li >
    <a href="../enhancements/">Enhancements for Later</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">API Documentation <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../api-overview/">Overview</a>
</li>
                            
<li >
    <a href="../api-lde/">The LDE</a>
</li>
                            
<li >
    <a href="../api-structures/">Structures</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../phase1-structures/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../phase3-output-tree/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#lde-design-phase-2-the-input-tree">LDE Design Phase 2: The Input Tree</a></li>
            <li><a href="#content">Content</a></li>
            <li><a href="#goal">Goal</a></li>
            <li><a href="#status">Status</a></li>
            <li><a href="#inputstructure-class">InputStructure class</a></li>
            <li><a href="#accepting-actual-instances">Accepting actual instances</a></li>
            <li><a href="#marking-structures-dirty">Marking structures dirty</a></li>
            <li><a href="#connecting-modules">Connecting modules</a></li>
            <li><a href="#lde-api">LDE API</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p>We have designed the work on the Lurch Deductive Engine (LDE) to progress in
phases.  The idea is that each phase ends with a completed whole that can be
tested in that state, and that provides more features than the previous
state did.  By the time the final phase is complete, the LDE will be a
robust and useful product.</p>
<h1 id="lde-design-phase-2-the-input-tree">LDE Design Phase 2: The Input Tree</h1>
<h2 id="content">Content</h2>
<p>In this phase, we add the Input Tree, a hierarchy comprised of a new kind of
<code>Structure</code> subclass, called <code>InputStructure</code>.</p>
<h2 id="goal">Goal</h2>
<p>The <code>InputStructure</code> class will exist and be used by the LDE module.</p>
<h2 id="status">Status</h2>
<p>This has been partially implemented.  See the tasks below, some marked
complete and some not yet marked complete.</p>
<h2 id="inputstructure-class"><code>InputStructure</code> class</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled checked/> Create a subclass of <code>Structure</code>, in its own new module,
   <code>src/input-structure.litcoffee</code>.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Add documentation explaining what it is and will do (though that
   documentation can grow with time).</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Ensure that the <code>InputStructure</code> subclass registers itself with the
   serialization code, as
   <a href="https://github.com/lurchmath/lde/blob/master/src/structure.litcoffee#registering-class-names">the documentation here</a>
   describes.  (That is, use a line like
   <code>className : Structure.addSubclass 'InputStructure', InputStructure</code> in
   the <code>InputStructure</code> class code.)</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Rewrite the LDE module so that it no longer takes as input generic
   <code>Structure</code> instances, but specifically <code>InputStructure</code> instances.  All
   of its methods should be updated to use <code>InputStructure</code>s where they
   currently use <code>Structure</code>s.  This will require importing the
   <code>input-structure.litcoffee</code> module instead of the generic
   <code>structure.litcoffee</code> one.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Rename the global <code>Structure</code> hierarchy in that file to be
   <code>InputTree</code> rather than <code>LDEDocument</code>.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Update all documentation in that file to reflect the changes just
   made.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Update all unit tests of the LDE module to reflect this change to
   <code>InputStructure</code>s.  This will require importing the
   <code>input-structure.litcoffee</code> module instead of the generic
   <code>structure.litcoffeee</code> one.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Create a new unit test file for <code>InputStructure</code>s that is extremely
   basic, just testing to be sure that the symbol <code>InputStructure</code> is
   defined at the global scope and creates things that are instances of the
   generic <code>Structure</code> base class.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Add documentation for that unit test file, following the pattern
   established in the documentation of other unit test files in this
   repository.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="accepting-actual-instances">Accepting actual instances</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled checked/> The LDE module was written to accept only JSON-serialized forms of
   <code>Structure</code>s as parameters to its methods.  Update those functions so
   that they now accept either serialized forms or actual instances, and can
   tell the difference and respond appropriately.  (That is, deserialize any
   serialized instances, but don't do that if the argument was already an
   instance.)</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Extend the unit test suite of the LDE module so that it tests this
   new feature of each API method of the LDE module.</li>
<li class="task-list-item"><input type="checkbox" disabled checked/> Update all documentation in that file to reflect the changes just
   made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="marking-structures-dirty">Marking structures dirty</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Extend the base <code>Structure</code> class with a field called <code>dirty</code>, which
   is initialized to false in the constructor.  This field does not need to
   be part of any serialization or deserialization of instances.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create an <code>isDirty()</code> method that returns the value of that member
   variable.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create a <code>markDirty()</code> method in the <code>InputStructure</code> class that sets
   the <code>dirty</code> flag to true, and does so for all ancestors as well.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update all documentation in that file to reflect the changes just
   made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add to the unit tests for <code>InputStructure</code>s a few simple tests for
   these new routines.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation in that file describing the changes just made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="connecting-modules">Connecting modules</h2>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Give the <code>Structure</code> class a class method called <code>feedback</code>, whose
   default implementation just writes to the console saying that the
   feedback implementation doesn't exist yet.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Give the <code>InputStructure</code> class a method called <code>feedback</code>, accepting
   a data object as parameter, and extending it with a <code>subject</code> field whose
   value is the unique ID of the <code>InputStructure</code> in question, then passing
   that new object on to the <code>feedback</code> class method in the <code>Structure</code>
   class.</li>
<li class="task-list-item"><input type="checkbox" disabled/> In the LDE module, if it detects that it has been loaded in Node.js
   or the main browser thread, then create a global variable called
   <code>Feedback</code> that is an instance of <code>EventTarget</code>.  In the module case,
   export that variable; in the browser case, just let it be global.</li>
<li class="task-list-item"><input type="checkbox" disabled/> In the LDE, create a module-global <code>feedback</code> function that does one
   of two things:<ul>
<li>If it detects that the LDE is running in a Node.js module or in the
  main browser thread, it calls, in the global <code>Feedback</code> object,
  <code>dispatchEvent(e)</code>, where the <code>Event e</code> holds the parameter passed to
  <code>feedback</code>.</li>
<li>If it detects that the LDE is running in a WebWorker (or the
  equivalent construct in Node.js), it sends its parameter along by
  posting a message to be heard by the parent thread.</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" disabled/> In the LDE, when it imports the <code>Structure</code> module, have it overwrite
   the default implementation of <code>feedback</code> in the <code>Structure</code> class with
   a call directly to the <code>feedback</code> function in the LDE.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update all documentation in that file to reflect the changes just
   made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add to the unit tests for <code>InputStructure</code>s a few simple tests for
   these new routines.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add documentation in that file describing the changes just made.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Once the unit tests pass, build everything and commit.</li>
</ul>
<h2 id="lde-api">LDE API</h2>
<h3 id="small-miscellaneous-updates">Small, Miscellaneous Updates</h3>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Now that we have changed from a generic <code>Structure</code> class paradigm to
   specific Input and Output Structures, reread the API Documentation of
   both <a href="../api-lde/">the LDE</a> and <a href="../api-structures/">the Structure class</a>,
   updating anything that's out-of-date.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add a page to the API documentation for the <code>InputStructure</code> class
   and all of its upcoming subclasses.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update <code>mkdocs.yml</code> in the project root to include that new file in
   the generated documentation.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update the API in the LDE module to include the word "Structure" in
   each method call, because we will soon add methods for connections as
   well.  So for instance, make it <code>insertStructure</code> rather than just
   <code>insert</code>, and so on.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update all unit tests and API documentation, and when the unit test
   pass, then commit.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Tweak the existing <code>setStructureAttribute()</code> API method so that it
   does not permit the client to use attribute names that begin with an
   underscore, so that we can "namespace" those for internal purposes.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update the LDE API documentation page to cover these new routines.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add a unit test for that change to <code>setStructureAttribute()</code> as well.</li>
</ul>
<h3 id="upgrading-connections">Upgrading Connections</h3>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Update the implementation in the <code>Structure</code> method for connections,
   to satisfy the following requirements.<ul>
<li>Do not put all connections data in one big attribute.  Rather, when
  creating a connection between two nodes, place it in an attribute with
  a key of the form <code>_connection_N</code> for some natural number <code>N</code> not yet
  used by either endpoint of the connection.  This number <code>N</code> should be
  returned by the routine; always use <code>N</code>&gt;1 so that we do not mistake
  <code>N</code>=0 for a return of a false value, as if the routine failed.</li>
<li>Do not restrict the third element of the connection tuple to being a
  string, but permit it to be arbitrary JSON data.  Store this only in
  the source of the connection, so as not to waste space.  This will
  necessitate changing the signature for disconnecting to not take a
  connection triple (source, target, type) but rather just the number
  <code>N</code> used when the connection was created.</li>
</ul>
</li>
<li class="task-list-item"><input type="checkbox" disabled/> All the unit tests should still pass; ensure this, then write a few
   more tests to ensure that you can use non-string JSON data as the third
   parameter when setting up the connection.  Then commit.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add to the API a new method, <code>insertConnection(source,target,data)</code>,
   which connects two <code>InputStructure</code>s that are already in the Input Tree.
   We require each newly inserted connection to have, in its <code>data</code> object,
   an attribute whose key is "id" and whose values are strings that are
   unique across the Input Tree.  The <code>source</code> and <code>target</code> parameters are
   unique ids, just as <code>parent</code> is for <code>insertStructure</code>.  The <code>data</code>
   parameter is any JSON data that will be stored with the connection.
   If any of the above requirements on the parameters are not satisfied,
   the routine does nothing.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add to the API a new method, <code>removeConnection(id)</code>, which
   disconnects two <code>InputStructure</code>s that are connected by the connection
   whose unique id was given.  If the parameter isn't the unique id for a
   connection in the Input Tree, the routine does nothing.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add to the API a new method,
   <code>setConnectionAttribute(connection,key,value)</code>, which alters the data of
   an existing connection between two <code>InputStructure</code>s in the Input Tree.
   The first parameter must be the unique id of a connection, just as with
   <code>removeConnection</code>.  The <code>key</code> should be a string that is the key of the
   attribute to be modified, but if it is not a string it will be converted into one using the <code>String</code> constructor.  It cannot be the string "id"
   because that attribute must remain constant throughout the life of any
   connection.  The <code>value</code> can be any JSON data to use as the new attribute
   value, or <code>undefined</code> to indicate that the key-value pair should be
   deleted.  If any of the above requirements on the parameters are not
   satisfied, the routine does nothing.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create unit tests for all of these new routines and ensure that they
   pass.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Rebuild docs and commit.</li>
</ul>
<h3 id="policing-connections">Policing Connections</h3>
<ul class="task-list">
<li class="task-list-item"><input type="checkbox" disabled/> Add a function to the <code>Structure</code> class,
   <code>connectionsOutsideSubtree()</code>, which finds all connections that lead from
   any node in the subtree to nodes outside the subtree, and returns them in
   a list.  Each element in the list should be an object of the form
   <code>{ structure : structureInstance, number : connectionNumber }</code>, where the
   number is the <code>N</code> used in the attribute storing the connection.  This
   will be useful in the following routine, and also for clients who wish to
   know which connections may be severed by the following routine
   beforehand, so that they might move them or record them for later
   reconnecting somewhere.  (Document this function with this purpose.)</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update the <code>removeStructure()</code> function in the LDE API so that, if
   there are any connections from the structure being removed to other
   <code>InputStructure</code> instances <em>not</em> being removed, then those connections
   are severed as part of the removal process.  (Connections among the
   descendants of a subtree removed as a whole should stay connected.)</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add unit tests to ensure that these routines work.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Update the <code>replaceStructure()</code> function in the LDE API so that, if
   there are any connections from the structure being replaced to other
   <code>InputStructure</code> instances <em>not</em> being altered, then those connections
   are severd as part of the replacement process.  (Connections among the
   descendants of a subtree replaced as a whole should stay connected.)</li>
<li class="task-list-item"><input type="checkbox" disabled/> Create a function in the <code>Structure</code> class that will transfer all
   connections in/out of node <code>X</code> to node <code>Y</code> instead, written as
   <code>X.transferConnectionsTo( Y )</code>.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Document the above routine as something that <code>interpret()</code> routines
   are welcome to use, if it is useful to them.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add an optional third parameter to <code>replaceStructure()</code>, which
   defaults to false, but can be set to true to have <code>replaceStructure()</code>
   transfer all such connections to the replacement structure, rather than
   just sever them.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Add unit tests to ensure that these features work.</li>
<li class="task-list-item"><input type="checkbox" disabled/> Rebuild and commit.</li>
</ul></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script src="../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../search/require.js"></script>
        <script src="../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
